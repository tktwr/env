*make-jp.txt*      Make マニュアル

* Make: (make).            Remake files automatically.


File: make-jp.info, Node: Top, Next: Overview, Up: (dir)

Make
****

The GNU `make' utility automatically determines which pieces of a
large program need to be recompiled, and issues the commands to
recompile them.

This edition of the `GNU Make Manual', last updated 04 April 2000,
documents GNU `make' Version 3.79.

This manual describes `make' and contains the following chapters:

* Menu:

* Overview::                    Overview of `make'.
* Introduction::                An introduction to `make'.
* Makefiles::                   Makefiles tell `make' what to do.
* Rules::                       Rules describe when a file must be remade.
* Commands::                    Commands say how to remake a file.
* Using Variables::             You can use variables to avoid repetition.
* Conditionals::                Use or ignore parts of the makefile based
                                 on the values of variables.
* Functions::                   Many powerful ways to manipulate text.
* Invoking make: Running.       How to invoke `make' on the command line.
* Implicit Rules::              Use implicit rules to treat many files alike,
                                 based on their file names.
* Archives::                    How `make' can update library archives.
* Features::                    Features GNU `make' has over other `make's.
* Missing::                     What GNU `make' lacks from other `make's.
* Makefile Conventions::        Conventions for makefiles in GNU programs.
* Quick Reference::             A quick reference for experienced users.
* Error Messages::              A list of common errors generated by `make'.
* Complex Makefile::            A real example of a straightforward,
                                 but nontrivial, makefile.
* Concept Index::               Index of Concepts
* Name Index::                  Index of Functions, Variables, & Directives

 -- The Detailed Node Listing ---

Overview of `make'

* Preparing::                   Preparing and Running Make
* Reading::                     On Reading this Text
* Bugs::                        Problems and Bugs

An Introduction to Makefiles

* Rule Introduction::           What a rule looks like.
* Simple Makefile::             A Simple Makefile
* How Make Works::              How `make' Processes This Makefile
* Variables Simplify::          Variables Make Makefiles Simpler
* make Deduces::                Letting `make' Deduce the Commands
* Combine By Prerequisite::     Another Style of Makefile
* Cleanup::                     Rules for Cleaning the Directory

Writing Makefiles

* Makefile Contents::           What makefiles contain.
* Makefile Names::              How to name your makefile.
* Include::                     How one makefile can use another makefile.
* MAKEFILES Variable::          The environment can specify extra makefiles.
* Remaking Makefiles::          How makefiles get remade.
* Overriding Makefiles::        How to override part of one makefile
                                 with another makefile.
* Reading Makefiles::           How makefiles are parsed.

Writing Rules

* Rule Example::                An example explained.
* Rule Syntax::                 General syntax explained.
* Wildcards::                   Using wildcard characters such as `*'.
* Directory Search::            Searching other directories for source files.
* Phony Targets::               Using a target that is not a real file's name.
* Force Targets::               You can use a target without commands
                                  or prerequisites to mark other
                                  targets as phony.
* Empty Targets::               When only the date matters and the
                                  files are empty.
* Special Targets::             Targets with special built-in meanings.
* Multiple Targets::            When to make use of several targets in a rule.
* Multiple Rules::              How to use several rules with the same target.
* Static Pattern::              Static pattern rules apply to multiple targets
                                  and can vary the prerequisites according to
                                  the target name.
* Double-Colon::                How to use a special kind of rule to allow
                                  several independent rules for one target.
* Automatic Prerequisites::     How to automatically generate rules giving
                                 prerequisites from source files themselves.

Using Wildcard Characters in File Names

* Wildcard Examples::           Several examples
* Wildcard Pitfall::            Problems to avoid.
* Wildcard Function::           How to cause wildcard expansion where
                                  it does not normally take place.

Searching Directories for Prerequisites

* General Search::              Specifying a search path that applies
                                  to every prerequisite.
* Selective Search::            Specifying a search path
                                  for a specified class of names.
* Search Algorithm::            When and how search paths are applied.
* Commands/Search::             How to write shell commands that work together
                                  with search paths.
* Implicit/Search::             How search paths affect implicit rules.
* Libraries/Search::            Directory search for link libraries.

Static Pattern Rules

* Static Usage::                The syntax of static pattern rules.
* Static versus Implicit::      When are they better than implicit rules?

Writing the Commands in Rules

* Echoing::                     How to control when commands are echoed.
* Execution::                   How commands are executed.
* Parallel::                    How commands can be executed in parallel.
* Errors::                      What happens after a command execution error.
* Interrupts::                  What happens when a command is interrupted.
* Recursion::                   Invoking `make' from makefiles.
* Sequences::                   Defining canned sequences of commands.
* Empty Commands::              Defining useful, do-nothing commands.

Recursive Use of `make'

* MAKE Variable::               The special effects of using `$(MAKE)'.
* Variables/Recursion::         How to communicate variables to a sub-`make'.
* Options/Recursion::           How to communicate options to a sub-`make'.
* -w Option::                   How the `-w' or `--print-directory' option
                                 helps debug use of recursive `make' commands.

How to Use Variables

* Reference::                   How to use the value of a variable.
* Flavors::                     Variables come in two flavors.
* Advanced::                    Advanced features for referencing a variable.
* Values::                      All the ways variables get their values.
* Setting::                     How to set a variable in the makefile.
* Appending::                   How to append more text to the old value
                                  of a variable.
* Override Directive::          How to set a variable in the makefile even if
                                  the user has set it with a command argument.
* Defining::                    An alternate way to set a variable
                                  to a verbatim string.
* Environment::                 Variable values can come from the environment.
* Automatic::                   Some special variables have predefined
                                  meanings for use with implicit rules.

Advanced Features for Reference to Variables

* Substitution Refs::           Referencing a variable with
                                  substitutions on the value.
* Computed Names::              Computing the name of the variable to refer to.

Conditional Parts of Makefiles

* Conditional Example::         Example of a conditional
* Conditional Syntax::          The syntax of conditionals.
* Testing Flags::               Conditionals that test flags.

Functions for Transforming Text

* Syntax of Functions::         How to write a function call.
* Text Functions::              General-purpose text manipulation functions.
* File Name Functions::         Functions for manipulating file names.
* Foreach Function::            Repeat some text with controlled variation.
* Call Function::               Expand a user-defined function.
* Origin Function::             Find where a variable got its value.
* Shell Function::              Substitute the output of a shell command.

How to Run `make'

* Makefile Arguments::          How to specify which makefile to use.
* Goals::                       How to use goal arguments to specify which
                                  parts of the makefile to use.
* Instead of Execution::        How to use mode flags to specify what
                                  kind of thing to do with the commands
                                  in the makefile other than simply
                                  execute them.
* Avoiding Compilation::        How to avoid recompiling certain files.
* Overriding::                  How to override a variable to specify
                                  an alternate compiler and other things.
* Testing::                     How to proceed past some errors, to
                                  test compilation.
* Options Summary::             Summary of Options

Using Implicit Rules

* Using Implicit::              How to use an existing implicit rule
                                  to get the commands for updating a file.
* Catalogue of Rules::          A list of built-in implicit rules.
* Implicit Variables::          How to change what predefined rules do.
* Chained Rules::               How to use a chain of implicit rules.
* Pattern Rules::               How to define new implicit rules.
* Last Resort::                 How to defining commands for rules
                                  which cannot find any.
* Suffix Rules::                The old-fashioned style of implicit rule.
* Implicit Rule Search::        The precise algorithm for applying
                                  implicit rules.

Defining and Redefining Pattern Rules

* Pattern Intro::               An introduction to pattern rules.
* Pattern Examples::            Examples of pattern rules.
* Automatic::                   How to use automatic variables in the
                                  commands of implicit rules.
* Pattern Match::               How patterns match.
* Match-Anything Rules::        Precautions you should take prior to
                                  defining rules that can match any
                                  target file whatever.
* Canceling Rules::             How to override or cancel built-in rules.

Using `make' to Update Archive Files

* Archive Members::             Archive members as targets.
* Archive Update::              The implicit rule for archive member targets.
* Archive Pitfalls::            Dangers to watch out for when using archives.
* Archive Suffix Rules::        You can write a special kind of suffix rule
                                  for updating archives.

Implicit Rule for Archive Member Targets

* Archive Symbols::             How to update archive symbol directories.




File: make-jp.info, Node: Overview, Next: Introduction, Prev: Top, Up: Top

`make'の概要
************

`make'ユーティリティは、大規模なプログラムのどの部分が再コンパイルされ
なければならないか、あるいは再コンパイルの命令に関する問題を自動的に決
定します。本書は、Richard StallmanとRoland McGrathによって実装された
GNU `make' について書かれたもので、開発自体は、Version 3.76からはPaul
D. Smithによって行なわれています。

GNU `make' は、`IEEE Standard 1003.2-1992' （POSIX.2）の6.2節に適合し
ます。

ここでは、もっとも一般的なC言語によるプログラム例を示しますが、シェル
コマンドによって動作するコンパイラを用いるプログラム言語であれば、どん
なコンパイラでもこの`make'を利用することができます。実際、`make'はプロ
グラム自体の制約を受けず、たとえば一部のファイルが自動的に更新されなけ
ればならないようなタスクを記述することができます。

* Menu:

* Preparing::                   Preparing and Running Make
* Reading::                     On Reading this Text
* Bugs::                        Problems and Bugs



File: make-jp.info, Node: Preparing, Next: Reading, Up: Overview

準備とMakeの実行
================

`make'を使用するためには、プログラムのファイル間の関係を記述する
"makefile"を準備しなければならず、これによってそれぞれのファイルの更新
を指示することになります。一般的には、ソースファイルから次々にコンパイ
ルされるオブジェクトファイルの更新によって実行可能ファイルが作られてい
きます。

したがって、適切な"makefile"があれば、ソースファイルに変更を加えるたび
にこの簡単なシェルコマンドを実行すればよいのです。

     make

これだけで再コンパイルに必要なすべてが行なわれます。`make'はどのファイ
ルが更新されなければならないかを決定するためにmakefileデータベースとファ
イルの最終更新時刻を用います。これによって、それぞれのファイルについて
データベースに記録された命令が実行されるのです。

また、`make'に引数を付加することによって、どのファイルをあるいはどのよ
うにコンパイルするかの制御を行なうこともできます。*Note `make'をどのよ
うに実行するか: Running.。



File: make-jp.info, Node: Reading, Next: Bugs, Prev: Preparing, Up: Overview

マニュアルの読み方
==================

読者が`make'に不慣れだったり、一般的な入門書を探している場合には、各章
の始めの部分を読み、そのあとの節は読み飛ばしてください。各章の始めの節
では入門的な、あるいは一般的なことが記述されていて、続く節では特殊なま
たはテクニカルなことが記述されています。ただし、*Note イントロダクショ
ン: Introduction.は例外で、入門編となっています。

読者がほかの`make'プログラミングに慣れている場合には、*Note GNU `make'
の機能: Features.を読んでください。それにはGNUの`make'の拡張されている
部分と*Note 非互換性と欠けている機能: Missing.にあるようにGNU`make'の
非互換な部分や機能として持たないものについて記述されています。

また、短時間で要約を見るためには、*Note オプションのサマリー: Options
Summary.  や*Note クイックリファレンス: Quick Reference.や*Note 特別な
組み込み済みのターゲット: Special Targets.を参照してください。



File: make-jp.info, Node: Bugs, Prev: Reading, Up: Overview

問題とバグについて
==================

さらに、読者が`make'について問題を抱えたり、バグを発見した場合には、開
発者まで報告をお願いします。すべてについての確約はできませんが、バグ
フィックスはしていきたいと考えます。

ただし、バグの報告のまえに必ずそれが本当にバグなのかどうかを確認してく
ださい。ドキュメントを慎重に読み返して、試そうとしていることが可能なこ
とかどうかを確認してください。可能なのかどうかが明確でない場合にはその
ことを報告してください。なぜなら、それ自体がドキュメントのバグである可
能性もあるためです。

バグを報告したり、自分でバグフィックスを行なうまえに、問題を再現できる
最低限のmakefileに分離して、それを`make'の結果とともに送ってください。
また、実行によって期待していた結果についても送ってください。それによっ
て、問題がドキュメントにあったのかどうかを判断することができます。

そして、たしかに問題がある場合には以下に電子メールを送ってください。

         bug-make@gnu.org

その際には、使用した`make'のバージョンを書くようにしてください。バージョ
ンは、コマンド`make --version'によって取得できます。併せて、使用してい
るマシンのタイプやオペレーティングシステム、さらに可能であれば、コンフィ
ギュレーションプロセスで生成される`config.h'の内容も含むようにしてくだ
さい。



File: make-jp.info, Node: Introduction, Next: Makefiles, Prev: Overview, Up: Top

イントロダクション
******************

読者が`make'に何をさせるかを指示するために"makefile"と呼ばれるファイル
が必要であり、これが`make'に対してコンパイルやリンクの指示をするのです。

この章では、8つのC（言語）のソースファイルと3つのヘッダファイルからな
るテキストエディタのプログラムのコンパイルとリンクを行なう簡単な
makefileについて記述します。また、このmakefileではたとえばクリーンオペ
レーションを行なう種々の命令の実行も`make'に指示します。より複雑な
makefileの例は、*Note 複雑なmakefileの例: Complex Makefile.を参照して
ください。

`make'によってエディタプログラムが再コンパイルされる際は、変更のあるC
のソースファイルもコンパイルされなければならず、ヘッダファイルが変更さ
れた場合にもそのヘッダを含むCのソースファイルは再コンパイルされなけれ
ばなりません。また、それぞれのコンパイルによりソースに対応するオブジェ
クトファイルが作り出されます。最終的には、なんらかのソースファイルが再
コンパイルされた場合には、すべてのオブジェクトファイルは新たに作成され
るか、前回コンパイルされたかにかかわらず、新たな実行可能なエディタプロ
グラムにリンクされなければならないのです。

* Menu:

* Rule Introduction::           What a rule looks like.
* Simple Makefile::             A Simple Makefile
* How Make Works::              How `make' Processes This Makefile
* Variables Simplify::          Variables Make Makefiles Simpler
* make Deduces::                Letting `make' Deduce the Commands
* Combine By Prerequisite::     Another Style of Makefile
* Cleanup::                     Rules for Cleaning the Directory



File: make-jp.info, Node: Rule Introduction, Next: Simple Makefile, Up: Introduction

ルールとはどのようなものか
==========================

以下のようなルールを持つ、簡単なmakefileを見てください。

     TARGET ... : PREREQUISITES ...
             COMMAND
             ...
             ...

"ターゲット"は、通常はプログラムで生成される実行可能またはオブジェクト
ファイルの名称ですが、`clean'のように実行の動作を表わすこともあります
（*Note 偽のターゲット: Phony Targets..）。

"前提条件"は、ターゲットを作成する際の入力として用いられ、多くの場合い
くつかのファイルからなっています。

"コマンド"は、`make'が実行する動作で、あるルールを示す行には複数の命令
を記述することができます。*［Please Note:］*コマンドラインの先頭はタブ
で始めなければなりません。これは不注意を捉えるためですが、わかりにくい
ところでもあります。

通常、命令は前提条件のルールのなかに置かれ、この前提条件が変更になった
場合でもターゲットファイルを作成できます。しかし、ターゲットそのものに
対する命令を指定するルールの場合は、前提条件を必要としません。たとえば、
ターゲットが`clean'のような削除命令を含むルールの場合には前提条件を持
ちません。

また、1つの"ルール"は、そのルールのターゲットであるファイルをどのよう
に、いつまたmakeするのかについて記述されていて、`make'はターゲットを作
成または更新するための前提条件に基づいて命令を実行します。さらに、ルー
ルはそのほかの動作についても、どのように、また、いつの時点で動作するの
かについても記述されています。*Note ルールの記述: Rules.。

makefileはルール以外のテキストを含んでいる場合もありますが、簡単な
makefileではルールだけを記述してあればよく、多少複雑に見える場合でも多
かれ少なかれテンプレートのパターンと同様です。



File: make-jp.info, Node: Simple Makefile, Next: How Make Works, Prev: Rule Introduction, Up: Introduction

簡単なMakefile
==============

ここでは、実行可能な`edit'プログラムの簡単なmakefileを扱います。このプ
ログラムは8つのオブジェクトに依存し、さらにこのオブジェクトは8つのCの
ソースと3つのヘッダから成り立っています。

この例では、すべてのCのソースは`defs.h'を含み、`edit'コマンドを定義す
るソースだけは`command.h'を含み、編集バッファを変更する低レベルの部分
のソースだけは`buffer.h'の各ヘッダを含んでいます。

     edit : main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

長い行の場合は、バックスラッシュと改行によって2行にわたって記述するこ
とができ、読みやすくすることができます。

このmakefileを使って`edit'の実行ファイルを作ることができ、このためには
キーボードから以下のように入力します。

     make

また、このmakefileを使って実行可能なファイルとすべてのオブジェクトをそ
のディレクトリから削除する場合には、以下のように入力します。

     make clean

このmakefileの例では、実行可能な`edit'、オブジェクト`main.o'と
`kbd.oo'、さらにこれらに必要な`main.c'と`defs.h'が含まれ、
それぞれの`.o'ファイルはターゲットでもあり、必須のものでもあります。
コマンドとしては`cc -c main.c'と`cc -c kbd.c'が含まれて
います。

ターゲットがファイルである場合には、必須条件（となるファイル）になんら
かの変更があった際にはふたたびコンパイルされ、リンクされる必要がありま
す。さらにいかなる必要条件であっても自動的に生成されアップデートされる
必要があります。この`edit'の例でも、8つのオブジェクトファイルに依存し
ていて、`main.o'はソースファイル`main.c'とヘッダファイル`defs.h'に依存
しています。

一方、シェルコマンドはターゲットと必要条件を含む行を辿っていき、ターゲッ
トとなるファイルをどのようにアップデートするかを示します。また、
makefile中のほかの命令とを区別するために、各行の先頭にはタブ文字が置か
れます。（覚えておかなければならないのは、`make'自身は各命令がどのよう
に動作するかについてはまったく感知せず、ターゲットとなるファイルが適切
にアップデートされるための命令の使用はユーザーに任されるということです。
ターゲットとなるファイルがいつの時点でアップデートされなければならない
かというルールに従って、すべての`make'が実行されます。）

また、ターゲット`clean'はファイルではなく動作の名前です。通常、ルール
のなかではこれを実行することはないため、必要条件とはなりません。したがっ
て、明確に指示しない限り、`make'は`clean'の動作を行なうことはありませ
ん。注意しなければならないのは、この`clean'の動作は必要条件ではないだ
けではなく、ほかにいかなる必要条件も持たないことから、ルールの唯一の目
的は、指定された命令の実行であるということです。ファイルを参照せずに動
作だけであるターゲットは、"phony targets"（偽のターゲット）と呼ばれま
す。このようなターゲットについては、*Note 偽のターゲット: Phony
Targets.。`make'が`rm'などの命令によるエラーをどのように無視するかといっ
た事柄については、*Note コマンドのエラー: Errors.。



File: make-jp.info, Node: How Make Works, Next: Variables Simplify, Prev: Simple Makefile, Up: Introduction

`make'はどのようにMakefileを処理するのか
========================================

デフォルトでは、`make'は`.'で始まる名前ではないターゲットから開始され、
これは"default goal"（デフォルトゴール）と呼ばれます。デフォルトゴール
が`make'が最終的に到達しようとする"ゴール"となります。*Note ゴールを指
定する引数: Goals.。

前節の簡単な例では、デフォルトゴールは、実行可能な`edit' プログラムの
アップデートでした。したがって、最初にそのルールを置くことになります。

コマンドは以下のように実行します。

     make

`make'はカレントディレクトリにあるmakefileを読み出し、最初のルールを実
行して開始されます。この例では、`edit'を再リンクすることですが、`make'
はこのルールを実行するまえに`edit'が依存するファイルに対するルールを実
行しなければなりません。それらの各ファイルはそれぞれのルールに基づいて
処理されます。すなわち、ソースファイルをコンパイルして`.o'をアップデー
トします。再コンパイルは、オブジェクトファイルが存在しなかったり、タイ
ムスタンプが新しくなっている場合に必要条件であるソースファイルやヘッダ
ファイルに対して行なわれます。

ほかのルールは、そのターゲットがゴールの必要条件として出現する際に、
処理されます。仮にいくつかのほかのルールがゴールの依存対象となっていない
場合には、明確に`make clean'のようなコマンドを実行しない限り
そのルールは処理されません。

オグジェクトの再コンパイルのまえに、`make'は必要条件であるソースファイ
ルとヘッダファイルのアップデートを考慮します。`.c'や`.h'ファイルがどの
ルールのターゲットでもないことや、これらのファイルに対してmakefileでは
何も動作を特定しないため、`make'はこれらのファイルに対して何も操作を行
ないません。しかしながら、BisonやYaccによって生成されたCプログラムにつ
いては、それ自身のルールに従って自動的にアップデートしようとします。

必要とされるオブジェクトの再コンパイルのあと、`make'は`edit'と再リンク
するかどうかを決定します。この決定は`edit'が存在しないか、あるいはオブ
ジェクトファイルがより新しいものである場合には必ず行なわれます。もし、
オブジェクトファイルが今まさに再コンパイルされたばかりで、`edit'よりも
新しいタイムスタンプである場合は`edit'は再リンクされます。

したがって、ファイル`insert.c'に変更を加えたあと、`make'を実行した場合
には、`insert.o'をアップデートするためにコンパイルを行ない、`edit'にリ
ンクを行ないます。また、`command.h'に変更を加えて`make'を実行した場合
には、オブジェクトファイル`kbd.o'と`command.o'と`files.o'をコンパイル
によってアップデートし、`edit'にリンクを行ないます。



File: make-jp.info, Node: Variables Simplify, Next: make Deduces, Prev: How Make Works, Up: Introduction

変数によるMakefileの簡素化
==========================

ここでの例では、`edit'のルールにおいて、すべてのオブジェクトファイルを
2回リストする必要がありました。

     edit : main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

しかし、このような重複はまちがいのもとです。もし新しいオブジェクトが加
えられた場合に、一方に加えて他方は忘れてしまうかもしれません。そこで、
変数を使うことによってリスクを回避し、makefileを簡素化することが可能で
す。"Variables"は文字列を1度定義し、それ以後の複数の場所でこれに置き換
えるものです（*Note 変数の使用法: Using Variables..）。

標準的な方法では、makefileのほとんどは`objects'、`OBJECTS'、`objs'、
`OBJS'、`obj'あるいは`OBJ'と名付けられた変数を持ち、以下の例のように変
数`objects'をmakefileのなかに置きます。

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

また、オブジェクトファイルのリストを置こうとするそれぞれの位置で
`$(objects)'を書くことによって変数で代用することができます（*Note 変数
の使用法: Using Variables..）。

ここで、オブジェクトファイルに対する変数を使用した場合のシンプルな
makefileのリストを示します。

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)
     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit $(objects)



File: make-jp.info, Node: make Deduces, Next: Combine By Prerequisite, Prev: Variables Simplify, Up: Introduction

`make'に命令を導き出させる
==========================

個々のCのソースファイルのコンパイルにおいては、`make'はコンパイルの方
法を理解できるため、いちいち命令を書く必要はありません。それは、`cc
-c'コマンドを使用して、`.c'から`.o'ファイルをアップデートする"暗黙のルー
ル"に従っているのです。たとえば、`cc -c main.c -o main.o'コマンドによっ
て、`main.c'をコンパイルして`main.o'を生成します。したがって、オブジェ
クトファイルの生成に関してはルールから命令を省くことができるのです。
*Note 暗黙のルールの使用: Implicit Rules.。

`.c'ファイルがこのように自動的に使用される場合は、必要条件のリストに自
動的に追加されます。したがって、命令を省略する必要条件からも`.c' ファ
イルは除くことができます。

ここに上述のような変更と変数の用い方を示す例を示します。

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)

     main.o : defs.h
     kbd.o : defs.h command.h
     command.o : defs.h command.h
     display.o : defs.h buffer.h
     insert.o : defs.h buffer.h
     search.o : defs.h buffer.h
     files.o : defs.h buffer.h command.h
     utils.o : defs.h

     .PHONY : clean
     clean :
             -rm edit $(objects)

ここでは、実際のmakefileをどう記述するかを示していて、`clean'は別に記
述されているものとします。また、*Note 偽のターゲット: Phony Targets.と
*Note コマンドのエラー: Errors.を参照してください。

暗黙のルールについては便利なため重要といえます。そのため、頻繁に目にす
ることになるでしょう。



File: make-jp.info, Node: Combine By Prerequisite, Next: Cleanup, Prev: make Deduces, Up: Introduction

もう1つのMakefileのスタイル
===========================

makefileのオブジェクトが暗黙のルールだけで生成される場合は、makefileの
別のスタイルが可能です。このスタイルでは、エントリーをターゲットではな
く必要条件でグルーピングすることができ、以下のようになります。

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)

     $(objects) : defs.h
     kbd.o command.o files.o : command.h
     display.o insert.o search.o files.o : buffer.h

ここでは`defs.h'はすべてのオブジェクトファイルの必要条件として与えられ
ています。また、`commannnd.h'と`buffer.h'は具体的なオブジェクトファイ
ルの必要条件となっています。

こちらのスタイルがよいかどうかは好みの問題で、コンパクトではあるものの、
個々のターゲットについてのすべての情報を1箇所にまとめるほうがわかりや
すいことから、このスタイルを嫌う人もいます。



File: make-jp.info, Node: Cleanup, Prev: Combine By Prerequisite, Up: Introduction

ディレクトリをクリーンにするルール
==================================

プログラムをコンパイルすることは、それに対するルールを記述することだけ
ではありません。makefileは、一般的に、プログラムのコンパイル以外のいく
つかの事柄を示します。たとえば、すべてのオブジェクトファイルや実行ファ
イルを削除してディレクトリを`clean'する方法などです。

ここにエディタプログラムの`make'におけるクリーンのルールをどのように書
いているかを示します。

     clean:
             rm edit $(objects)

実際には、予期しない状況を処理するために多少複雑なルールを書く必要があ
るかもしれませんが、以下のようにします。

     .PHONY : clean
     clean :
             -rm edit $(objects)

こうすることによって、`rm'によるエラーにも影響されず処理を継続し、
`clean'と呼ばれる現実のファイルによって`make'が混乱することを防ぐこと
ができます。（*Note 偽のターゲット: Phony Targets.、および*Note コマン
ドのエラー: Errors.を参照。）

しかしながら、それがデフォルトの動作では困るため、makefileの先頭に置く
べきではありません。したがって、ここでの例のmakefileのように、デフォル
トのゴールをそのままにするために、エディタを再コンパイルする`edit'のルー
ルを先頭に置くようにします。

`clean'は`edit'の必要条件ではないので、何の引数も与えずに`make'を実行
したとしても実行されることはありません。実行したい場合には`make clean'
とタイプしなければなりません。*Note `make'をどのように実行するか:
Running.。



File: make-jp.info, Node: Makefiles, Next: Rules, Prev: Introduction, Up: Top

Makefileの記述
**************

"makefile"と呼ばれるデータベースを読み取ることによって、どのように再コ
ンパイルするかの情報を`make'に伝えます。

* Menu:

* Makefile Contents::           What makefiles contain.
* Makefile Names::              How to name your makefile.
* Include::                     How one makefile can use another makefile.
* MAKEFILES Variable::          The environment can specify extra makefiles.
* Remaking Makefiles::          How makefiles get remade.
* Overriding Makefiles::        How to override part of one makefile
                                 with another makefile.
* Reading Makefiles::           How makefiles are parsed.



File: make-jp.info, Node: Makefile Contents, Next: Makefile Names, Up: Makefiles

Makefileに含まれるもの
======================

Makefileは5つの項目を含んでいます。それは、"explicit rules"、"implicit
rules"、"variable definitions"、"directives"と"comments"です。また、ルー
ル、変数とディレクティブについては章の後半で説明しています。

   * "explicit rule"（明示的なルール）は、1つあるいは複数のファイルを
     いつどのように変更するかを示し、ルールのターゲットと呼ばれます。
     そしてターゲットが依存するほかのファイルをリストし、ターゲットの
     必要条件を呼び出します、さらにターゲットをアップデートしたり生成
     したりする命令を与えます。*Note ルールの記述: Rules.。

   * "implicit rule"（暗黙のルール）は、名前に基づくファイルのクラスを
     いつどのように変更するかを示し、ターゲットがその名前に似たファイ
     ルにどのように依存しているかを記述し、ターゲットをアップデートし
     たり生成したりする命令を与えます。*Note 暗黙のルールの使用:
     Implicit Rules.。

   * "variable definition"（変数の定義）は、あとでテキストで代用できる
     変数のための文字列を特定するラインです。簡単なmakefileの例では、
     すべてのオブジェクトファイルのリストとして`objects'に対する変数を
     定義しています（*Note 変数によるMakefilesの簡素化: Variables
     Simplify..）。

   * "directive"（ディレクティブ）は、makefileを読み取るあいだに`make'
     に何か特別に実行させる命令です。これらは以下を含みます。

        * ほかのmakefileを読み取ること（*Note ほかのMakefileをインクルー
          ドする: Include..）。

        * 変数の値に基づいて、makefileの一部分を使用するか無視するかを
          決定すること（*Note Makefileの条件文: Conditionals..）。

        * 複数の行にわたる文字列から変数を定義すること（*Note 変数のまっ
          たく同一の定義: Defining..）。

   * `#'で始まるmakefileの行は"コメント"で、その行は無視されます。ただ
     し、バックスラッシュで区切られた複数の行にわたるコメントは例外で
     す。また、コメントはmakefileのどこにでも置けます。ただし、
     `define'ディレクティブのなかでは例外となりますし、命令行において
     も例外となります。コメントだけの行（先頭がスペースで始まる）は空
     白と同じで無視されます。



File: make-jp.info, Node: Makefile Names, Next: Include, Prev: Makefile Contents, Up: Makefiles

Makefileの名前のつけ方
======================

デフォルトでは`make'はmaefileを探しますが、その際には、`GNUmakefile'、
`makefile'、`Makefile'の順序で探します。

通常は、makefileを`makefile'あるいは`Makefile'としたほうがよく、こうし
ておけば、`README'などの重要なファイルのあるディレクトリのリストの先頭
に出てきます。名前のチェックでは、ほとんどの場合`GNUmakefile'は推奨し
ません。この名前は、とくにGNUの`make'を使用する場合に用いますが、ほか
のバージョンの`make'では認識されないでしょう。ほかの`make'プログラムは、
`makefile'あるいは`Makefile'は認識しますが、`GNUmakefile'は認識しませ
ん。

もし`make'がこれらのファイルを探し出せなかった場合には、makefileを用い
ません。したがって、コマンドの引数でゴールを指定する必要があり、`make'
は組み込まれている暗黙のルールにのみ従ってremakeしようとします。*Note 
暗黙のルールの使用: Implicit Rules.。

標準的なmakefile以外の名前を用いたい場合には、`-f'あるいは
`--file'オプションをつけてmakefileの名前を指定できます。引数
`-f NAME'あるいは`--file=NAME'によって
`make'にNAMEをmakefileだと認識させられます。また、`-f'
あるいは`--file'オプションによって、複数のmakefileの指定を行なうことも
できます。指定されたすべてのmakefileは順序に従って効果的に連結されます。
また、`-f'あるいは`--file'オプションを使用した場合には、
デフォルトの名前である`GNUmakefile'や`makefile'や`Makefile'は
自動的にチェックは行なわれません。



File: make-jp.info, Node: Include, Next: MAKEFILES Variable, Prev: Makefile Names, Up: Makefiles

ほかのMakefileをインクルードする
================================

`include'ディレクティブは、`make'に対してmakefileの読み込みを中断し、1
つあるいは複数のほかのmakefileを読み込んでから継続するように指示します。
makefileのなかのディレクティブは以下のようなものです。

     include FILENAMES...

FILENAMESは、シェルのファイル名のパターンを含むことができます。

行の先頭では、スペースは無視されるのでかまいませんが、タブは許されませ
ん。タブで始まる行はコマンド行と認識されてしまいます。また、`include'
とファイル名のあいだには空白が必要で、2つ以上の空白やディレクティブの
終わりの空白は無視されます。行の終わりに`#'で始まるコメントも可能です。
さらに、ファイル名がなんらかの変数や関数の参照を含んでいる場合にはそれ
が展開されます。*Note 変数の使用法: Using Variables.。

たとえば、3つの`.mk'すなわち、`a.mk'、`b.mk'、`c.mk'を含んでいる場合に
は、`bish bash'とともに展開され、以下のようになります。

     include foo *.mk $(bar)

は、以下と同様です。

     include foo a.mk b.mk c.mk bish bash

`make'が`include'ディレクティブを処理する際は、makefileの読み込みを中
断し、かわりにリストされたファイルの読み込みを実行します。その後、
`make'はディレクティブの現われた箇所に戻り読み込み処理を続けます。

さまざまなディレクトリにある個々のmakefileによって処理されるいくつかの
プログラムが変数定義の標準的なセットを必要とする場合に`include' ディレ
クティブを使用します（*Note 変数の設定: Setting..、あるいはパターンルー
ルについては*Note パターンルールの定義と再定義: Pattern Rules..）。

また、ソースファイルから必要条件を自動的に生成する場合にも`include' ディ
レクティブを用います。その場合、必要条件はメインのmakefileに含まれるよ
うにファイルとして生成されます。この方法は、従来のほかのバージョンの
`make'のようにメインのmakefileの最後に追加していく方法よりもすっきりし
ています。*Note 必要条件の自動生成: Automatic Prerequisites.。

もし、指定したファイルの名前がスラッシュで始まるものでない場合やカレン
トディレクトリにない場合には、いくつかのディレクトリがサーチされます。
その際に、まず`-I'あるいは`--include-dir'で指定されたディレクトリがサー
チされ（*Note オプションのサマリー: Options Summary..）、次に（存在す
る場合には）以下のディレクトリがサーチされます。`PREFIX/include'（普通
は`/usr/local/include' ですが、MS-DOSとMS-Windowsの場合は、DJGPPツリー
階層のルートディレクトリであるようにGNUのMakeはコンパイルを行ないます）、
`/usr/gnu/include'、`/usr/local/include'、 `/usr/include'。

もし、含まれているmakefileがどのディレクトリでもみつからない場合には、
警告メッセージが生成されますが、これはすぐに致命的なエラーということで
はなく、`include'を含むmakefileの処理は継続します。そして、makefileの
読み込みが終了すると`make'は期限切れや存在しないファイルを再構成しよう
とします。*Note Makefileの作られ方: Remaking Makefiles.。ただし、
makefile自体を変更しようとする方法をみつけた場合には再構成は失敗します。
そして致命的なエラーとして、makefileの存在を診断しようとします。

存在しないため、変更しようのないmakefileをエラーメッセージなしに単純に
無視する場合には、以下のように`include'ディレクティブのかわりに
`-include'を使用してください。

     -include FILENAMES...

FILENAMEがまったく存在せず、エラーがないという場合を除けば、
この動作は`include'によく似ています。これはほかの`make'
インプリメンテーションとの互換性のためで、
`sinclude'は`-include'の別名となっています。



File: make-jp.info, Node: MAKEFILES Variable, Next: Remaking Makefiles, Prev: Include, Up: Makefiles

`MAKEFILES'の変数
=================

環境変数`MAKEFILES'が定義されている場合には、`make'はその変数を、先行
して読み込むmakefileの名前のリスト（空白で区切られた）とみなします。こ
の動作は`include'ディレクティブとたいへん似ていて、さまざまなディレク
トリをサーチします（*Note ほかのMakefileをインクルードする: Include..）。
さらに、デフォルトのゴールはこれらのmakefileから得られることはなく、
`MAKEFILES'にリストされたファイルが、たとえみつからない場合でもエラー
となることはありません。

`MAKEFILES'の主な用途は、`make'の再帰的な呼び出しの際の通信です。
（*Note `make'の再帰的用法: Recursion..）通常は、トップレベルの`make'
の呼び出しのまえに環境変数を設定することは好ましくありません。なぜなら、
外部からmakefileに対して干渉しないことがよいからです。しかしながら、
makefileを指定せずに`make'を実行する場合には、`MAKEFILES'のなかの
makefileは組み込まれた暗黙のルールが定義されたサーチパスよりもうまく機
能します（*Note 必要条件のためのディレクトリサーチ: Directory Searc
h..）。

ユーザーによっては、ログイン時に自動的に`MAKEFILES'を環境に設定して、
このような動作をするように設定したがりますが、これはよくないアイデアと
いえます。なぜなら、異なるユーザーによって実行された場合には失敗してし
まうからです。したがって、明示的に`include'ディレクティブを記述するほ
うがずっとよいのです。*Note ほかのMakefileをインクルードする: Include.。



File: make-jp.info, Node: Remaking Makefiles, Next: Overriding Makefiles, Prev: MAKEFILES Variable, Up: Makefiles

Makefileの作られ方
==================

makefileはRCSやSCCSファイルから作られる場合があります。このようにほか
のファイルからmakefileが作られる場合には、`make'が最新のバージョンの
makefileを読み込むことが期待されます。

すべてのmakefileを読み込んだあと、`make'はそれぞれをゴールのターゲット
とみなし、アップデートしようと試みます。あるmakefileがその（まさにその
makefileまたは別のmakefile）アップデートの方法についてのルールを持つ場
合（*Note 暗黙のルールの使用: Implicit Rules..）、あるいは暗黙のルール
を持つ場合には必要に応じてアップデートされるでしょう。すべてのmakefile
がチェックされたあと、なんらかの変更が行なわれた場合には、`make'はクリー
ン動作を行ないすべてのmakefileの読み込みをふたたび開始します。（それぞ
れのアップデートもふたたび試みられますが、通常はアップデートされている
はずなので、再度変更を加えることはしません。）

1つあるいは複数のmakefileが変更できないことを知っていて、しかも暗黙の
ルールのサーチを`make'にさせないようにしたい場合、おそらくその理由は効
率の問題で、暗黙のルールのルックアップは通常の方法で防止することができ
ます。たとえば、明示的なルールをターゲットとしてmakefileに記述し、空の
コマンド文字列を書いておけばよいのです（*Note 空のコマンドの使用:
Empty Commands..）。

必要条件ではなく、命令でファイルを変更するために2つのコロンのルールを
makefileで指定する場合には、ファイルはつねに変更されます（*Note ダブル
コロンルール: Double-Colon..）。つまり、命令と2つのコロンのついた必要
条件でないルールは`make'が実行されるたびに実行され、ふたたび`make'が実
行される際に再度読み込みも行なわれます。これは無限ループを引き起こしま
す。`make'はつねにmakefileを変更しようと試み、ほかに何もしないことにな
ります。したがって、これを避けるために、命令と2つのコロンのついた必要
条件でないルールのターゲットとして指定されたmakefileについては`make'は
変更しようとしません。

`-f'や`--file'オプションでmakefileを何も指定しない場合は、`make'はデフォ
ルトの名前のmakefileを試します（*Note Makefileの名前のつけ方: Makefile
Names..）。`-f'や`--file'オプションで明示的に要求されたmakefileと異な
り、`make'はファイルの存在をあてにしません。しかしながら、デフォルトの
makefileが存在せず、かつ`make'の実行によって生成される場合には、
makefileが使用されるようにルールの実行が行なわれたほうがよいことになり
ます。

したがって、もしデフォルトのmakefileが存在しない場合には、`make'はサー
チされる順序でそれを生成しようとしますが（*Note Makefileの名前のつけ方:
Makefile Names..）、サーチする名前を使い果たしてしまいます。注意しなけ
ればならないのは、`make'がmakefileをサーチあるいは生成できなかったとし
てもこれはエラーとはなりません。なぜなら、makefileがつねに必要というわ
けではないからです。

`-t'あるいは`--touch'オプション（*Note コマンド実行の代替: Instead of
Execution..）を使用する際には、どのターゲットにtouchするかを決定するた
めに期限切れのmakefileを使用したいとは考えないはずです。したがって、
`-t'オプションはmakefileのアップデートには何の効果も与えません。同様に、
`-q' （あるいは`--question'）や`-n' （あるいは`--just-print'）オプショ
ンは、makefileのアップデートを妨げません。なぜなら期限切れのmakefileは
ほかのターゲットに対して誤った出力を行なってしまうからです。したがって、
`make -f mfile -n foo'は`mfile'をアップデートし、それを読み込みます。
そして実行することなしに、命令を出力して`foo'と必要条件をアップデート
します。`foo'に出力された命令は、`mfile'のアップデートされた内容におい
て指定されたものです。

しかしながら、ときにはmakefileのアップデートを止めたいと考えることもあ
るかもしれません。その場合、makefileのなかで行なうようにmakefile自体を
ゴールに指定することで、実現できます。明示的なゴールとしてmakefileが指
定されている場合には、`-t'などのオプションが適用されます。

したがって、`make -f mfile -n mfile foo'はmakefile `mfile'を読み込み実
際に実行することはせずに、アップデートに必要な命令を出力します。そして、
`foo'のアップデートに必要な命令も出力します。`foo'に対する命令は
`mfile'の実際の内容によって指定されたものとなります。



File: make-jp.info, Node: Overriding Makefiles, Next: Reading Makefiles, Prev: Remaking Makefiles, Up: Makefiles

ほかのMakefileの部分的なオーバーライド
======================================

まれに、もう1つほとんど同じmakefileを持つことが有益な場合があります。
その場合、`include'ディレクティブによってもう一方をインクルードするよ
うにします。そして、より多くのターゲットあるいは変数定義を付け加えます。
しかし、同じターゲットに対して2つのmakefileが異なる命令を与える場合に
は`make'はこの方法は用いることができません。この場合には別の方法があり
ます。

他方をインクルードしようとするmakefileにおいては、そのmakefileに含まれ
る内容から導けないどんなターゲットでも再構成できる何にでもマッチするパ
ターンルールを使用することができ、`make'は他方のmakefileを読み取ること
になります。パターンルールについては、*Note パターンルールの定義と再定
義: Pattern Rules.。

たとえば、ターゲット`foo'をmakeするための`Makefile'があるとして、もう1
つ別の`GNUmakefile'を作ることができ、その中身は、以下のようにします。

     foo:
             frobnicate > foo

     %: force
             @$(MAKE) -f Makefile $@
     force: ;

`make foo'とした場合、`make'は`GNUmakefile'をみつけだし、それを読み
`foo'をmakeしようとします。そしてコマンド`frobnicate > foo'を実行しよ
うとします。また、`make bar'とした場合には、`make'は`GNUmakefile'のな
かで`bar'をmakeする方法をみつけられません。つまりここでは、`make -f
Makefile bar'というパターンルールを使おうとしたからです。もし
`Makefile'が`bar'をアップデートするルールを提供するならば、`make'はそ
れを適用します。`GNUmakefile'がどのようにmakeするかを指示しないあらゆ
るターゲットに対しても同様です。

この動作は、`%'だけのパターンを持つパターンルールによります。`%'はあら
ゆるターゲットにマッチします。たとえターゲットファイルがすでに存在して
いても命令の実行を保証するために、ルールは`force'という必要条件を指定
します。`make'が暗黙のルールをサーチしないように空の命令を`force'ター
ゲットに与えます。そうしないと同一の何にでもマッチするルールを`force'
に適用してしまい、必要条件のループを生成してしまいます。



File: make-jp.info, Node: Reading Makefiles, Prev: Overriding Makefiles, Up: Makefiles

`make'はどのようにMakefileを解釈するか
======================================

GNUの`make'は2つの異なったフェーズで仕事を行ないます。最初のフェーズで
は、すべてのmakefileを読み、makefileのインクルードを行ないすべての変数
と値を内部の値として持ち、暗黙および明示的なルールおよびすべてのターゲッ
トとその必要条件の依存状態のグラフを構築します。次のフェーズでは、どの
ターゲットが再構築される必要があり、ルールの適用が必要なのかを決定する
ために`make'は内部構造を使用します。

この2段階のアプローチを理解しておくのが重要なのは、変数と関数の展開に
よる直接的な影響があるからです。このことはしばしばmakefileを記述する際
の混乱のもとになります。ここでは、makefileのなかの異なる構成に対する展
開における2つの段階の要約を示します。最初のフェーズで展開が行なわれる
場合を"immediate"といい、この場合は`make'は構文解析されたmakefileとし
て構成のセクションの部分にすべての変数と関数を展開します。また、展開が
ただちに行なわれない場合を"deferred"といい、即時の文脈のなかでその構成
が出現しない限り実行されることはなく、そうでない場合は2番目のフェーズ
で実行されることになります。

読者はこの構成（物）に関してはまだ詳しくはないかもしれませんが、あとの
章を読み詳しくなるに従ってこの章を参照するとよいでしょう。


変数の割り当て
--------------

変数の定義は以下のように構文解析されます。

     IMMEDIATE = DEFERRED
     IMMEDIATE ?= DEFERRED
     IMMEDIATE := IMMEDIATE
     IMMEDIATE += DEFERRED or IMMEDIATE

     define IMMEDIATE
       DEFERRED
     endef

`+='は付加オペレーターで、以前に変数が単純変数としてセット（`:='）され
ていてdeferredでない場合には、オペレーターの右側はimmediateであるとみ
なされます。


条件付きのシンタックス
----------------------

条件付きのすべてのインスタンスはただちに全体として構文解析され、これに
は`ifdef'や`ifeq'や`ifndef'と`ifneq'形式が含まれます。


ルールの定義
------------

ルールは形式を問わず、つねに同じ方法で展開されます。

     IMMEDIATE : IMMEDIATE ; DEFERRED
     	DEFERRED

つまり、ターゲットと必要条件であるセクションはただちに展開されて、ター
ゲットを構成するための命令はつねにdeferredとなります。この一般的なルー
ルは明示的なルール、パターンルール、サフィックスルール、静的なパターン
ルールと単純な必要条件の定義に対してあてはまります。



File: make-jp.info, Node: Rules, Next: Commands, Prev: Makefiles, Up: Top

ルールの記述
************

makefileに現われる"ルール"はいつどのようにファイルを再構成するかを示し、
ルールの"ターゲット"といわれます。多くの場合、1つのルールに1つのターゲッ
トです。そして、ターゲットの"必要条件"となるほかのファイルをリストし、
ターゲットを生成したりアップデートするための命令をリストします。

ルールの順序は"default goal"の決定を除けば重要ではありません。異なる形
で指定しない限り`make'が判断するターゲットがデフォルトゴールです。また、
デフォルトゴールは最初のmakefileの最初のルールで、仮に最初のルールが複
数のターゲットを持つ場合にはその1番目がデフォルトゴールとなります。た
だし、ここで2つの例外があります。ピリオドで始まるターゲットで、1つある
いは複数のスラッシュ`/'を含まない限り、それはデフォルトのターゲットで
はありません。同様に、パターンルールを定義するターゲットはデフォルトゴー
ルに対して何の影響も与えません（*Note パターンルールの定義と再定義:
Pattern Rules..）。

したがって、通常は、最初のルールがすべてのプログラムをコンパイルするよ
うに、あるいは`all'と呼ばれるターゲットをしばしば用いるようにmakefile
を記述します。*Note ゴールを指定する引数: Goals.。

* Menu:

* Rule Example::                An example explained.
* Rule Syntax::                 General syntax explained.
* Wildcards::                   Using wildcard characters such as `*'.
* Directory Search::            Searching other directories for source files.
* Phony Targets::               Using a target that is not a real file's name.
* Force Targets::               You can use a target without commands
                                  or prerequisites to mark other
                                  targets as phony.
* Empty Targets::               When only the date matters and the
                                  files are empty.
* Special Targets::             Targets with special built-in meanings.
* Multiple Targets::            When to make use of several targets in a rule.
* Multiple Rules::              How to use several rules with the same target.
* Static Pattern::              Static pattern rules apply to multiple targets
                                  and can vary the prerequisites according to
                                  the target name.
* Double-Colon::                How to use a special kind of rule to allow
                                  several independent rules for one target.
* Automatic Prerequisites::     How to automatically generate rules giving
                                  prerequisites from source files themselves.



File: make-jp.info, Node: Rule Example, Next: Rule Syntax, Up: Rules

ルールの例
==========

ルールの例をあげます。

     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c

ここでのターゲットは`foo.o'で、その必要条件は`foo.c'と`defs.h'です。コ
マンドは1つで、`cc -c -g foo.c'で、コマンドであることを示すために行の
先頭はタブで始めます。

このルールでは2つのルールが宣言されています。

   * `foo.o'が期限切れかどうかをどのように決定するか？　それは、存在し
     ないあるいは、`foo.c'または`defs.h'がより新しいものかどうかで決定
     されます。

   * `foo.o'をどのようにアップデートするか：それは、`cc'を実行すること
     によって行なわれます。命令では、`defs.h'に明示的に言及しませんが、
     `foo.c'がそれを含み、`defs.h'が必要条件に加えられた理由を推定する
     ことになります。



File: make-jp.info, Node: Rule Syntax, Next: Wildcards, Prev: Rule Example, Up: Rules

ルールのシンタックス
====================

一般的にルールは以下のようになります。

     TARGETS : PREREQUISITES
             COMMAND
             ...

もしくは、以下のようになります。

     TARGETS : PREREQUISITES ; COMMAND
             COMMAND
             ...

TARGETSはスペースで区切られたファイル名で、ワイルドカードが使われるこ
ともあります（*Note ファイル名におけるワイルドカードの使用:
Wildcards..）。`A(M)'というファイル名では、アーカイブファイルAのメンバー
であるMを表わしていることがあります（*Note ターゲットとしてのアーカイ
ブメンバー: Archive Members..）。通常は、ルールごとに1つのターゲットが
ありますが、まれに、複数の場合もあります（*Note ルール中の複数のターゲッ
ト: Multiple Targets..）。

COMMAND行の先頭はタブ文字で始まります。最初の命令は必要条件のあとにタ
ブ文字とともに現われるか、セミコロンで同じ行に現われます。どちらの方法
でも効果は同じです。*Note ルールのなかでのコマンドの書き方: Commands.。

変数の参照を開始するためにドル記号が使用されるため、ルールのなかでドル
記号を用いたい場合には、`$$' （*Note 変数の使用法: Using Variables..）
のように2つ続けて書かなければなりません。また、長い行はバックスラッシュ
で分割することができますが、`make'はmakefileのなかでの行の長さに制限を
持たないため、必ずしもそうする必要はありません。

ルールは`make'に対して、ターゲットがいつ期限切れであるか、必要な場合に
どのようにアップデートするかの2つを指示します。

期限切れであるということの尺度は、（スペースによってファイル名が区切ら
れている）必要条件で指定されています。（ワイルドカードとそのアーカイブ
メンバー（*Note アーカイブファイルのアップデートに `make'を使用する:
Archives..）も同様に置くことができます）もし、それが存在しないかあるい
は必要条件のいずれよりも古ければ（最終更新日付との比較によって）、その
ターゲットは期限切れとされます。このアイデアは、ターゲットファイルの内
容が必要条件の情報に基づいて計算されるということです。したがって、いず
れかの必要条件に変更があった場合には、既存のターゲットファイルの内容は
有効ではなくなるのです。

どのようにアップデートするかは命令によって指定され、それらはシェル（通
常は`sh'）といくつかの特別な機能を用いて実行されます（*Note ルールのな
かでのコマンドの書き方: Commands..）。



File: make-jp.info, Node: Wildcards, Next: Directory Search, Prev: Rule Syntax, Up: Rules

ファイル名におけるワイルドカードの使用
======================================

"ワイルドカード"を用いると1つのファイル名で多くのファイルを指定するこ
とができます。`make'におけるワイルドカード文字は、`*'、`?'と`[...]'で
Bourneシェルと同じです。たとえば、`*.c'はワーキングディレクトリの`.c'
という名前のファイルすべてを指定します。

ファイル名の先頭が`~'で始まるファイルもまた特別な意味を持ちます。単独
もしくは次にスラッシュがある場合は、ホームディレクトリを表わし、たとえ
ば`~/bin'は`/home/you/bin'と展開されます。また、`~'の次に単語がある場
合、その単語が示すユーザーのホームディレクトリを表わします。たとえば、
`~john/bin'は`/home/john/bin'と展開されます。MS-DOSやMS-Windowsのよう
にそれぞれのユーザーのホームディレクトリを持たないシステムの場合には、
この機能は環境変数HOMEの設定によってシミュレートされます。

ワイルドカードの展開は、ターゲット、必要条件、シェルが実行するコマンド
によって自動的に行なわれます。ほかの文脈においても、この機能を明示的に
指示することでワイルドカード展開は行なわれます。

ワイルドカード文字の特別な意味は、バックスラッシュを前置することで無効
にできます。したがって、`foo\*bar'は`foo'、アスタリスクと`bar'からなる
具体的なファイルを参照することになります。

* Menu:

* Wildcard Examples::           Several examples
* Wildcard Pitfall::            Problems to avoid.
* Wildcard Function::           How to cause wildcard expansion where
                                  it does not normally take place.



File: make-jp.info, Node: Wildcard Examples, Next: Wildcard Pitfall, Up: Wildcards

ワイルドカードの例
------------------

ワイルドカードはシェルによって展開されるルール中の命令で用いられます。
たとえば、すべてのオブジェクトファイルを削除するルールの例は以下のよう
になります。

     clean:
             rm -f *.o

また、ワイルドカードはルールの必要条件においても有益です。makefileのな
かで以下のようなルール、すなわち`make print'は、前回印刷した以降に更新
されたすべての`.c'ファイルを印刷します。

     print: *.c
             lpr -p $?
             touch print

このルールでは、`print'を空のターゲットファイルとして扱います。*Note 
レコードイベントに対する空のターゲットファイル: Empty Targets.を参照し
てください。（また、自動変数`$?'は更新されたファイルだけを対象としてい
ます。*Note 自動変数: Automatic.参照。）

しかし、変数を定義した場合にはワイルドカードによる展開は起こりません。
したがって、

     objects = *.o

のように書いた場合には、変数`objects'の値は、実際の`*.o'となります。し
かしながら、ターゲット、必要条件や命令で`objects'の値を用いる場合には、
ワイルドカードによる展開が行なわれます。`objects'が展開されるように設
定するには、かわりに以下のようにしてください。

     objects := $(wildcard *.o)

*Note ワイルドカードの機能: Wildcard Function.。



File: make-jp.info, Node: Wildcard Pitfall, Next: Wildcard Function, Prev: Wildcard Examples, Up: Wildcards

ワイルドカードの落とし穴
------------------------

ここにワイルドカードを使用する際に意図しない動作をする微妙な例がありま
す。たとえば、あるディレクトリのすべてのオブジェクトファイルから実行可
能なファイル`foo'が作られる場合に、次のように記述することでしょう。

     objects = *.o

     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)

`objects'の値は実際の`*.o'の文字列です。そして、ワイルドカードによる展
開は、`foo'に対するルールのなかで行なわれます。そして、それぞれの*実在
する*`*.o'ファイルが`foo'の必要条件となり、必要に応じて再コンパイルさ
れます。

しかし、`*.o'ファイルをすべて削除したらどうなるでしょうか。ワイルドカー
ドがマッチするものがなくなり、`*.o'という妙な名前のついたファイルに
`foo'が依存することになります。したがって、そのようなファイルが存在し
そうもないため、`make'は`*.o'を作ることができないというエラーを表示し
ます。これは望んだ結果ではないはずです。

実際には、ワイルドカードによる展開によって、望む結果が得られるかもしれ
ませんが、ワイルドカードによる機能と文字列の代用による洗練されたテクニッ
クを必要とするでしょう。*Note ワイルドカードの機能: Wildcard Function.。


Microsoftのオペレーティングシステム（MS-DOSとMS-Windows）では、パス名
のディレクトリの区切りはバックスラッシュを用い以下のように書かれます。

       c:\foo\bar\baz.c

これは、Unixスタイルの`c:/foo/bar/baz.c'（ここで`c:'はドライブレターと
呼ばれます）に等しく、`make'がこのようなシステム上で動作するときには、
パス名においてはバックスラッシュがUnixでのスラッシュに相当します。しか
し、バックスラッシュがクォート文字となる場合には、ワイルドカードによる
展開はサポート*されません*。したがって、そのような場合にはUnixスタイル
のスラッシュを使用*しなければ*なりません。




File: make-jp.info, Node: Wildcard Function, Prev: Wildcard Pitfall, Up: Wildcards

ワイルドカードの機能
--------------------

ワイルドカードによる展開はルール中で自動的に行なわれますが、変数が設定
されている場合、あるいはファンクションの引数のなかでは通常は行なわれま
せん。そのような場合でもワイルドカードによる展開が必要な場合は、以下の
ようなワイルドカードの機能を用います。

     $(wildcard PATTERN...)

makefileのどこの位置で用いられてもこの文字列は、与えられたファイル名の
パターンの1つに一致する実在のファイルの名前をスペースで区切ったリスト
に置き換えられます。実在のファイルがパターンに一致しない場合には、ワイ
ルドカードの機能による出力からは省略されます。注意しなければならないの
は、無視されるというよりもむしろまったく同じとして扱われる場合に、ルー
ルのなかで一致しないワイルドカードの挙動が異なることです（*Note ワイル
ドカードの落とし穴: Wildcard Pitfall..）。

ワイルドカードの機能の1つは、以下のようにあるディレクトリのCのソースファ
イルのリストを得ることです。

     $(wildcard *.c)

そして、拡張子`.c'を`.o'に置き換えることによってCのソースファイルのリ
ストをオブジェクトのリストに変更することができます。

     $(patsubst %.c,%.o,$(wildcard *.c))

（ここでは、`patsubst'という別の機能を用いています。*Note 文字列の代用
と分析のファンクション: Text Functions.。）

そして、makefileはすべてのCのソースファイルをそのディレクトリでコンパ
イルし、以下のように書かれているように互いにリンクします。

     objects := $(patsubst %.c,%.o,$(wildcard *.c))

     foo : $(objects)
             cc -o foo $(objects)

（これは、Cのプログラムをコンパイルするための暗黙のルールを利用し、そ
こではコンパイルに必要な明示的なルールを記述する必要はありません。
*Note 変数の2つのフレーバー: Flavors.）



File: make-jp.info, Node: Directory Search, Next: Phony Targets, Prev: Wildcards, Up: Rules

必要条件のためのディレクトリサーチ
==================================

大規模なシステムの場合には、バイナリとは異なるディレクトリにソースを置
くことが望ましいことがあります。`make'の"ディレクトリサーチ"機能は必要
条件をみつけるためにいくつかのディレクトリをサーチします。ファイルをい
くつかのディレクトリに再配置する場合でも個々のルールを変更する必要はな
く、サーチパスの変更だけですみます。

* Menu:

* General Search::              Specifying a search path that applies
                                  to every prerequisite.
* Selective Search::            Specifying a search path
                                  for a specified class of names.
* Search Algorithm::            When and how search paths are applied.
* Commands/Search::             How to write shell commands that work together
                                  with search paths.
* Implicit/Search::             How search paths affect implicit rules.
* Libraries/Search::            Directory search for link libraries.



File: make-jp.info, Node: General Search, Next: Selective Search, Up: Directory Search

`VPATH':すべての必要条件のサーチパス
------------------------------------

`make'における可変`VPATH'の値は、`make'がサーチすべきディレクトリのリ
ストを指定します。たいていの場合は、カレントディレクトリにない必要条件
のファイルを含むことが期待されますが、`VPATH'は、ルールのターゲットを
含み、しかも`make'がすべてのファイルに適用するサーチリストを指定します。

したがって、仮にターゲットや必要条件としてリストされたファイルがカレン
トディレクトリに存在しない場合、`make'は`VPATH'でリストされたディレク
トリをサーチすることになります。そのどこかのディレクトリでファイルがみ
つかった場合、そのファイルが必要条件となります（下記参照）。そして、カ
レントディレクトリにすべてのファイルがあるかのごとく、ルールは必要条件
のリストのなかでファイル名を特定できるようになります。*Note ディレクト
リサーチにおけるシェルコマンドの記述: Commands/Search.。

`VPATH'変数においては、ディレクトリ名はコロンあるいは空白で区切られま
す。ディレクトリのリストの順序は、`make'のサーチの順序に従います。
（MS-DOSとMS-Windowsにおいては、パス名自体にコロンが使用されるため、ド
ライブ名のあとに`VPATH'のディレクトリ名のセパレータとしてセミコロンが
使われます。）

たとえば、

     VPATH = src:../headers

は、`src'と`../headers'の2つのディレクトリを指定し、`make'はその順序で
サーチをします。

`VPATH'の値によって、以下のルールは、

     foo.o : foo.c

以下のように書かれたかのごとくに解釈されます。

     foo.o : src/foo.c

ファイル`foo.c'を仮定し、カレントディレクトリに存在しなくとも`src'ディ
レクトリでそれを発見します。



File: make-jp.info, Node: Selective Search, Next: Search Algorithm, Prev: General Search, Up: Directory Search

`vpath'ディレクティブ
---------------------

`VPATH'変数に似ていますが、より選択的なディレクティブが`vpath'（小文字
であることに注意してください）で、あるパターンにマッチするファイル名の
特定のクラスのためのサーチパスを指定できます。したがって、一定のサーチ
ディレクトリをファイル名の1つのクラス、およびほかのファイル名に対する
ほかのディレクトリに与えることが可能です。

`vpath'ディレクティブには3つの形式があります。

`vpath PATTERN DIRECTORIES'
     PATTERNにマッチするファイル名に対してサーチパスのDIRECTORIESを指
     定する。

     サーチパスのDIRECTORIESは、サーチされるディレクトリのリストで、コ
     ロン（MS-DOSとMS-Windowsではセミコロン）で区切られ、`VPATH'変数に
     おけるサーチパスと同様です。

`vpath PATTERN'
     PATTERNで関連付けられたサーチパスをクリアします。

`vpath'

     `vpath'ディレクティブで以前に指定されたサーチパスをクリアします。

`vpath'パターンは`%'文字を含む文字列です。その文字列は、サーチされる必
要条件のファイル名にマッチしなければならず、`%'文字はゼロ以上長さの文
字列とマッチします（*Note パターンルール の定義と再定義: Pattern
Rules..）。たとえば、`%.h'は`.h'で終わるファイルとマッチします。（`%'
がない場合には、必要条件に正確にマッチしなければならず、ほとんどの場合
には有益ではありません。）

`vpath'ディレクティブパターンにおける`%'文字は、そのまえに書かれたバッ
クスラッシュによって引用されます。`%'文字を引用するバックスラッシュは
さらに多くのバックスラッシュで引用されることになりますが、それがファイ
ル名と比較されるまえに、`%'文字またはほかのバックスラッシュで引用され
るバックスラッシュはパターンから削除されます。`%'を引用する危険のない
バックスラッシュは悩みの種にはなりません。

仮に、必要条件がカレントディレクトリに存在せず、`vpath' ディレクティブ
におけるPATTERNが必要条件のファイル名にマッチする場合、そのディレクティ
ブのDIRECTORIESは`vpath'変数のディレクトリと同様にサーチされます。

たとえば、

     vpath %.h ../headers

という記述は`make'に対して、カレントディレクトリに存在しない場合は、
`.h'で終わるファイル名の必要条件を`../headers'ディレクトリで探すように
指示します。

そして、いくつかの`vpath'パターンが必要条件のファイル名にマッチするな
らば、`make'は`vpath'ディレクティブにおけるすべてのディレクトリを1つず
つそれぞれマッチさせます。さらに`make'はmakefileに現われる順序で複数の
`vpath'ディレクティブを扱います。ここで、同じパターンを持つ複数のディ
レクティブは互いに独立したものです。

したがって、

     vpath %.c foo
     vpath %   blish
     vpath %.c bar

は、`.c'で終わるファイルを`foo'でサーチし、それから`blish'、`bar'でサー
チします。

     vpath %.c foo:bar
     vpath %   blish

の場合は、`.c'で終わるファイルを`foo'でサーチし、それから`bar'、
`blish'でサーチします。



File: make-jp.info, Node: Search Algorithm, Next: Commands/Search, Prev: Selective Search, Up: Directory Search

ディレクトリサーチはどのように行なわれるのか
--------------------------------------------

一般的あるいは選択的にかかわらず、ディレクトリサーチをして必要条件がみ
つかるとき、そのパス名は、`make'が実際に提供する必要条件のリストのうち
の1つではないかもしれません。したがって、ときおりディレクトリサーチを
通じて発見されたパス名は破棄されることがあります。

`make'がディレクトリサーチで発見したパスを保持するか破棄するかを決定す
るためのアルゴリズムは以下のようなものです。

  1. makefile中で指定されたパスでターゲットファイルが存在しない場合に
     は、ディレクトリサーチが行なわれます。

  2. ディレクトリサーチに成功した場合は、そのパスが保持され、そのファ
     イルは一時的にストアされます。

  3. ターゲットのすべての必要条件が同じ方法を用いて試されます。

  4. 必要条件の処理のあと、必要に応じてターゲットが再構成されることも
     あります。

       a. もし、ターゲットが再構成される必要の*ない*場合は、ディレクト
          リサーチのあいだに発見されたファイルへのパスは、そのターゲッ
          トが含まれるすべての必要条件のリストに使用されます。簡単にい
          えば、`make'がターゲットを再構成する必要のない場合は、ディレ
          クトリサーチによるパスを使用するのです。

       b. 一方、期限切れによって、ターゲットの再構成が必要な場合は、ディ
          レクトリサーチのあいだに発見されたファイルへのパスは*破棄*さ
          れ、makefile中で指定されたファイル名を使用してそのターゲット
          は再構成されます。いいかえれば、`make'がターゲットを再構成す
          る際は、ディレクトリサーチによるディレクトリではなくローカル
          に再構成します。

このアルゴリズムは複雑そうに見えますが、実際には意図したとおり、正しく
動作します。

`make'のほかのバージョンはより簡単なアルゴリズムを使用します。ファイル
が存在せず、ディレクトリサーチで発見された場合はターゲットの再構成の必
要性に関係なくそのパス名が使用されます。したがって、ディレクトリサーチ
で発見されたパス名でターゲットが再構成されます。

実際、そのような動作をさせたい場合には、`make'中で`GPATH'変数を使用す
ることができます。

`GPATH'は`VPATH'と同じくスペースあるいはコロンでパス名を区切る書式とシ
ンタックスを持ちます。ディレクトリサーチで、あるディレクトリに期限切れ
のターゲットが発見された場合、しかもそれが`GPATH'にある場合、そのパス
名は破棄されず、ターゲットは展開されたパスを用いて再構成されます。



Info file: make-jp.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `make-jp.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.







INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Make: (make).            Remake files automatically.
END-INFO-DIR-ENTRY


This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

This is Edition 0.55, last updated 04 April 2000, of `The GNU Make
Manual', for `make', Version 3.79.

Copyright (C) 1988, '89, '90, '91, '92, '93, '94, '95, '96, '97, '98,
'99, 2000 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.




File: make-jp.info, Node: Commands/Search, Next: Implicit/Search, Prev: Search Algorithm, Up: Directory Search

ディレクトリサーチにおけるシェルコマンドの記述
----------------------------------------------

ディレクトリサーチのあいだに別のディレクトリで必要条件が発見された場合
でも、ルールの命令を変更することはできず、記述されたとおりに実行されま
す。したがって、`make'がその必要条件を発見したディレクトリのなかを探す
ように注意深く命令を記述しなければなりません。

この場合は、`$^'のような"自動変数"を用います（*Note 自動変数:
Automatic..）。たとえば、`$^'の値はルールのすべての必要条件のリストで、
それらが発見されたディレクトリの名前を含み、`$@'の値はターゲットとなり
ます。

     foo.o : foo.c
             cc -c $(CFLAGS) $^ -o $@

（変数`CFLAGS'は暗黙のルールにおけるC言語の互換性のために指定が可能な
ようになっていて、すべてのC言語のコンパイルに同じように影響を与え、整
合性を取るために使用されます。*Note 暗黙のルールで使用される変数:
Implicit Variables..。）

必要条件は同じようにヘッダファイルを含むことが多く、そのヘッダファイル
については言及したくない場合があります。自動変数の`$<'はまさに最初の必
要条件です。

     VPATH = src:../headers
     foo.o : foo.c defs.h hack.h
             cc -c $(CFLAGS) $< -o $@



File: make-jp.info, Node: Implicit/Search, Next: Libraries/Search, Prev: Commands/Search, Up: Directory Search

ディレクトリサーチと暗黙のルール
--------------------------------

複数のディレクトリにわたる、`VPATH'の中あるいは`vpath'で指定されるサー
チは暗黙のルールの解釈のあいだに行なわれます（*Note 暗黙のルールの使用:
Implicit Rules..）。

たとえば、ファイル`foo.o'が明示的なルールをまったく持たない場合、
`make'が暗黙のルールを考慮し、それはファイルが存在する場合には`foo.c'
をコンパイルするというあらかじめ用意されているルールです。カレントディ
レクトリにそのファイルがない場合には適切なディレクトリがサーチされます。
どこかのディレクトリに`foo.c'が存在する、あるいはmakefileで指示されて
いる場合には、C言語のコンパイルに関するルールが暗黙のルールとなります。

暗黙のルールの命令は、通常必ず自動変数を使用します。その結果、特別なこ
とをせずにディレクトリサーチによって発見されたファイル名を使用します。



File: make-jp.info, Node: Libraries/Search, Prev: Implicit/Search, Up: Directory Search

リンクライブラリに対するディレクトリサーチ
------------------------------------------

リンカによって用いられるライブラリに対してはディレクトリサーチは特別な
方法を用います。この仕組みは、必要条件の名前が`-lNAME'の書式のときに働
きます。（通常は必要条件がファイル名であるため、ライブラリの名前の
*file name*が、一般的に`-lNAME'ではなく`libNAME.a'のように見えるため、
何か奇妙な感じを受けるかもしれません。）

必要条件の名前が`-lNAME'の書式である場合、`make'はその名前を
`libNAME.so'としてカレントディレクトリや`vpath'のサーチパスと`VPATH'の
サーチパスにマッチしたディレクトリでサーチし、その後、`/lib'、
`/usr/lib'、と`PREFIX/lib'のディレクトリでサーチします（ここで、通常は
`/usr/local/lib'ですが、MS-DOS/MS-Windowsのバージョンの`make'では
PREFIXがDJGRPインストレーションツリーのルートディレクトリであるかのよ
うにふるまいます）。

もし、ファイルがみつからない場合にはファイル`libNAME.a'が上記と同様の
ディレクトリでサーチされます。

たとえば、`/usr/lib/libcurses.a'ライブラリがシステムにある場合（かつ
`/usr/lib/libcurses.so'はない場合）、

     foo : foo.c -lcurses
             cc $^ -o $@

は、`foo'が`foo.c'あるいは`/usr/lib/libcurses.a'よりも古い場合、`cc
foo.c /usr/lib/libcurses.a -o foo'というコマンドを実行します。

デフォルトの設定でサーチされるのは`libNAME.so'と`libNAME.a'ですが、
`.LIBPATTERNS'変数によってカスタマイズすることができます。この変数の値
における個々の語はパターン文字列です。`-lNAME'のような必要条件が現われ
る場合には、`make' はNAMEでリスト中の個々のパターンの%を置き換え、ライ
ブラリのファイル名を用いて上記のディレクトリのサーチを行います。ライブ
ラリがみつからない場合には、リストの次の語が使用されます。

`.LIBPATTERNS'変数のデフォルトの値は、`lib%.so lib%.a'で、前記のふるま
いを行なうようになっています。

しかし、この変数の値を空にすることで、リンクライブラリへの展開をしない
ように設定することもできます。



File: make-jp.info, Node: Phony Targets, Next: Force Targets, Prev: Directory Search, Up: Rules

偽のターゲット
==============

偽のターゲットは本当はファイルの名前ではありません。明示的な要求を作る
際に実行されるいくつかの命令の名前（通称）です。偽のターゲットを使うた
めの、2つの理由があります。1つは同一のファイル名によるコンフリクトを避
けるためで、もう1つは、パフォーマンスの向上のためです。

ターゲットファイルを作成しない命令によるルールを記述する場合、その命令
はターゲットが現われるたびに実行されます。例をあげます。

     clean:
             rm *.o temp

`rm'コマンドは、`clean'というファイルを作成はしないため、そのようなファ
イルは存在しません。したがって、`rm'コマンドは`make clean'を実行するた
びに実行されることになります。

もし何かが`clean'という名前のファイルをこのディレクトリに作成するなら
ば、偽のターゲットは動作を停止するでしょう。なぜなら`clean'は必要条件
を持たないからで、必然的に最新であると考えられ、命令の実行は行なわれま
せん。この問題を避けるには、特別なターゲット`.PHONY'（*Note 特別な組み
込み済みのターゲット名: Special Targets..）を使用して、明示的にターゲッ
トが偽であるように宣言しておきます。

     .PHONY : clean

いったん、このようにした場合、`clean'の有無にかかわらず、`make clean'
が実行されます。

偽のターゲットはほかのファイルから作られる実際のファイル名をつけないこ
とがわかっているため、`make'は偽のターゲットのサーチを行なう暗黙のルー
ルをスキップします（*Note 暗黙のルールの使用: Implicit Rules..）。この
ことから、実際のファイルが存在している場合でもそれを気にすることがない
ため、偽のターゲットの宣言が効果的なのです。

したがって、`clean'を最初の行に置き、これを偽のターゲットにします。こ
の場合のルールの書き方は以下のようになります。

     .PHONY: clean
     clean:
             rm *.o temp

偽のターゲットの利用のもう1つの有益な例は、`make'の再帰的な呼び出しの
場合にあります。この場合、makefileはビルドされる多くのサブディレクトリ
のリストの変数を持つことが多く、これを処理する1つの方法は、サブディレ
クトリ間を越えてシェルのコマンドが実行されるルールを扱うようにすること
です。たとえば、以下のようにします。

     SUBDIRS = foo bar baz

     subdirs:
             for dir in $(SUBDIRS); do \
               $(MAKE) -C $$dir; \
             done

しかしながら、この方法にはいくつか問題があります。1番目の問題は、この
ルールでは、submakeのなかでなんらかのエラーが起きた場合にそれが記録さ
れないことです。したがって、エラーが起きてもほかのディレクトリでのビル
ドは続行されます。エラーとそれによる終了はシェルコマンドの追加によって
そうさせないことはできますが、その場合は`make'に`-k'オプションがついて
いても実行されてしまいます。2番目の問題は、より重要ですが、ルールが1つ
であるため、makeの持つパラレルビルドの機能を利用することができません。

しかし、サブディレクトリが偽のターゲット（サブディレクトリはつねに存在
するようにしておかなければビルドされません）であるように宣言することに
よって、これらの問題を取り除くことが可能です。

     SUBDIRS = foo bar baz

     .PHONY: subdirs $(SUBDIRS)

     subdirs: $(SUBDIRS)

     $(SUBDIRS):
             $(MAKE) -C $
     foo: baz

この例では、`baz'サブディレクトリがビルドされたあとでさえも`foo' サブ
ディレクトリがビルドされないように宣言しています。このような関係の宣言
はパラレルビルドを行なう際にはとくに重要です。

偽のターゲットは実際のターゲットファイルの必要条件である必要はなく、も
しそうであっても、`make'がそのファイルをアップデートするたびに命令が実
行されます。偽のターゲットが実際のターゲットの必要条件でない限り、偽の
ターゲットの命令は偽のターゲットが特別なゴールであるときにだけ実行され
ます（*Note ゴールを指定する引数: Goals..）。

また、偽のターゲットは必要条件を持つことができます。たとえば、1つのディ
レクトリに複数のプログラムがある場合、1つの`.Makefile'ですべてのプログ
ラムを記述できるほうが便利です。デフォルトで再構成されたターゲットが
makefileの最初のものであるため、`all'と名付けられた偽のターゲットおよ
び必要条件をすべての個々のプログラムに与えるのが共通になります。たとえ
ば、

     all : prog1 prog2 prog3
     .PHONY : all

     prog1 : prog1.o utils.o
             cc -o prog1 prog1.o utils.o

     prog2 : prog2.o
             cc -o prog2 prog2.o

     prog3 : prog3.o sort.o utils.o
             cc -o prog3 prog3.o sort.o utils.o

とすることによって、`make'によって3つのプログラムを再構築することがで
き、その際に引数として扱うこともできます（`make prog1 prog3'のように）。

偽のターゲットが別のターゲットの必要条件である場合にはサブルーチンとし
て働きます。たとえば、この`make cleanall'はオブジェクトファイル、差分
ファイル、`program'ファイルを削除します。

     .PHONY: cleanall cleanobj cleandiff

     cleanall : cleanobj cleandiff
             rm program

     cleanobj :
             rm *.o

     cleandiff :
             rm *.diff



File: make-jp.info, Node: Force Targets, Next: Empty Targets, Prev: Phony Targets, Up: Rules

命令または必要条件なしのルール
==============================

ルールが必要条件や命令を何も持たない場合、またルールのターゲットが存在
しないファイルである場合、`make'はルールが実行されるたびにそのターゲッ
トを仮定することになります。これは、依存しているすべてのターゲットがそ
れらの命令の実行をつねに行なうことを暗示しています。

以下の例を見てください。

     clean: FORCE
             rm $(objects)
     FORCE:

ここで、ターゲット`FORCE'は特別な条件を満たしています。つまりターゲッ
ト`clean'は強制的にその命令を実行させられます。名前の`FORCE'には特別な
意味はありませんが、このような場合に一般的に使用される名前の1つです。

見てわかるように、`FORCE'を使用することは、`.PHONY: clean'を使用した場
合とまったく同じ結果になります。

`.PHONY'を使用することはより明確で効率的な方法です。しかしながら、
`make'のほかのバージョンでは`.PHONY'をサポートしていないため、`FORCE'
がmakefile中に出てきます。*Note 偽のターゲット: Phony Targets.。



File: make-jp.info, Node: Empty Targets, Next: Special Targets, Prev: Force Targets, Up: Rules

レコードイベントに対する空のターゲットファイル
==============================================

"empty target"は偽のターゲットのバリエーションで、ときどき明示的に要求
する動作のために命令を保持するために使用されます。しかし、偽のターゲッ
トと異なり、ファイルの実態を持つことができますが、内容が重要ではなく通
常は空です。

空のターゲットファイルの目的は、ルールの命令が実行されたときの最終更新
時刻を記録することです。つまり、命令の1つがターゲットファイルのアップ
デートのための`touch'コマンドだからです。

また、空のターゲットファイルはいくつかの必要条件を持たなければなりませ
ん（そうでないと無意味だからです）。空のターゲットを再構成する要求をす
る場合、いずれかの必要条件がターゲットよりも新しい場合に命令が実行され
ます。すなわち、ターゲットを再構成した最終の時刻のあとに必要条件が変更
された場合、命令が実行されます。例をあげます。

     print: foo.c bar.c
             lpr -p $?
             touch print

この`make print'ルールは、最後に`make print'を実行されてからソースファ
イルが変更されたかどうかで`lpr'コマンドを実行します。自動変数`$?'は変
更のあったファイルだけを出力する際に使用されます（*Note 自動変数:
Automatic..）。



File: make-jp.info, Node: Special Targets, Next: Multiple Targets, Prev: Empty Targets, Up: Rules

特別な組み込み済みのターゲット名
================================

ターゲットとして使用される場合、いくつかの名前は特別な意味を持ちます。

`.PHONY'

     特別なターゲット`.PHONY'の必要条件は偽のターゲットであるとみなさ
     れます。それがターゲットであるとみなされる場合には、`make'はその
     名前のファイルが存在するかどうかや更新時刻によらず無条件に命令を
     実行します。*Note 偽のターゲット: Phony Targets.。

`.SUFFIXES'

     特別なターゲット`.SUFFIXES'の必要条件は、サフィックスの一覧で、サ
     フィックスルールのチェックに用いられます。*Note 古いスタイルのサ
     フィックスルール: Suffix Rules.。

`.DEFAULT'

     `.DEFAULT'を指定する命令はルール（明示的でも暗黙のルールでも）が
     みつからない場合にすべてのターゲットに対して適用されます。*Note 
     最後の手段のルールの定義: Last Resort.。`.DEFAULT'が指定されると
     き、ルールのターゲットではなく必要条件として言及されるすべてのファ
     イルはそれらの命令を実行されることになります。*Note 暗黙のルール
     のサーチアルゴリズム: Implicit Rule Search.。

`.PRECIOUS'

     `.PRECIOUS'が依存するターゲットは次のような特殊な扱いをされます。
     もし`make'がkillされたり命令の実行が中断された場合、ターゲットは
     削除されません。*Note `make'の中断あるいはkill: Interrupts.。また、
     もしターゲットが中間ファイルである場合には、たとえ不要になったあ
     とでも通常は削除されることはありません。*Note 暗黙のルールの連鎖:
     Chained Rules.。この後者の点については、`.SECONDARY'の特別なター
     ゲットと重なる部分があります。

     また、ターゲットパターンがファイル名にマッチするルールによって生
     成された中間ファイルを保持するために特別なターゲット`.PRECIOUS'の
     必要条件として暗黙のルール（たとえば`%.o'）のターゲットパターンの
     リストをすることが可能です。

`.INTERMEDIATE'

     `.INTERMEDIATE'が依存するターゲットは中間ファイルとして扱われます
     が、必要条件のない`.INTERMEDIATE'は何の効果も持ちません。*Note 暗
     黙のルールの連鎖: Chained Rules.。

`.SECONDARY'

     `.SECONDARY'が依存するターゲットは自動的に削除されない限り、中間
     ファイルとして扱われます。*Note 暗黙のルールの連鎖: Chained
     Rules.。

     また、必要条件のない`.SECONDARY'はすべてのターゲットをセカンダリ
     （二次的な）として扱います（すなわち、中間ファイルであるとみなさ
     れるためターゲットは削除されないのです）。

`.DELETE_ON_ERROR'

     makefileにおいて`.DELETE_ON_ERROR'がターゲットとして記述されてい
     る場合、ルールが変更されて、シグナルを受け取って終了ステータスが
     ゼロ以外で終了した場合には、`make'はルールのターゲットを削除しま
     す。*Note コマンドのエラー: Errors.。

`.IGNORE'

     `.IGNORE'に対して必要条件を指定する場合、`make'は特定のファイルに
     対して命令の実行時にエラーが起きてもそれを無視します。`.IGNORE'の
     ための命令はあまり意味がありません。

     必要条件なしのターゲットとして言及する場合、`.IGNORE'はすべてのファ
     イルに対する命令の実行におけるエラーを無視するようにします。この
     `.IGNORE'の使用は歴史的な互換性のためだけにサポートされています。
     makefileにおけるすべての命令に対する影響はあまり有益ではないため、
     特定の命令のエラーに対してはより選択的な方法がすすめられます。
     *Note コマンドのエラー: Errors.。

`.SILENT'

     `.SILENT'に対する必要条件を指定する場合、`make'は実行前にそれらの
     特定のファイルを再構成する際に命令を出力しません。したがって
     `.SILENT'に対する命令はあまり有益ではありません。

     必要条件なしでターゲットについて言及する場合は、`.SILENT'は命令の
     実行前にいかなる命令も出力しないようにします。`.SILENT'のこの用法は、
     歴史的な互換性のためにサポートされています。*Note コマンドエコー: Echoing.。
     特定の命令を出力させないようにするにはもっと選択的な方法がすすめられます。
     この場合は`make'の実行時に`-s'あるいは`--silent'
     オプションを用います（*Note オプションのサマリー: Options Summary..）。

`.EXPORT_ALL_VARIABLES'

     たんにターゲットとして言及されることによって、`make'に対してデフォ
     ルトで子プロセスにすべての変数をエクスポートします。*Note サブの
     `make'への変数の伝達: Variables/Recursion.。

`.NOTPARALLEL'

     `.NOTPARALLEL'がターゲットとして言及される場合は、`-j' オプション
     がつけられても`make'はシリアルに実行されます。しかし、makefileが
     このターゲットを含んでいない限り、再帰的な`make'の呼び出しはパラ
     レルに行なわれます。そして、このターゲットの必要条件はすべて無視
     されます。

ターゲットとして現われる場合には、暗黙のルールのサフィックスもまた特別
なターゲットとしてカウントされ、`.c.o'のように2つのサフィックスの連結
が行なわれます。これらのターゲットはサフィックスのルールであり、暗黙の
ルールの定義としては古い方法です（広く使われてはいますが）。原則的に、
2つに分解し両方のサフィックスをリストに追加した場合は、どんなターゲッ
トの名前でもこの方法では特別になるでしょう。実際には、サフィックスは通
常は`.'で始まるため、特別なターゲットの名前もまた、`.'で始まることにな
ります。*Note 古いスタイルのサフィックスルール: Suffix Rules.。



File: make-jp.info, Node: Multiple Targets, Next: Multiple Rules, Prev: Special Targets, Up: Rules

ルール中の複数のターゲット
==========================

複数のターゲットを持つルールはたくさんのルールを記述することに等しく、
それぞれが1つのターゲットを別々に記述することと同じです。すべてのター
ゲットに同じ命令を適用する場合には、`$@'を使用することによって実際のター
ゲットを代用できるため、効果は変わるかもしれません。

この2つの場合では有益です。

   * たとえば、必要条件だけで命令は不要な場合、

          kbd.o command.o files.o: command.h

     は、3つのオブジェクトファイルのそれぞれに対して必要条件を与えます。

   * 同様な命令がすべてのターゲットに対して働きます。自動変数`$@'が特
     定のターゲットの代用となり命令を再構成するので、命令は完全に同一
     である必要はありません（*Note 自動変数: Automatic..）。たとえば、

          bigoutput littleoutput : text.g
                  generate text.g -$(subst output,,$@) > $@

     は、以下と同じです。

          bigoutput : text.g
                  generate text.g -big > bigoutput
          littleoutput : text.g
                  generate text.g -little > littleoutput

     ここで、仮想のプログラム`generate'は`-big'と`-little'によって2つ
     のタイプの出力をします。`subst'機能の説明については、*Note 文字列
     の代用と分析のファンクション: Text Functions.。

ターゲットに従って必要条件を変更したい場合には、変数`$@'によって命令を
変更することができます。ここで、普通のルールでは複数のターゲットについ
てこの方法は用いることができませんが、"static pattern rule" （静的なパ
ターンルール）の場合は可能です。*Note 静的なパターンルール: Static
Pattern.。



File: make-jp.info, Node: Multiple Rules, Next: Static Pattern, Prev: Multiple Targets, Up: Rules

1つのターゲットに対する複数のルール
===================================

1つのファイルがいくつかのルールのターゲットになる場合があります。この
場合、すべてのルールのなかで言及されるすべての必要条件が、ターゲットに
対する必要条件のリストにマージされます。そして、ターゲットがルールの必
要条件よりも古い場合には命令が実行されます。

あるファイルに対して実行される命令のセットは1つだけかもしれませんが、
同じファイルに対して複数のルールが命令を与える場合には、`make'は最後の
セットを与えてエラーを出力します。（ただし、ファイル名がドットで始まる
場合にはメッセージは出力されません。この奇妙な動作はほかの`make'のイン
プリメンテーションとの互換性のためです。）したがって、`make'の出力する
メッセージがあるため、この方法でmakefileを記述する必要はありません。

必要条件だけを持つ特別なルールは、同時に多くのファイルにいくつかの特別
な必要条件を与えるのに使用されます。たとえば、`objects'という名前を持
つ変数は通常、コンパイラが出力するファイルのリストを含んでいますが、も
し、`config.h'の変化が以下のように書かれるならば、すべて再コンパイルさ
れなければならず、これを簡単にする方法は、以下のようになります。

     objects = foo.o bar.o
     foo.o : defs.h
     bar.o : defs.h test.h
     $(objects) : config.h

これによって、どのようにしてオブジェクトファイルを作るかというルールを
変更せずに挿入あるいは取り出しが行なわれ、付加的な必要条件を間欠的に追
加したい場合には便利な書式となります。

ただし、`make'のコマンドの引数によるセットを変数に与えて付加的な必要条
件が特定されるという別の影響もあります（*Note 変数のオーバーライド:
Overriding..）。たとえば、

     extradeps=
     $(objects) : $(extradeps)

は、コマンド`make extradeps=foo.h'は`foo.h'をそれぞれのオブジェクトファ
イルの必要条件としてみなしますが、`make'は文句をいいません。

ターゲットに対する明示的なルールのどれもが命令を持たない場合には、
`make'はいくつかの命令を発見する暗黙のルールのサーチを行ないます
（*Note 暗黙のルールの使用: Implicit Rules..）。



File: make-jp.info, Node: Static Pattern, Next: Double-Colon, Prev: Multiple Rules, Up: Rules

静的なパターンルール
====================

  "静的なパターンルール"は複数のターゲットを指定し、ターゲットの名前に
基づいてそれぞれのターゲットに対して必要条件の名前を作製します。ターゲッ
トは同一の必要条件を持つ必要がないため、複数のターゲットを持つ通常のルー
ルよりもより一般的です。このとき必要条件は*類似*していなければなりませ
んが、*同一*である必要はありません。

* Menu:

* Static Usage::                The syntax of static pattern rules.
* Static versus Implicit::      When are they better than implicit rules?



File: make-jp.info, Node: Static Usage, Next: Static versus Implicit, Up: Static Pattern

静的なパターンルールのシンタックス
----------------------------------

ここに静的なパターンルールのシンタックスの例があります。

     TARGETS ...: TARGET-PATTERN: DEP-PATTERNS ...
             COMMANDS
             ...

TARGETSのリストはルールの適用されるターゲットを指定します。そしてその
ターゲットは通常のルールとまったく同様にワイルドカードを含むことが可能
です（*Note ファイル名におけるワイルドカードの使用: Wildcards..）。

TARGET-PATTERNとDEP-PATTERNSは、それぞれのターゲットの必要条件の計算法
について示します。それぞれのターゲットはTARGET-PATTERNにマッチし名前の
部分展開を行ないます。これを"stem"と呼びます。このstemはDEP-PATTERNSの
それぞれに代用され、必要条件の名前の作成に用いられます。

個々のパターンは通常、`%'を1個含んでいます。TARGET-PATTERNがターゲット
にマッチした場合、`%'はターゲット名のどの部分にもマッチすることができ
ます。この部分のことを"stem"といいます。この部分以外は正確にマッチする
必要があり、たとえばターゲット`foo.o'がパターン`%.o'にマッチするとき
`foo'がstemとなります。そして、ターゲット`foo.c'と`foo.out'はそのパター
ンとはマッチしません。

個々のターゲットに対する必要条件の名前は、それぞれの必要条件のパターン
のなかの`%'に対するstemの置き換えによって作成されます。たとえば、ある
必要条件のパターンが`%.c'である場合、stemの代用である`foo'は必要条件の
名前である`foo.c'を与えます。また、`%'を含まない必要条件のパターンを記
述することもまったく問題はありません。この場合はすべてのターゲットに対
して同じ必要条件となります。

パターンルールにおける`%'文字は先行するバックスラッシュによって引用さ
れます。`%'を違った形で引用するバックスラッシュはさらに多くのバックス
ラッシュで引用できます。`%'文字あるいはほかのバックスラッシュを引用す
るバックスラッシュは、ファイル名と比較されたりstemを代用させるまえにパ
ターンから削除されます。`%'文字を引用する可能性のないバックスラッシュ
は悩みの種ではありません。たとえば、パターン`the\%weird\\%pattern\\'は
`%'文字に先行する`the%weird\'を持ち、`pattern\\'があとに続きます。最後
の2つのバックスラッシュはどの`%'にも影響を持たないため取り残されます。

ここに、`.c'に対応した`foo.o'と`bar.o'のそれぞれをコンパイルする例があ
ります。

     objects = foo.o bar.o

     all: $(objects)

     $(objects): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@

ここで、`$<'は必要条件の名前を保持する自動変数で、`$@'はターゲットの名
前を保持する自動変数です。詳しくは、*Note 自動変数: Automatic.を参照し
てください。

個々のターゲットはターゲットパターンにマッチしているはずで、そうでない
場合は警告が出ます。パターンにマッチするわずかなファイルのリストを持つ
場合、マッチしないファイル名を削除するために`filter' 機能を使用するこ
とができます（*Note 文字列の代用と分析のファンクション: Text
Functions..）。

     files = foo.elc bar.o lose.o

     $(filter %.o,$(files)): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@
     $(filter %.elc,$(files)): %.elc: %.el
             emacs -f batch-byte-compile $<

この、`$(filter %.o,$(files))'の結果の例では`bar.o lose.o'を示し、
最初の静的なパターンルールは、対応するCのソースファイルのコンパイルによって
アップデートされるオブジェクトファイルを作り出します。
`$(filter %.elc,$(files))'の結果は、`foo.elc'となり、
`foo.el'からファイルが作り出される結果になります。

別の例では、静的なルールにおける`$*'の使用法を示しています。

     bigoutput littleoutput : %output : text.g
             generate text.g -$* > $@

`generate'コマンドが実行されるとき、`$*'は`big'あるいは`little'のstem
に展開されます。



File: make-jp.info, Node: Static versus Implicit, Prev: Static Usage, Up: Static Pattern

静的なパターンルール対暗黙のルール
----------------------------------

静的なパターンルールは、パターンルールとして定義された暗黙のルールを一
般的に多く持っています（*Note パターンルールの定義と再定義: Pattern
Rules..）。それらの両方ともにターゲットに対するパターンと必要条件の名
前を構成するパターンを持ちますが、その違いは`make'がそのルールを*いつ*
適用するかです。

パターンとマッチするどんなターゲットに対しても暗黙のルールは適用するこ
とが*できます*。しかし、それは、ターゲットが異なる形で指定された命令を
持たないときと必要条件が発見されたときだけに限られます。もし、複数の暗
黙のルールが適用可能であるならば、そのなかの1つだけが適用されます。そ
の適用の選択はルールの順序に依存します。

静的なパターンルールは、ルール中で指定したターゲットの正確なリストに適
用されますが、ほかのターゲットには適用できず、指定されたターゲットのそ
れぞれに対して適用されます。仮に2つの矛盾したルールが適用された場合で
両方が命令を持つ場合にはエラーとなります。

静的なパターンルールは以下のような理由で暗黙のルールよりも優れています。

   * シンタックスで分類できない名前を持ち、明示的なリストを与えられる
     いくつかのファイルに対する通常の暗黙のルールをオーバーライドする
     ことを望む場合もあります。

   * 使用しているディレクトリの正確な内容について確信が持てない場合、
     なんらかの不適切なファイルが`make'に誤った暗黙のルールを使用させ
     てしまうかについて確信が持てないでしょう。その場合の選択は暗黙の
     ルールがサーチした順序に依存します。静的なパターンルールによって、
     不確実性はなくなり、指定されたターゲットに対して正確に個々のルー
     ルが適用されます。



File: make-jp.info, Node: Double-Colon, Next: Automatic Prerequisites, Prev: Static Pattern, Up: Rules

ダブルコロンルール
==================

"ダブルコロン"ルールはターゲットの名前のあとに`:'のかわりに`::'の書か
れたルールです。

複数のルールに1つのターゲットが現われる場合、すべてのルールは同じタイ
プであるはずで、すべて普通のものか、あるいはすべてダブルコロンルールで
す。ダブルコロンルールの場合にはそれぞれが独立したものです。個々のダブ
ルコロンルールの命令は、そのルールのいかなる必要条件よりもターゲットが
古い場合に実行されます。これは、場合によってはダブルコロンルールのすべ
て、あるいは何も結果として生じないかもしれません。

同じターゲットについてのダブルコロンルールは完全に互いに別のものです。
それぞれのダブルコロンルールはあたかも異なるターゲットが処理されるよう
に個別に処理されます。

あるターゲットについてのダブルコロンルールは、makefileでの出現順序で実
行されます。しかしながら、ダブルコロンルールが本当に意味があるのは命令
を実行する順序が重要ではない場合です。

ダブルコロンルールは多少わかりにくく、いつでも有益だというわけではあり
ません。ターゲットをアップデートするために用いられる方法において異なり、
アップデートを必要とする必要条件に依存する場合の仕組みを提供しますが、
そのようなケースは稀です。

個々のダブルコロンルールは命令を指定しなければならず、さもないと暗黙の
ルールが適用されてしまいます。*Note 暗黙のルールの使用: Implicit
Rules.。



File: make-jp.info, Node: Automatic Prerequisites, Prev: Double-Colon, Up: Rules

必要条件の自動生成
==================

あるプログラムについてのmakefileにおいて、記述しなければならない多くの
ルールはいくつかのヘッダファイルに依存するオブジェクトファイルだけであ
る場合がほとんどです。たとえば、`#include'によって`main.c'が`defs.h'を
使用する場合、以下のように記述します。

     main.o: defs.h

`defs.h'が変更された場合にいつでも`main.o'は再構成されなければならない
ことを`make'が知っている必要があるので、このようなルールが必要ですが、
規模の大きなプログラムの場合に、このようなルールをmakefileにたくさん記
述しなければならないことがすぐにわかるはずです。そして、`#include'を加
えたり削除したりする際につねにmakefileをアップデートすることに注意しな
ければならないのです。

そのようなことを避けるために、最近のCコンパイラはソースファイルの
`#include'行を見てこれらのルールを書けるようになっています。通常は、
`-M'オプションをつけることによって可能です。たとえば、

     cc -M main.c

は、以下のような出力を生成します。

     main.o : main.c defs.h

したがって、もはや、そのようなルールを自分で書く必要はなく、コンパイラ
がやってくれます。

ここで、makefileのなかで`main.o'に言及している必要条件に注意してくださ
い。それは、暗黙のルールのサーチによる中間ファイルとしてみなされていま
せん。このことは、`make'がそのファイルを使用したあとに削除しないことを
意味しています（*Note 暗黙のルールの連鎖: Chained Rules..）。

古い`make'プログラムの場合、`make depend'というコマンドによって要求に
応じて必要条件を生成するコンパイラの機能を使用することが伝統的に有効で
したが、そのような命令は必要条件を自動生成する`depend'というファイルを
作ってしまいます。そしてmakefileは`include'を使用してそれを読み込むこ
とになります（*Note ほかのMakefileをインクルードする: Include..）。

GNUの`make'においては、makefileの再構成をする機能は時代遅れとなってい
ます。つまり、`make'に対して明示的に必要条件の再生成を命じる必要はない
のです。なぜなら期限切れのいかなるmakefileもつねに再生成するからです。
*Note Makefileの作られ方: Remaking Makefiles.。

必要条件の自動生成についての実践的な方法は、それぞれのソースファイルに
対して1つのmakefileを持つことです。`NAME.c'の個々のソースファイルにつ
いて`NAME.d'という1つのmakefileを持ち、オブジェクトファイル`NAME.o'が
どれに依存しているかのリストを持つことです。この方法によって、新しい必
要条件を生み出すために変更のあったソースファイルだけがスキャンされるこ
とになります。

ここに、`NAME.c'というCのソースファイルから`NAME.d'という必要条件のファ
イルを生成するパターンルールがあります。

     %.d: %.c
             set -e; $(CC) -M $(CPPFLAGS) $< \
                       | sed 's/\($*\)\.o[ :]*/\1.o $@ : /g' > $@; \
                     [ -s $@ ] || rm -f $@

パターンルールを定義する情報については、*Note パターンルールの定義と再
定義: Pattern Rules.。シェルに対する`-e'フラグは、`$(CC)'コマンドの失
敗（ゼロ以外のステータスで終了する場合）の際にただちに終了させます。通
常は、パイプラインの最後のコマンドのステータスで終了するため、`make'は
コンパイラからのゼロ以外のステータスに気づきません。

GNUのCコンパイラの場合、`-M'のかわりに`-MM'フラグを使用するでしょう。
これはシステムヘッダファイルの必要条件を省略します。詳細は、*Note
Options Controlling the Preprocessor: (gcc.info)Preprocessor Options.。

`sed'コマンドの目的は（たとえば）翻訳することです。

     main.o : main.c defs.h

という内容を

     main.o main.d : main.c defs.h

と翻訳します。この例では、個々の`.d'ファイルが、対応する`.o' ファイル
が依存するすべてのソースとヘッダファイルに依存しています。そして、
`make'はソースファイルやヘッダファイルに変更があるときにはつねに必要条
件の再生成が必要であることを知っています。

一度`.d'ファイルの再構成をするルールを定義すると、`include' ディレクティ
ブを使用してすべてを読み込むことが可能です。*Note ほかのMakefileをイン
クルードする: Include.。たとえば、

     sources = foo.c bar.c

     include $(sources:.c=.d)

（この例ではソースファイル`foo.c bar.c'のリストを必要条件のmakefileの
`foo.d bar.d'に翻訳するために代替変数による参照を使用しています。*Note 
代用の参照: Substitution Refs.。）`.d'ファイルはほかと似ているmakefile
のため、`make'はほかに何もせずに必要に応じて再構成してくれるのです。
*Note Makefileの作られ方: Remaking Makefiles.。



File: make-jp.info, Node: Commands, Next: Using Variables, Prev: Rules, Up: Top

ルールのなかでのコマンドの書き方
********************************

ルールの命令は、1行ずつ実行されるシェルコマンドの行で成り立っていて、
個々の行はタブで始まらなければなりませんが、あいだにセミコロンのあるター
ゲットと必要条件の行は例外です。また、空白行とコメントだけの行もあいだ
に置くことができますが、それらは無視されます。（ただし、タブで始まり明
らかに空白の行は空白では*なく*空の命令です。*Note 空のコマンドの使用:
Empty Commands..。）

ユーザーは多くの異なったシェルプログラムを使用しますが、makefile中のコ
マンドはほかのシェルを指定しない限り、つねに`/bin/sh'によって解釈され
ます。*Note コマンド実行: Execution.。

使用されるシェルは、コマンド行においてコメントが書かれているかどうか、
使用されるシンタックスは何かを決定します。シェルが`/bin/sh'の場合、`#'
がコメントの始まりで、行の終わりまでコメントとされます。また、`#'が行
の先頭にある必要はなく、`#'よりまえのテキストはコメントの一部ではあり
ません。

* Menu:

* Echoing::                     How to control when commands are echoed.
* Execution::                   How commands are executed.
* Parallel::                    How commands can be executed in parallel.
* Errors::                      What happens after a command execution error.
* Interrupts::                  What happens when a command is interrupted.
* Recursion::                   Invoking `make' from makefiles.
* Sequences::                   Defining canned sequences of commands.
* Empty Commands::              Defining useful, do-nothing commands.



File: make-jp.info, Node: Echoing, Next: Execution, Up: Commands

コマンドエコー
==============

通常、`make'はコマンドの実行前に個々のコマンド行を出力します。コマンド
をタイプしたときのように見えることからこれを"エコー"といいます。

行が`@'で始まる場合、エコーは抑制され、コマンドがシェルに渡されるまえ
に`@'は破棄されます。一般的には、makefileを通して実行状態を表示するた
めの`echo'コマンドのように何かを出力する効果のあるコマンドに対してこれ
を用います。

     @echo About to make distribution files

`make'に`-n'あるいは`--just-print'フラグが与えられる場合には、コマンド
のエコーだけを行ない実行はしません。*Note オプションのサマリー:
Options Summary.。このケースにおいてだけ、`@'で始まるコマンドでさえも
出力されます。このフラグは有益で、`make'が必要とするコマンドがどれであ
るかを実行を伴わずにみつけだすことができます。

`-s'あるいは`--silent'フラグが`make'に与えられた場合、すべてのコマンド
が`@'で始まるかのごとくすべてのエコーが抑制されます。必要条件を持たな
い特別なターゲットである`.SILENT'に対するmakefileのルールは同様の効果
を持ちます（*Note 特別な組み込み済みのターゲット名: Special Targets..）。
`@'はより柔軟なため、`.SILENT'は本質的に時代遅れといえます。



File: make-jp.info, Node: Execution, Next: Parallel, Prev: Echoing, Up: Commands

コマンド実行
============

ターゲットをアップデートする命令の実行のタイミングであるとき、それぞれ
の行に対して新しいサブシェルを作ることによって実行されます。（実際には、
`make'は結果に影響を与えないショートカットを捉えます。）

*［Please Note:］*`cd'のような個々のプロセスにローカルな変数をセットす
るシェルコマンドはそれに続く行に対して影響を与えないことを意味している
ことです。 (1) (*Note Execution-Footnotes::) 仮に、`cd'を使用して次の
コマンドに影響与えるようにする場合、1行に2つのコマンドをセミコロンで区
切って置けばよいのです。そして、`make'はそれらを1つのコマンドのように
みなし、連続して実行するようにします。たとえば以下のようになります。

     foo : bar/lose
             cd bar; gobble lose > ../foo

もし、1つのシェルコマンドを複数の行に分割したい場合には、最後の行を除
いてすべての行の終わりにバックスラッシュを置きます。このような連続した
行は、シェルに渡されるまえにバックスラッシュによる分割が削除されて単一
の行として統合されます。したがって、以下の例は前記のものと同じものとな
ります。

     foo : bar/lose
             cd bar;  \
             gobble lose > ../foo

シェルとして使われるプログラムは変数`.SHELL'から得られます。デフォルト
では、`/bin/sh'が使われます。

MS-DOSの場合、`SHELL'がセットされていない場合には変数`COMSPEC'の値がか
わりに用いられます。

Makefileにおいて変数`SHELL'をセットした行の処理はMS-DOSの場合には異な
ります。もともとのシェルである`command.com'は機能が滑稽に制限されてい
て、`make'のユーザーはかわりのシェルをインストールする傾向があります。
したがってMS-DOSにおいては、`make'は`SHELL'変数の値を試し、Unixスタイ
ルかDOSスタイルかによってふるまいを変更します。これによって、たとえ
`SHELL'が`command.com'であっても妥当な機能を提供できるのです。

`SHELL'がUnixスタイルを示す場合、MS-DOSの`make'はそのシェルをみつけだ
そうとします。もし、みつからない場合には`SHELL'をセットした行を無視し
ます。MS-DOSにおいてはGNUの`make'は以下の場所でシェルを検索します。

  1. `SHELL'の値で指定された正確な場所。たとえば、makefileで`SHELL =
     /bin/sh'と指定されている場合、`make'はカレントドライブの`/bin'ディ
     レクトリを探します。

  2. カレントディレクトリ。

  3. `PATH'変数のなかのディレクトリを順番に。


それぞれのディレクトリにおいて`make'は特定のファイル（上記の場合は`sh'）
を探します。みつからない場合は、実行形式のファイル拡張子を持つファイル
をそのディレクトリで探します。たとえば、`.exe'、`.com'、`.bat'、`.btm'
や`.sh'などです。

これらの試みが成功すると、`SHELL'の値はみつかったシェルのフルパスでセッ
トされます。しかしながら、何もみつからない場合には`SHELL'の値は変更さ
れず、その行は無視されます。つまり、`make'が動作するシステムに実際にイ
ンストールされているシェルがUnixスタイルのシェルの場合だけを対象にした
特徴を`make'がサポートしているということです。

ここで、シェルのサーチについては、Makefileで`SHELL'がセットされている
場合には制限されることを注意してください。環境変数やコマンドラインで設
定されている場合には、Unixの場合のようにシェルのフルパスにセットされる
ことが必要です。

以上のDOS限定の処理の効果は、多くのUnixのmakefileのように`SHELL =
/bin/sh'であるMakefileがMS-DOSで`PATH'に従うディレクトリに`sh.exe'がイ
ンストールされている場合に限られます。

大部分の変数と異なり、`SHELL'は環境から設定されることはありません。こ
れは、環境変数`SHELL'が対話的な使用をするシェルを個人の好みで指定でき
るからです。しかし、個人の選択によることはmakefileの機能への影響として
は好ましくないのです。*Note 環境（変数）からの変数の取得: Environment.。
しかし、MS-DOSやMS-Windowsにおいては環境変数のなかの`SHELL'の値が用い
られます。これらのシステムのユーザーはこの変数を設定しませんので、
`make'によって使用されるように明確に指定する必要があります。また、
MS-DOSにおいては`SHELL'のセッティングが`make'にとって適当ではない場合
に`make'が使用する`MAKESHELL'変数を設定することができ、これは`SHELL'を
オーバーライドします。


File: make-jp.info  Node: Execution-Footnotes, Up: Execution

(1) MS-DOSにおいてはカレントディレクトリは*global*のため、それ
を変更する場合は続く行に影響を与えます。



File: make-jp.info, Node: Parallel, Next: Errors, Prev: Execution, Up: Commands

パラレル実行
============

GNUの`make'はいくつかのコマンドを同時に実行することができます。通常は
`make'は一度に1つのコマンドの実行しかせず、直前の処理の終了を待ってか
ら次の処理に移ります。しかしながら、`-j'あるいは`--jobs'オプションがあ
る場合は、`make'は多くのコマンドを同時に実行します。

ただし、MS-DOSにおいてはマルチプロセッシングをサポートしていないので、
`-j'オプションは意味がありません。

`-j'オプションのあとに整数がつく場合は、同時に実行するコマンドの数を表
わし、これを"ジョブスロット"の数といいます。`-j'オプションのあとに整数
がないときは、ジョブスロットに制限がないことを意味します。ジョブスロッ
トのデフォルトの値は1で、シリアルな実行を意味します。

同時にいくつかのコマンドを実行した際に不愉快なのは、種々のコマンドが出
すメッセージがバラバラに出てくることです。

もう1つ別の問題は、2つのプロセスが同じデバイスから入力を得ることができ
ないことです。したがって、ターミナルからの入力を得ようとするコマンドが
一度に1つになるように気をつけなければならず、`make'は標準入力を無効に
して1つのコマンドが動作するようにします。つまり、複数の子プロセスに対
する標準入力からの読み込みは通常はエラー（`Broken pipe'シグナル）にな
るということです。

どのコマンドが有効な標準入力ストリーム（ターミナルまたは`make'の入力を
リダイレクトするデバイス）であるかを予測することは困難です。つねに最初
のコマンドの実行がそれを獲得して、その終了後に次々に獲得していきます。

ほかに選択肢があるならば、`make'のこの特徴をどのように変更したいと考え
るでしょうか。パラレル実行を用いる場合には、標準入力を用いるいかなるコ
マンドも信頼しないでしょう。しかし、この機能を使用しない場合は標準入力
はすべてのコマンドで正常に動作します。

最終的には、再帰的な`make'の呼び出しが問題として出てきます。詳細は、
*Note サブの`make'へのオプションの伝達: Options/Recursion.  を参照して
ください。

コマンドの実行が失敗した場合（シグナルでkillされるか、ゼロ以外のステー
タスで終了した場合）、しかもエラーが無視されなかった場合（*Note コマン
ドのエラー: Errors..）、同じターゲットを再構成するための残されたコマン
ドは実行されません。コマンドが失敗して`-k'や`--keep-going'オプションが
与えられないときには（*Note オプションのサマリー: Options Summary..）、
`make'は実行を中止します。子プロセス側の理由によってmakeが中断する場合
には、終了するまえに、それらの終了を待ちます。

システムのロード（負荷）が大きい場合、小さいときに比較して少ないジョブ
を実行させようとするはずです。`-l'オプションをつけることによって、
`make'に対してロードアベレージに応じて同時に実行するジョブの数を制限す
ることができます。`-l'あるいは`--max-load'オプションに続けて小数を例の
ように加えます。

     -l 2.5

この場合、ロードアベレージが2.5を超えたときには`make'は複数のジョブを
開始しません。また、`-l'に数値をつけない場合は以前の`-l'で与えたロード
の制限をなくします。

より正確にいうと、`make'がジョブを開始する際にすでに少なくとも1つのジョ
ブが動作中だとすると、現在のロードアベレージをチェックし、`-l'で与えら
れた制限よりも小さくない場合には`make'は、ロードアベレージが下がるのを
待つか、ほかのすべてのジョブが終了するのを待ちます。

デフォルトでは、この制限はありません。



File: make-jp.info, Node: Errors, Next: Interrupts, Prev: Parallel, Up: Commands

コマンドのエラー
================

個々のシェルコマンドに戻ったあと、`make'は終了ステータスを見ます。コマ
ンドの実行が成功している場合は次のコマンド行が新しいシェルで実行されま
す。最後のコマンド行が終了するとルールが終了となります。

もしエラーが起きた場合（終了ステータスがゼロでない場合）、`make'は現在
のルールを諦め、おそらくすべてのルールについても諦めます。

一定のコマンドの実行時の失敗は問題を表示しないことがあります。たとえば、
ディレクトリの存在を保証するために`mkdir'コマンドを使うかもしれません。
すでにそのディレクトリが存在している場合、`make'はエラーを報告しますが
これを無視してほしい場合もあります。

コマンド行におけるエラーの無視をさせる場合には、`-'を最初のタブのあと
の行の先頭に置きます。`-'はコマンドが実行のためにシェルに渡される直前
に破棄されます。

たとえば、

     clean:
             -rm -f *.o

このようにしておけば、削除できない場合でも`rm'は継続できます。

`-i'または`--ignore-errors'フラグをつけて`make'を実行した場合、すべて
のルールのすべてのコマンドのエラーが無視されます。必要条件がない場合に
は、特別なターゲット`.IGNORE'に対するmakefileのルールは同様の効果を持
ちます。ただし、その方法は時代遅れで、`-'のほうがより柔軟性があります。

`-i'または`--ignore-errors'フラグによってエラーが無視される場合、
`make'はステータスコードを出力する以外はエラーを無視し、成功したかのご
とく扱い、コマンドから抜け、エラーが無視されたことを示します。

`make'に対して無視するように指定されなかったエラーが起きた場合には、現
在のターゲットが正しく再構成されないか、直接的あるいは間接的にほかに依
存していることを暗示しています。必要条件が達成されなければ、ターゲット
に対してのそれ以上のコマンドの実行は行なわれません。


通常、`make'はこのような状況ではただちに諦め、ゼロでないステータスを返
します。しかしながら、`-k'または`--keep-going'フラグが指定されている場
合、`make'は諦めてゼロでないステータスを返すまえに、必要に応じて保留に
なっているターゲットのほかの必要条件を再構成することを継続しようとしま
す。たとえば、あるオブジェクトファイルのコンパイルでエラーとなったあと、
`make -k'はリンクすることが不可能とわかっていてもほかのオブジェクトファ
イルのコンパイルを継続します。*Note オプションのサマリー: Options
Summary.。

`make'の通常のふるまいは、特定のターゲットをアップデートすることが目的
であると仮定しています。しかし、`make'はこれが無理だとわかるとただちに
失敗を表示します。`-k'オプションによって実際の目的が可能な限りプログラ
ムでの変更をテストできるようにすることで、次のコンパイルのまえにいくつ
かの独立した問題を解決できるように発見することができます。Emacsの
`compile'コマンドがデフォルトで`-k'フラグを渡すのはこのような理由によ
ります。

通常、コマンドが実行に失敗し、ターゲットファイルが変更された場合、その
ファイルは損なわれて使用されないことになります。あるいは少なくとも完全
にはアップデートされません。ファイルのタイムスタンプがアップデートすべ
きタイミングだと告げても、次回の`make'の実行時にアップデートは行なわれ
ません。この状況はシグナルによってコマンドがkillされた場合によく似てい
ます（*Note `make'の中断あるいはkill: Interrupts..）。したがって、一般
的には、ファイルの変更開始後にコマンドが失敗した場合には、ターゲットファ
イルを削除するのが正しい方法でしょう。`make'は`.DELETE_ON_ERROR'がター
ゲットになっている場合にそのように動作します。この動作は`make'に関して
好ましい動作なのですが、歴史的な互換性のため明確に指示する必要がありま
す。



File: make-jp.info, Node: Interrupts, Next: Recursion, Prev: Errors, Up: Commands

`make'の中断あるいはkill
========================

コマンド実行時に`make'が致命的なシグナルを受け取った場合、コマンドによっ
てアップデートされるはずのターゲットファイルを削除することになります。
これは、ターゲットファイルが`make'の最初のチェックから最終更新時刻が変
化している場合に行なわれます。

ターゲットの削除の目的は、次回`make'が動作する際に最初から再構成するこ
とを確認することです。これはなぜかというと、コンパイラが動作している際
に`Ctrl-c'が押されたとします。その際、`foo.o'が書き始められていたとし
ます。`Ctrl-c'はコンパイラをkillし、結果的にソースファイル`foo.c'より
も新しい最終更新時刻を持つ不完全なファイルができてしまうことになります。
しかし`make'もまた`Ctrl-c'シグナルを受けるため、この不完全なファイルを
削除します。`make'がこうしなければ、次回の`make'の呼び出し時に`foo.o'
をアップデートしないことになります。その結果、半端なオブジェクトファイ
ルのリンクを試みようとしたリンカから奇妙なエラーメッセージが示されてし
まいます。

このようなターゲットファイルの削除を特別なターゲット`.PRECIOUS'を作る
ことで防ぐこともできます。ターゲットの再構成のまえに、`make'は
`.PRECIOUS'の必要条件の有無をチェックし、シグナルが発生したときにター
ゲットを削除すべきかどうかを判断します。この方法を用いる場合は、ターゲッ
トが自動的な流れのなかでアップデートされたり、内容によらずに修正時刻の
記録のために存在したり、トラブルのソートを防ぐためにつねに存在しなけれ
ばならないなどの場合です。



File: make-jp.info, Node: Recursion, Next: Sequences, Prev: Interrupts, Up: Commands

`make'の再帰的用法
==================

`make'の再帰的用法とは、makefile中のコマンドとして`make'を用いることで
す。大きなシステムを作る際のさまざまなサブシステムにmakefileを分割した
い場合にこのテクニックは有益です。たとえば、サブディレクトリ`subdir'が
あってそのなかにmakefileがあり、そのなかで`make'を実行したい場合には以
下のように記述することができます。

     subsystem:
             cd subdir && $(MAKE)

もしくは、以下と同様です（*Note オプションのサマリー: Options
Summary..）。

     subsystem:
             $(MAKE) -C subdir

読者はこの例をコピーして`make'の再帰的なコマンドを書くことができます。
しかし、それらがどのように働き、サブの`make'がトップレベルの`make'とど
のように関連するのかなどを知っておく必要があります。

便利なように、GNUの`make'は変数`CURDIR'をカレントのワーキングディレク
トリのパス名にセットすることができます。`-C'が有効な場合は、オリジナル
ではなく新しいディレクトリのパス名を含みます。makefileに設定された場合
は、その変数の値は同じ優位性を持ちます（デフォルトでは環境変数`CURDIR'
はそれをオーバーライドしません）。注意しなければならないのは、この変数
の設定は`make'の動作にはまったく影響しないということです。

* Menu:

* MAKE Variable::               The special effects of using `$(MAKE)'.
* Variables/Recursion::         How to communicate variables to a sub-`make'.
* Options/Recursion::           How to communicate options to a sub-`make'.
* -w Option::                   How the `-w' or `--print-directory' option
                                 helps debug use of recursive `make' commands.



File: make-jp.info, Node: MAKE Variable, Next: Variables/Recursion, Up: Recursion

`MAKE'変数の働き
----------------

`make'を再帰的に用いる場合は、以下のようにつねに`MAKE'変数を用い、コマ
ンド`make'は使用しません。

     subsystem:
             cd subdir && $(MAKE)

この変数の値は`make'が呼び出されるファイル名です。このファイル名が
`/bin/make'である場合、実行されるコマンドは`cd subdir && /bin/make'で
す。特別なバージョンの`make'をトップレベルのmakefileで使用する場合には、
その同じバージョンが再帰的に呼び出されます。

特別な機能として、変数`MAKE'をルールのコマンドで使用する場合、
`-t'(`--touch'）、`-n'(`--just-print'）あるいは
`-q'(`--question'）の効果を代替します。また、`MAKE'
変数を使用する場合、`+'文字をコマンド行の先頭で試用する場合と
同じ効果をもたらします。
*Note コマンド実行の代替: Instead of Execution.。

上記の例で、コマンドを`make -t'とみなしてください。（`-t'
オプションは実際には何もコマンドを実行せずにターゲットが
最新であることにします。*Note コマンド実行の代替: Instead of Execution.
を参照。）`-t'の通常の定義に従って、例のなかの`make -t'
コマンドは`subsystem'という名前のファイルを作るだけでほかには
何もしません。本当に実行したいコマンドは`cd subdir && make -t'
のはずですが、実際にはコマンドが実行されません。

この特別な仕組みは希望どおりのことをしてくれます。それは、ルールのコマ
ンド行が変数`MAKE'を含んでいる場合はつねに`-t'、`-n'、`-q'フラグはその
行に適用されません。`MAKE'を含んでいるコマンド行は、ほとんどのコマンド
が実行されないフラグの存在にかかわらず正常に実行されます。通常の
`MAKEFLAGS'の仕組みは、サブの`make'にフラグを渡します（*Note サブの
`make'へのオプションの伝達: Options/Recursion..）。したがって、ファイ
ルのtouchやコマンドの出力の要求はサブシステムに伝達されます。



File: make-jp.info, Node: Variables/Recursion, Next: Options/Recursion, Prev: MAKE Variable, Up: Recursion

サブの`make'への変数の伝達
--------------------------

トップレベルの`make'の変数の値は、明示的な要求によって環境（変数）を通
してサブの`make'に渡されます。また、これらの変数はデフォルトでサブの
`make'のなかで定義されます。しかし、`-e'スイッチを使用しない限り、サブ
の`make'のmakefileによって使用されるmakefileで指定されるものをオーバー
ライドしません（*Note オプションのサマリー: Options Summary..）。

渡された、もしくは"エクスポート"された変数の値を`make'はコマンドの実行
のために環境にセットします。反対にサブの`make'は変数テーブルをその環境
を初期化に用います。*Note 環境（変数）からの変数の取得: Environment.。

明確な要求による以外は、`make'は環境の初期状態で定義されるか、あるいは
コマンド行でセットされる場合にだけ変数をエクスポートします。また、その
場合は文字、数字、アンダースコアだけからなる名前となります。シェルによっ
ては、文字、数字、アンダースコア以外の文字からなる名前には対処できない
場合があります。

`SHELL'という特別な変数と`MAKEFILES'はつねにエクスポートされます（エク
スポートしないという要求がない限り）。`MAKEFILES'はまた必ずエクスポー
トされます。

`make'はコマンド行で定義された変数の値を`MAKEFILES'変数に置くことによっ
て、サブの`make'に自動的に渡します。*Note サブの`make'へのオプションの
伝達: Options/Recursion.。

変数は、`make'によってデフォルトで作成されたものである場合は通常は渡さ
れ*ません* （*Note 暗黙のルールで使用される変数: Implicit Variables..）。
サブの`make'はそれらの定義を自身で行ないます。

特定の変数をサブの`make'に渡したい場合は、`export'ディレクティブを以下
のように用います。

     export VARIABLE ...

変数のエクスポートを*したくない*場合には、`unexport'ディレクティブを以
下のように用います。

     unexport VARIABLE ...

変数とエクスポートを同時に行なう便利な方法もあります。

     export VARIABLE = value

は、以下と同じ結果をもたらします。

     VARIABLE = value
     export VARIABLE

また、

     export VARIABLE := value

は、以下と同様の結果をもたらします。

     VARIABLE := value
     export VARIABLE

同様に

     export VARIABLE += value

は、以下とまったく同じです。

     VARIABLE += value
     export VARIABLE

*Note 変数へのテキストの追加: Appending.。

ここで、`make'のなかの`export'と`unexport'ディレクティブはシェル`sh'に
おいて同じように働くことに気づくかもしれません。

デフォルトですべての変数をエクスポートさせる場合は`export'をこのように
使用できます。

     export

これは、`make'に対して`export'や`unexport'ディレクティブで明確に言及さ
れない変数をエクスポートさせるように指示します。`unexpot'ディレクティ
ブで与えられたいかなる変数も決してエクスポート*されません*。一方、デフォ
ルトで`export'を用いて変数がエクスポートされる場合は、英数字とアンダー
スコア以外の文字をを含む名前の変数は`export'ディレクティブでとくに言及
しない限りエクスポートされることはありません。

`export'ディレクティブによって起きるふるまいは、GNUの`make'の古いバー
ジョンではデフォルトです。makefileがこのふるまいに依存している場合で古
いバージョンの`make'との互換性を保ちたい場合には、特別なターゲット
`.EXPORT_ALL_VARIABLES'を`export'ディレクティブのかわりに記述します。
そうすると、古い`make'では無視され、`export' ディレクティブはシンタッ
クスエラーを起こします。

また、`unexport'を使用することで、`make'がデフォルトで変数をエクスポー
ト*しない*ように設定することもできます。このふるまいはデフォルトなので、
`export'が以前に指定されている場合にのみ必要になります。しかし、
`export'と`unexport'によっていくつかのコマンドに関しては変数をエクスポー
トし、ほかのコマンドに対してはエクスポートしないということはできません。
最後に現われた`export'または`unexport'ディレクティブが`make'の動作を決
定します。

特殊な機能として、変数`MAKELEVEL'は下位のレベルに渡される際に変更され
ます。この変数の値は文字列で、レベルの深さを10進数で表わすものです。値
は、`0'がトップレベルの`make'、`1'がサブの`make'、`2'がサブのサブの
`make'というぐあいです。この数値の増加は、コマンドに対する環境への
`make'のセットが行なわれる場合に発生します。

`MAKELEVEL'の主な用途は、条件ディレクティブにおいてそれをテストするこ
とです（*Note Makefileの条件文: Conditionals..）。この方法によって、
makefileのふるまいを再帰的に動作するか、あるいは直接的に動作するかを記
述することができます。

また、すべてのサブの`make'のコマンドが付加的なmakefileを使用するように
変数`MAKEFILES'を使用することができます。`MAKEFILE'の値は、空白で区切
られたファイル名のリストで、外部のmakefileで定義されている場合には、こ
の変数は環境変数を通じて渡されます。そして、事前にそれを読み込むように、
サブの`make'に対して特別なmakefileのリストを与えることになります。
*Note `MAKEFILES'の変数: MAKEFILES Variable.。



File: make-jp.info, Node: Options/Recursion, Next: -w Option, Prev: Variables/Recursion, Up: Recursion

サブの`make'へのオプションの伝達
--------------------------------

`-s'と`-k'フラグなどは変数`MAKEFLAGS'を通じてサブの
`make'に自動的に渡されます。この変数は`make'により自動的に
設定され、`make'が受け取ったフラグ文字になります。したがって、
`make -ks'を実行すると、`MAKEFLAGS'は`ks'という値を
得ることになります。

結果的に、すべてのサブの`make'は自身の環境において、`MAKEFLAGS'に対す
る値を得ることになります。そして、あたかも引数を与えられたかのように値
とプロセスからフラグを得ることになります。*Note オプションのサマリー:
Options Summary.。

また、コマンド行で定義された変数は`MAKEFLAGS'を通じてサブの`make'に渡
されます。`='を含む`MAKEFLAGS'の値は、あたかもコマンド行で現われたかの
ように`make'が変数定義として扱います。*Note 変数のオーバーライド:
Overriding.。

オプション`-C'、`-f'、`-o'と`-W'は`MAKEFLAGS'に渡されず、下位のレベル
にも渡されません。

`-j'オプションは特別なケースです（*Note パラレル実行: Parallel..）。な
んらかの数値`N'を設定して、OSがそれをサポートしている場合（大部分の
Unixがそうですが、それ以外はそうではありません）、親にあたる`make'とす
べてのサブの`make'は`N'個のジョブだけが同時に動作するのを保証するよう
に伝達します。注意すべきことは、再帰的にマークされた（*Note コマンド実
行の代替: Instead of Execution..）いかなるジョブもトータルなジョブの数
にはカウントされないことです。（いいかえれば、`N'個のサブの`make'だけ
が動作し、実際のworkのためのスロットも残されていない状態になるというこ
とです。）

読者のOSが上記のような伝達をサポートしていない場合、指定した値のかわりに、
`MAKEFLAGS'に対して`-j 1'がつねに渡されます。このことは、
`-j'オプションがサブの`make'に渡される理由で、パラレルに
実行される要求よりも多くのジョブを得られます。数字なしで`-j'を
与えた場合、可能な限り多くのジョブがパラレルに動作し、下位に伝達されます。

もし、ほかのフラグを下位に伝達したくない場合には、`MAKEFLAGS'の値を以
下のように変更します。

     subsystem:
             cd subdir && $(MAKE) MAKEFLAGS=

コマンド行の変数定義は実際には`MAKEOVERRIDES'変数において現われます。
また`MAKEFLAGS'はこの変数への参照を含みます。通常のように下位への伝達
を望む場合で、コマンド行の変数定義の伝達は望まない場合は、以下のように
記述します。

     MAKEOVERRIDES =

この方法はつねに有益であるとは限りませんが、システムによっては環境変数
のサイズに制限があり小さすぎる場合があり、`MAKEFIL'の値を代入する際に
そのサイズを越える場合があります。`Arg list too long'というエラーメッ
セージが表示された場合はこの問題です。（POSIX.2に対しての厳格な準拠の
ため、`MAKEOVERRIDES'は特定のターゲット`.POSIX'がmakefileに現われる場
合には`MAKEFLAGS'に影響を与えませんので気にする必要はありません。）

歴史的な互換性のために、同様な変数`MFLAGS'もあります。この変数はコマン
ド行の変数定義を含まないことを除けば、`MAKEFLAGS'と同じ値を持ち、空で
ない限りつねにハイフンで始まります（`--warn-undefined-variables'のよう
に複数文字のバージョンのオプションで始まる場合だけはハイフンで始まりま
す）。

     subsystem:
             cd subdir && $(MAKE) $(MFLAGS)

しかし、現在の`MAKEFLAGS'ではこの使用法は冗長です。makefileを古い
`make'プログラムと互換性を保つ場合にこの方法を使用してください。そうし
ておけば、現在の`make'と同様にうまく動作するでしょう。

`-k'のようなオプション（*Note オプションのサマリー: Options Summary..）
を使用し`make'を実行するごとにセットしようとする場合には、`MAKEFLAGS'
変数もまた有益です。使用法は環境設定のなかで`MAKEFLAGS'に値をセットす
るだけで、makefileに対して効果のあるように付加的なフラグを指定します。
（注意すべきことは、この方法では`MFLAGS'は使用できないことです。この変
数は互換性のためだけにあり、`make'はその値を解釈しません。）

`make'が`MAKEFLAGS'の値を解釈する際（環境変数またはmakefileから）には、
値の前にあるハイフンから行なわれます。そして、空白によって値を区切り、
それらをコマンド行のオプションのように解釈していきます（ただし、`-C'、
`-f'、`-h'、`-o'、`-W'とそのロングネームバージョンは無視されますし、不
正な値に対してエラーを返しません）。

`MAKEFLAGS'を環境設定に入れる場合は、`make'の動作に影響を与えたり
makefileの目標などに影響を与えるオプションが含まれていないことを確認す
る必要があります。たとえば、`-t'、`-n'や`-q'オプションが含まれている場
合、よくない結果が待っていて、悩みの種になってしまうことでしょう。



File: make-jp.info, Node: -w Option, Prev: Options/Recursion, Up: Recursion

`--print-directory'オプション
-----------------------------

いくつかのレベルの`make'の再帰的呼び出しを行なう場合、`-w'あるいは
`--print-directory'オプションは`make'が処理を開始し終了する
それぞれのディレクトリの表示を簡単にすることができます。たとえば、
`make -w'がディレクトリ`/u/gnu/make'で実行される場合、
`make'は次の書式で表示させることができます。

     make: Entering directory `/u/gnu/make'.

なにかを実行するまえにこのように記述し、終了したあとのために以下のよう
に1行記述しておきます。

     make: Leaving directory `/u/gnu/make'.

@noindent

通常は、このオプションを指定する必要がありません。なぜなら、`-C'を使用
すると自動的に`-w'がオンになり、サブの`make'でもそうだからです。しかし、
メッセージを出さない`-s'オプションをつけた場合、あるいは
`--no-print-directory'を明確に指示した場合には、`make'は`-w'を自動的に
オンにはしません。



File: make-jp.info, Node: Sequences, Next: Empty Commands, Prev: Recursion, Up: Commands

コマンドの組み合わせの定義
==========================

さまざまなターゲットを作る際にコマンドの同じシーケンスが有用な場合、
`define'ディレクティブによって決まったシーケンスとして定義することがで
き、ターゲットのルールからそのシーケンスを参照することがも可能になりま
す。このシーケンスは実際には変数のため、ほかの変数名と矛盾しないように
しなければなりません。

ここにコマンドのシーケンスの定義の例があります。

     define run-yacc
     yacc $(firstword $^)
     mv y.tab.c $@
     endef

ここで、`run-yacc'は定義する変数名で、`endef'は定義の終わりを示します。
この2つのあいだの行がコマンドになります。`define' ディレクティブは参照
する変数を展開せず、シーケンスにおいてファンクションコールも行ないませ
ん。`$'文字、括弧、変数名などは定義する変数の値の一部となります。
`define'の完全な説明については、*Note 変数のまったく同一の定義:
Defining.。

この例の最初のコマンドは、ルールがコマンドシーケンスを使用することにか
かわらず、最初の必要条件としてYaccの実行を行ないます。Yaccからの出力ファ
イルは`y.tab.c'となります。2番目のコマンドはその出力をルールのターゲッ
トファイル名に変更します。

コマンドのシーケンスを使用するためには、ルールのコマンドに変数を代入し
ます。そして何かほかの変数（*Note 変数参照の基礎: Reference..）のよう
に代用します。`define'で定義された変数は再帰的に変数に展開されるため、
`define'で記述された変数の参照は展開されます。たとえば、

     foo.c : foo.y
             $(run-yacc)

`foo.y'は、`run-yacc'の値や`$@'に対する`foo.c'に存在するときは変数`$^'
に対して代用されます。

これは実例ですが、このような特殊なものは実際にはありません。なぜならば、
`make'はファイル名に基づくコマンドのこのような役割を暗黙のルールとして
持っているからです（*Note 暗黙のルールの使用: Implicit Rules..）。

コマンドの実行に際しては、それぞれのコマンドのシーケンスは、ルールのな
かで独自に現われたかのようにタブが先頭についた形で扱われます。そして、
`make'はそれぞれの行で独立したサブシェルを呼び出します。また、コマンド
行に影響を与える特別なプレフィックス文字（`@'、`-'と`+'）をそれぞれの
コマンドシーケンスで用いることができます。*Note ルールのなかでのコマン
ドの書き方: Commands.。以下は、このようなコマンドシーケンスの例です。

     define frobnicate
     @echo "frobnicating target $@"
     frob-step-1 $< -o $@-step-1
     frob-step-2 $@-step-1 -o $@
     endef

`make'は最初の行すなわち`echo'コマンドをエコーしませんが、次の2つのコ
マンド行はエコー*します*。

一方、シーケンスへの参照に用いられるコマンドのプレフィックス文字はシー
ケンスのすべての行に適用されるため、ルールは、以下のようになります。

     frob.out: frob.in
             @$(frobnicate)

このように*一切*エコーしません。（`@'の詳しい説明については、*Note コ
マンドエコー: Echoing.。）



File: make-jp.info, Node: Empty Commands, Prev: Sequences, Up: Commands

空のコマンドの使用
==================

何もしないコマンドを定義することが有用な場合があります。この場合、以下
のように単純に空白からなるコマンドを与えるだけでいいのです。

     target: ;

`target'に対して空白のコマンドを与えます。または、タブ文字から始まる空
のコマンド文字列を使用することもできますが、見かけ上、何もない状態にな
りますので混乱することがあります。

何もしないコマンドを定義する理由は何でしょうか。その唯一の理由は、ター
ゲットが暗黙のコマンド（暗黙のルールから、あるいは`.DEFAULT'の特別なター
ゲットから）を得てしまうことを防ぐ意味です。`.DEFAULT'の特別なターゲッ
トについては*Note 暗黙のルールの使用: Implicit Rules.、*Note 最後の手
段のルールの定義: Last Resort.を参照してください。


現実のファイルではないターゲットに対して空のコマンド文字列を定義しよう
と考えても、実際には必要条件の再構成が可能なようにできるだけです。しか
しながら、この方法はベストとはいえません。なぜなら、ターゲットファイル
が実際に存在する場合には必要条件が適切に再構成できなくなるからです。よ
りよい方法については、*Note 偽のターゲット: Phony Targets.。



File: make-jp.info, Node: Using Variables, Next: Conditionals, Prev: Commands, Up: Top

変数の使用法
************

"変数"は、makefileのなかで文字列の代理となるための名前の定義です。それ
らの"値"は明確な要求によってターゲット、必要条件、コマンドあるいは
makefileの一部で代用されます。（`make'のバージョンによっては変数は"マ
クロ"と呼ばれます。）

makefile中の変数とファンクションは読み込みの際に展開されます。ただし、
ルールにおけるシェルコマンドは例外で、`='を使った変数定義の右側と
`define'ディレクティブを使用した変数定義の本体は展開されません。

変数はいろいろなものを代用することができ、それらは、ファイル名のリスト、
コンパイラに渡すオプション、実行するプログラム、ソースファイルを探すディ
レクトリ、出力するディレクトリなどです。

変数は、`:'、`#'、`='と空白を含まない文字列で表わされます。しかし、変
数はまた、文字以外の数字、アンダースコアは使用を避けるべきでしょう。な
ぜなら、それらは将来特別な意味を持つからです。また、シェルによっては環
境変数を通してサブの`make'に渡せない場合もあります（*Note サブの`make'
への変数の伝達: Variables/Recursion..）。

また、変数名は大文字小文字を区別し、`foo'と`FOO'と`Foo'はすべて異なる
ものとして参照されます。

伝統的には大文字を使いますが、makefileにおいては目的にかなうように小文
字の使用を推奨します。大文字は明示的なルールのコントロールのためのパラ
メータやコマンドのオプションのオーバーライドのためのパラメータに使用す
ることを推奨します（*Note 変数のオーバーライド: Overriding..）。

いくつかの変数は単一の文字またはごく少ない文字列になっていて、それらは
"自動変数"と呼ばれ特別な用途に用いられます。*Note 自動変数: Automatic.。

* Menu:

* Reference::                   How to use the value of a variable.
* Flavors::                     Variables come in two flavors.
* Advanced::                    Advanced features for referencing a variable.
* Values::                      All the ways variables get their values.
* Setting::                     How to set a variable in the makefile.
* Appending::                   How to append more text to the old value
                                  of a variable.
* Override Directive::          How to set a variable in the makefile even if
                                  the user has set it with a command argument.
* Defining::                    An alternate way to set a variable
                                  to a verbatim string.
* Environment::                 Variable values can come from the environment.
* Target-specific::             Variable values can be defined on a per-target
                                  basis.
* Pattern-specific::            Target-specific variable values can be applied
                                  to a group of targets that match a pattern.
* Automatic::                   Some special variables have predefined
                                  meanings for use with implicit rules.



File: make-jp.info, Node: Reference, Next: Flavors, Up: Using Variables

変数参照の基礎
==============

変数の値を代用するには、括弧または中括弧のなかにドル記号に続いて変数名
を書きます。たとえば、`$(foo)'や`${foo}'は変数`foo'の正しい参照例です。
また、`$'の特別な点は、ファイル名やコマンドにおいて1個のドル記号を表わ
す際は、`$$'と記述しなければならないことです。

変数参照は文脈のどこからでも行なわれます。たとえば、ターゲット、必要条
件、コマンド、大部分のディレクトリ、そして新たな変数などからです。ここ
に一般的な例がありますが、プログラムのすべてのオブジェクトの名前を変数
が保持しています。

     objects = program.o foo.o utils.o
     program : $(objects)
             cc -o program $(objects)

     $(objects) : defs.h

変数は、テキストの正確な代用により、動作を参照します。したがって、ルー
ル、

     foo = c
     prog.o : prog.$(foo)
             $(foo)$(foo) -$(foo) prog.$(foo)

は、C言語のプログラムの`prog.c'をコンパイルします。変数のまえのスペー
スは無視されるため、`foo'の値は正確に`c'です。（ただし、実際のmakefile
にはこのように記述しないでください。）

ドル記号以外の文字、開いている括弧または中括弧がドル記号に続く場合はそ
れを変数名として扱います。したがって、変数`x'は`$x'で参照できます。し
かし、この方法は自動変数以外ではうまくいきません（*Note 自動変数:
Automatic..）。



File: make-jp.info, Node: Flavors, Next: Advanced, Prev: Reference, Up: Using Variables

変数の2つのフレーバー
=====================

GNUの`make'において変数が値を持つには2つの方法があります。それを変数の
2つの"フレーバー"と呼びます。このフレーバーは、定義のされ方と展開され
るときのタイミングによって区別されます。

1つめのフレーバーは、"再帰的に展開された"変数で、`='（*Note 変数の設定:
Setting..）あるいは`define'ディレクティブ（*Note 変数のまったく同一の
定義: Defining..）を使って定義されたものです。指定する値はまったく同一
にインストールされ、ほかの変数への参照を含む場合でも代用されるときには
いつでも展開されます。このような展開を"再帰的な展開" と呼びます。

たとえば、

     foo = $(bar)
     bar = $(ugh)
     ugh = Huh?

     all:;echo $(foo)

は、`Huh?'というエコーを表示します。`$(fo)'は`$(bar)'に展開され、さら
に`$(ugh)'に展開され、最終的に`Huh?'になります。

この変数のフレーバーは別のバージョンの`make'だけでサポートされています。
その利点としては、

     CFLAGS = $(include_dirs) -O
     include_dirs = -Ifoo -Ibar

の例で意図されていることは、`CFLAGS'がコマンドに展開されるとき、`-Ifoo
-Ibar -O'と展開されます。ここで不便なことは、変数の最後に何かを付加で
きないことです。

     CFLAGS = $(CFLAGS) -O

なぜなら、これは変数の展開において無限ループを引き起こしてしまうからで
す。（実際には、`make'はそれと検知し、通知してくれます。）

別の不便な点は変数が展開されるときはつねに定義におけるファンクション
（*Note テキスト変換のためのファンクション: Functions..）への参照が行
なわれることです。これによって`make'は動作が遅くなり、さらに、
`wildcard'と`shell'ファンクションに対して予測不可能でコントロールでき
ない結果をもたらします。

再帰的な変数の展開による問題と不便さを回避するには、もう1つのフレーバー、
すなわち単純な変数の展開というものがあります。

"変数の単純な展開"は、`:='（*Note 変数の設定: Setting..）を使用して定
義します。単純に展開される変数の値は一度すべてに対して行なわれ、ほかの
変数とファンクションへの参照も*定義された時点*で行なわれます。そして、
その実際の値は記述したテキストの展開結果となります。ほかの変数への参照
は何も含まないため、

     x := foo
     y := $(x) bar
     x := later

は、以下と同じになります。

     y := foo bar
     x := later

単純に展開された変数が参照されたとき、その値はまったく同じに代用されま
す。

ここには多少複雑な例があり、`shell'ファンクションと連携した`:='の使用
について説明します（*Note `shell'ファンクション: Shell Function.）。こ
の例では、変数`MAKELEVEL'の使用について示していて、下のレベルに値が渡
される際の変更について示しています。`MAKELEVEL'については、*Note サブ
の`make'への変数の伝達: Variables/Recursion.。

     ifeq (0,${MAKELEVEL})
     cur-dir   := $(shell pwd)
     whoami    := $(shell whoami)
     host-type := $(shell arch)
     MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
     endif

`:='の使用による利便性は、典型的なディレクトリを下るコマンドにおいて以
下のようになることです。

     ${subdirs}:
           ${MAKE} cur-dir=${cur-dir}/$@ -C $@ all

一般的に単純に展開される変数は、多くのプログラミング言語の変数のように
働くため、複雑なmakefileのプログラミングをより予測可能なものにします。
また、その変数の値自体（あるいは展開機能を使った値の処理によって）を使っ
て再定義を可能にしたり、展開機能をより効果的にすることが可能です
（*Note テキスト変換のためのファンクション: Functions..）。

変数の値に空白を使用することもできます。しかし、その空白は変数参照の代
用とファンクションコールのまえに破棄されます。このことは、変数の参照に
よって保護される変数の値にスペースを含むことができるということを示し、
以下のように表わせます。

     nullstring :=
     space := $(nullstring) # end of the line

ここで、変数`space'の値はまさに1個のスペースです。コメントの
`# end of the line'はたんにわかりやすくするためのものです。後続の
空白文字が変数の値と切り離せ*ない*ために、行の終わりの1個の空白は
同じ効果を持ちます（読み取ることは困難ですが）。変数の値の終わりに
スペースを置く場合は、意図を明らかにするという目的でコメントを
行の終わりに置くのがよいでしょう。反対に、変数の値の最後にスペースを
置きたく*ない*場合には、以下のように、行の終わりに適当なコメントを
複数のスペースに続いて置いてはなりません。

     dir := /foo/bar    # directory to put the frobs in

ここで、変数`dir'の値は`/foo/bar '（4つのスペースが
続いています）で、意図とは異なるでしょう。ここでは、`$(dir)/file'
としたいはずです。

変数に対する別の割り当てを行なう演算子`?='があります。これは条件変数割
り当て演算子と呼ばれます。その理由は、変数が定義されていない場合にだけ
効果を持つからで、ステートメントは以下のようになります。

     FOO ?= bar

は以下と同じです（*Note `origin'ファンクション: Origin Function..）。

     ifeq ($(origin FOO), undefined)
       FOO = bar
     endif

空の値をセットされた変数がすでに定義されていて、`?='は変数にセットされ
ていないことに注意してください。



File: make-jp.info, Node: Advanced, Next: Values, Prev: Flavors, Up: Using Variables

変数参照の進んだ機能
====================

この節では、より柔軟な変数の参照法のいくつかの方法について記述します。

* Menu:

* Substitution Refs::           Referencing a variable with
                                  substitutions on the value.
* Computed Names::              Computing the name of the variable to refer to.



File: make-jp.info, Node: Substitution Refs, Next: Computed Names, Up: Advanced

代用の参照
----------

"代用参照"は、指定した変更による変数の値の代用を行ないます。この場合、
`$(VAR:A=B)' （あるいは`${VAR:A=B}'）の書式を持ち、変数VARの値をとり、
すべての語の終わりのAはBの値で置き換えられ、文字列が代用されます。

語の終わりという意味は、空白が続くかあるいは置き換えられる値の終わりの
どちらかにAが現われることを意味しています。Aが値に現われるほかの場合は
変更できません。たとえば、

     foo := a.o b.o c.o
     bar := $(foo:.o=.c)

のように、`bar'を`a.c b.c c.c'とセットします。*Note 変数の設定:
Setting.。

代用参照は、実際には`patsubst'展開機能（*Note 文字列の代用と分析のファ
ンクション: Text Functions..）の短縮です。したがって、代用参照はほかの
`make'のインプリメンテーションに対する互換性のために`patsubst'と同じく
提供されます。

別のタイプの代用参照は`patsubst'機能のすべてを利用することができます。
書式は前と同じで、`$(VAR:A=B)'ですが、Aは1個の`%'文字を含まなければな
りません。このケースは、`$(patsubst A,B,$(VAR))'と同じです。`patsubst'
ファンクションの説明については、*Note 文字列の代用と分析のファンクショ
ン: Text Functions.。

たとえば、

     foo := a.o b.o c.o
     bar := $(foo:%.o=%.c)

のように、`bar'を`a.c b.c c.c'とセットします。



File: make-jp.info, Node: Computed Names, Prev: Substitution Refs, Up: Advanced

計算された変数名
----------------

計算された変数名は洗練されたmakefileプログラミングのためだけに必要な複
雑な概念です。ほとんどの場合これを用いる必要はなく、例外は名前にドル記
号を用いた変数を作る際に奇妙な結果を得る場合です。しかし、すべてを理解
したい、あるいは興味があるならば読み進んでください。

変数は、内部的に名前のなかで参照されます。これは"計算された変数名"、あ
るいは"ネストされた変数の参照"と呼ばれます。たとえば、

     x = y
     y = z
     a := $($(x))

において、`a'は`z'として定義され、`$($(x))'の内部の`$(x)'は`y'に展開さ
れます。したがって`$(y)'に展開される`$($(x))'は反対に`z'に展開されます。
ここで参照される変数の名前は明示的ではありません。それは`$(x)'の展開か
ら計算されたものです。また`$(x)'の参照は外部からの参照においてネストし
ています。

前記の例では、2つのレベルのネストでした。しかし、どんな数のレベルでも
可能です。3つのレベルの場合の例を示します。

     x = y
     y = z
     z = u
     a := $($($(x)))

もっとも奥のレベルの`$(x)'は`y'に展開され、したがって、`$($(x))'は
`$(y)'に展開され、反対に`z'に展開されます。そして、`$(z)'は`u'となりま
す。

変数名による変数の再帰的展開に対する参照は通常の方式で再展開されます。
たとえば、

     x = $(y)
     y = z
     z = Hello
     a := $($(x))

この場合、`a'を`Hello'として定義しています。したがって`$($(x))'は
`$($(y))'となり、`$(z)'となって最後には`Hello'となります。

ネストされた変数の参照はほかの参照と同様に（*Note テキスト変換のための
ファンクション: Functions..）、修正された参照や呼び出されたファンクショ
ンをも含んでいる場合があります。たとえば、`subst'ファンクション（*Note 
文字列の代用と分析のファンクション: Text Functions..）を使用する例とし
て、

     x = variable1
     variable2 := Hello
     y = $(subst 1,2,$(x))
     z = y
     a := $($($(z)))

は、`a'を`Hello'として定義しています。このネストの記述の仕方は複雑で、
誰でもこう記述したいかどうかは疑問としても、これはきちんと動作します。
`$($($(z)))'が`$($(y))'に展開され、`$($(subst 1,2,$(x)))'に展開されま
す。`x'からの値`variable1'を得て、`variable2'への代用によって変更が加
えられます。結果的に`$(variable2)'となり、値が`Hello'である変数の参照
となります。

計算された変数名は単一の変数の参照からなっているわけではありません。複
数の変数の参照からなることもできますし、ある不変のテキストである場合も
あります。たとえば、

     a_dirs := dira dirb
     1_dirs := dir1 dir2

     a_files := filea fileb
     1_files := file1 file2

     ifeq "$(use_a)" "yes"
     a1 := a
     else
     a1 := 1
     endif

     ifeq "$(use_dirs)" "yes"
     df := dirs
     else
     df := files
     endif

     dirs := $($(a1)_$(df))

の場合は、`dirs'に同じ値として`use_a'と`use_dirs'のセットに応じて、
`a_dirs'、`1_dirs'、`a_files'あるいは`1_files'を与えます。

また、計算された変数名は代用参照においても使用されます。

     a_objects := a.o b.o c.o
     1_objects := 1.o 2.o 3.o

     sources := $($(a1)_objects:.o=.c)

は、`sources'を`a1'の値に応じて、`a.c b.c c.c'あるいは`1.c 2.c 3.c'と
して定義します。

ネストされた変数の参照の利用における唯一の制限は、呼び出されるファンク
ションの名前の一部を指定できないことです。これは、ネストされた参照の展
開が行なわれるまえに、認知されているファンクションの名前に対するテスト
が行なわれるためです。

     ifdef do_sort
     func := sort
     else
     func := strip
     endif

     bar := a d b g q c

     foo := $($(func) $(bar))

の場合は、`foo'に対して`sort'あるいは`strip'ファンクションの引数として
`a d b g q c'が与えられるのではなく、変数`sort a d b g q c'あるいは
`strip a d b g q c'の値が与えられようとします。この制限は、よいアイデ
アがあれば将来的になくすることができるでしょう。

また、変数割り当ての左側あるいは`define'ディレクティブにおいて、この計
算された変数名を使用することができます。

     dir = foo
     $(dir)_sources := $(wildcard $(dir)/*.c)
     define $(dir)_print
     lpr $($(dir)_sources)
     endef

この例では、変数`dir'、`foo_sources'と`foo_print'を定義しています。

ここで注意してほしいのは、"ネストされた変数参照"と"再帰的に展開された
変数"（*Note 変数の2つのフレーバー: Flavors..）はmakefileのプログラミ
ングでは複雑な方法で同時に使用される場合があるものの、両者はまったく異
なるということです。



Info file: make-jp.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `make-jp.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.







INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Make: (make).            Remake files automatically.
END-INFO-DIR-ENTRY


This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

This is Edition 0.55, last updated 04 April 2000, of `The GNU Make
Manual', for `make', Version 3.79.

Copyright (C) 1988, '89, '90, '91, '92, '93, '94, '95, '96, '97, '98,
'99, 2000 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.




File: make-jp.info, Node: Values, Next: Setting, Prev: Advanced, Up: Using Variables

変数の値の取得の仕方
====================

変数はいくつかの異なる方法で値を取得できます。

   * `make'を実行する際にオーバーライドする値を指定することができます。
     *Note 変数のオーバーライド: Overriding.。

   * makefileのなかで値を指定することができます。これは割り当て（*Note 
     変数の設定: Setting..）あるいは、同一の定義（*Note 変数のまったく
     同一の定義: Defining..）によります。

   * `make'の変数となる環境変数のなかの変数（を使用する方法）。*Note 
     環境（変数）からの変数の取得: Environment.。

   * いくつかの"自動"変数はルールによって新しい値を与えられます。それ
     ぞれは従来の用途を持ちます。*Note 自動変数: Automatic.。

   * いくつかの変数は初期値として定数を持ちます。*Note 暗黙のルールで
     使用される変数: Implicit Variables.。



File: make-jp.info, Node: Setting, Next: Appending, Prev: Values, Up: Using Variables

変数の設定
==========

makefileから変数をセットするには、行の先頭から変数名に続いて`=' あるい
は`:='を記述します。`='あるいは`:='のあとは変数の値となります。たとえ
ば、

     objects = main.o foo.o bar.o utils.o

では、変数名`objects'を定義しています。変数名の隣のスペースと`='のあと
のスペースは無視されます。

`='で定義された変数は"再帰的に展開される"変数です。また`:='で定義され
た変数は"単純に展開される"変数です。これらの定義はその定義が作られるま
えに展開される変数の参照を含んでいます。*Note 変数の2つのフレーバー:
Flavors.。

変数名はファンクションと変数の参照を含んでいます。そしてそれらは使用さ
れる実際の変数名をみつけるための行が読み込まれるときに展開されます。

変数の値の長さは、コンピュータのスワップ領域の量を除けば制限はありませ
ん。変数の定義が長い場合にはバックスラッシュを適当な位置に置くことによ
り複数の行に分割することが賢明です。このことは`make'の機能に影響を与え
ず、可読性のよさにつながります。

設定を行なわない限り、ほとんどの変数名は空の文字列を値として持っている
とみなされますが、いくつかの変数はあらかじめ組み込まれた空でない初期値
を持っていて、その変更もできます（*Note 暗黙のルールで使用される変数:
Implicit Variables..）。いくつかの特別な変数は、自動的にそれぞれのルー
ルに従って新しい値にセットされます。これらを"自動変数"と呼びます
（*Note 自動変数: Automatic..）。

すでに設定されていない場合にだけ値をセットしようとする場合、`='のかわ
りに略式演算子`?='を使用することができます。変数`FOO'の2つの設定は同じ
ものです（*Note `origin'ファンクション: Origin Function..）。

     FOO ?= bar

は、以下と同じです。

     ifeq ($(origin FOO), undefined)
     FOO = bar
     endif



File: make-jp.info, Node: Appending, Next: Override Directive, Prev: Setting, Up: Using Variables

変数へのテキストの追加
======================

すでに定義されている変数の値にさらにテキストを追加することが有益な場合
がしばしばあります。その場合、例のように`+='を含む行を使用します。

     objects += another.o

この場合、変数`objects'の値を取得していて、テキスト`another.o'を追加し
ています。したがって、

     objects = main.o foo.o bar.o utils.o
     objects += another.o

は、`objects'を`main.o foo.o bar.o utils.o another.o'にセットしていま
す。

`+='を使用するのは、

     objects = main.o foo.o bar.o utils.o
     objects := $(objects) another.o

に似ていますが、より複雑な値を用いる場合には重要となります。

事前に定義されていない変数が問題になる場合、`+='は通常の`=' のように働
きます。つまり、再帰的な展開を行なう変数を定義します。しかしながら、事
前に定義が*ある*場合は、`+='の動作は最初にどのフレーバーで定義されてい
るかに依存します。2つの変数のフレーバーについての説明は、*Note 変数の2
つのフレーバー: Flavors.。

`+='によって変数の値に追加する場合、変数の初期定義のテキストを含むかの
ように`make'は働きます。最初に`+='で定義を行なう場合、`+='は単純展開の
変数にテキストを追加し、`:='のように古い値に追加をするまえに新しいテキ
ストを展開します（`:='の説明については、*Note 変数の設定: Setting..）。
実際には以下のようになります。

     variable := value
     variable += more

はまったく以下と同じです。

     variable := value
     variable := $(variable) more

一方では、最初に`='を使用して再帰的展開をするように定義した変数に`+='
を使用する場合、`make'は少しだけ違う動作をします。再帰的展開を定義する
場合を思い出してください。変数やファンクションの参照に対してセットした
値を`make'はただちに展開はしません。新しい変数（*Note 変数の2つのフレー
バー: Flavors..）に参照を行なう際に、テキストをまったく同じ状態で格納
するかわりに、あとで展開するために変数とファンクションの参照を保存しま
す。再帰的展開をさせる変数について`+='を使用する場合は、指定したテキス
トを`make'が追加する未展開のテキストに対して行なうことになります。

     variable = value
     variable += more

は、ほぼ以下と同じです。

     temp = value
     variable = $(temp) more

ここでは、`temp'と呼ばれる変数は例外的に定義していません。ここで重要と
なるのは、変数の古い値が参照を含む場合に問題になることです。共通の例と
して以下をあげます。

     CFLAGS = $(includes) -O
     ...
     CFLAGS += -pg # enable profiling

最初の行では、別の変数`include'への参照に用いられる`CFLAGS'を
定義しています。（`CFLAGS'はCのコンパイルの際のルールに使用されます。
*Note 暗黙のルールのカタログ: Catalogue of Rules..。）
定義に対する`='の使用は`CFLAGS'を再帰的展開変数にします。
`$(includes) -O'は`make'が`CFLAGS'の定義を処理する際に
展開*しない*ことを意味しています。したがって`includes'はその値が
有効になるまで、定義の必要はなく、`CLAGS'に参照が
及ぶ直前にだけ定義されればよいのです。`+='を使用せずに、
`CFLAGS'の値に追加するには、以下のように記述してしまいます。

     CFLAGS := $(CFLAGS) -pg # enable profiling

しかし、この方法は望むものに近いのですが、完全ではありません。`:='を
使用することは`CFLAGS'を単純展開の変数として再定義します。つまり、
`make'はテキスト`$(CFLAGS) -pg'をその変数をセットするまえに
展開します。もし、`includes'がまだ定義されていない場合、
` -O -pg'を得るため、`includes'の定義は効果を
持たなくなります。反対に、`+='の使用によって`CFLAGS'を
*未展開*の値`$(includes) -O -pg'にセットします。したがって、
`includes'に対する参照を保存するため、あとの時点で定義を得られるならば、
`$(CFLAGS)'はその値をまだ使い続けます。



File: make-jp.info, Node: Override Directive, Next: Defining, Prev: Appending, Up: Using Variables

`override'ディレクティブ
========================

コマンドの引数で変数がセットされた場合、makefileのなかでの通常の割り当
ては無視されます（*Note 変数のオーバーライド: Overriding..）。しかし、
コマンドの引数でセットされたにもかかわらずmakefileのなかに変数をセット
したい場合には、`override'ディレクティブを使用することができ、以下のよ
うな行となります。

     override VARIABLE = VALUE

あるいは、

     override VARIABLE := VALUE

コマンド行で定義された変数にさらにテキストを追加するには、以下の例を使
います。

     override VARIABLE += MORE TEXT

*Note 変数へのテキストの追加: Appending.。

`override'ディレクティブはmakefileとコマンド引数のあいだの論争がエスカ
レートしているあいだは使用されませんでした。コマンド引数によってユーザー
の指定した値に変更と追加が可能なようにされたのです。

たとえば、Cコンパイラを実行する際に`-g'スイッチをつねに使用するとしま
す。しかしユーザーがコマンド引数としてほかのスイッチを指定するのを許可
したいと思う場合、この`override'ディレクティブを使用します。

     override CFLAGS += -g

また、`override'ディレクティブを`define'ディレクティブとともに使用する
こともできます。

     override define foo
     bar
     endef

*Note 変数のまったく同一の定義: Defining.。



File: make-jp.info, Node: Defining, Next: Environment, Prev: Override Directive, Up: Using Variables

変数のまったく同一の定義
========================

変数の値のセットのもう1つ別の方法は、`define'ディレクティブを使用する
方法です。このディレクティブは通常のシンタックスとは異なり、改行文字を
値に含みます。これはコマンドのシーケンスの定義をするのに便利です
（*Note コマンドの組み合わせの定義: Sequences..）。

`define'ディレクティブは同じ行で変数名だけがそのあとに続きます。そして
変数の値は次の行に現われます。値の終わりには、`endef'という語だけの行
が置かれます。シンタックスの違いは別として、`define'は`:=' とよく似た
働き、すなわち再帰的展開の変数を作成します（*Note 変数の2つのフレーバー:
Flavors..）。変数名はファンクションと変数への参照を含み、使用される実
際の変数名を発見するためにディレクティブが読み込まれる際に展開されます。

     define two-lines
     echo foo
     echo $(bar)
     endef

通常の割り当てにおける変数の値は改行文字を含みませんが、`define' にお
ける値の行は改行文字で区切られ、変数の値になります（ただし、`endef'よ
りもまえで、値の一部とみなされない最後の改行文字を除きます）。

前記の例は機能的には以下と同一です。

     two-lines = echo foo; echo $(bar)

セミコロンで区切られた2つのコマンドは2つの別のシェルコマンドのようにふ
るまいます。しかしながら、気をつけなければならないのは、2つに別れた行
を使う場合は`make'はシェルを2回呼び出し、それぞれ独立したサブシェルを
個々の行で実行するということです。*Note コマンド実行: Execution.。

また、コマンド行での変数定義よりも`define'による変数定義を優先したい場
合は、`define'とともに`override'ディレクティブを使用することができます。

     override define two-lines
     foo
     $(bar)
     endef

*Note `override'ディレクティブ: Override Directive.。



File: make-jp.info, Node: Environment, Next: Target-specific, Prev: Defining, Up: Using Variables

環境（変数）からの変数の取得
============================

`make'のなかの変数は`make'が動作している環境変数から取得することもでき
ます。`make'がその起動を監視している環境変数は、その同じ名前と値で
`make'の変数になります。ただし、makefileで明示的に割り当てられたものや
コマンドの引数として与えられたものは環境変数からの値をオーバーライドし
ます。（`-e'フラグが指定されている場合、環境変数がmakefileのなかの変数
をオーバーライドしますが、実際には推奨しません。*Note オプションのサマ
リー: Options Summary.。しかし、この手法はあまりすすめられるものではあ
りません。）

したがって、環境設定で`CFLAGS'変数をセットしている場合、C言語のコンパ
イルにおいて希望するコンパイラのスイッチを使用することができます。この
ことは、標準あるいは従来の意味付けを持つ変数に対しては安全な方法です。
なぜならば、makefileがそれらをほかのことに使うことはないことがわかって
いるからです。（しかし、実はこのことは信頼できないことです。makefileに
よっては`CFLAGS'を明示的に設定するため、環境変数の影響がまったくないこ
ともあるからです。）

`make'が再帰的に呼び出される場合、外部の呼び出しで定義された変数は環境
を通して内部の呼び出しに渡されます（*Note `make'の再帰的用法:
Recursion..）。デフォルトでは、環境変数またはコマンド行からもたらされ
た変数のみが再帰的な呼び出しにおいて渡されます。また、`export'ディレク
ティブを使用してほかの変数を渡すこともできます。詳細については、*Note 
サブの`make'への変数の伝達: Variables/Recursion.。

環境からの変数のほかの使用は推奨されません。その理由は、外部から設定さ
れたmakefileの環境変数に対するファンクションに依存することは、同一の
makefileでも異なったユーザーに異なった結果をもたらすため賢明とはいえな
いからです。このことはmakefileの目的に反することといえます。

そのような問題はとくに変数`SHELL'について見受けられます。それは通常、
対話型のシェルがユーザーの選択で決められ環境変数に設定されているからで
す。このことが`make'に対しては非常に望ましくないことになります。したがっ
て、`make'は`SHELL'の環境変数を無視するようになっています（ただし、
MS-DOSとMS-Windowsでは通常`SHELL'がセットされていません。*Note コマン
ド実行: Execution.）。



File: make-jp.info, Node: Target-specific, Next: Pattern-specific, Prev: Environment, Up: Using Variables

ターゲット固有の変数の値
========================

`make'のなかの変数の値は通常はグローバルです。すなわち（無論、リセット
されない限り）評価される位置を問わず同じです。ただし、自動変数だけは例
外です（*Note 自動変数: Automatic..）。

ほかの例外は、"ターゲット固有の変数の値"です。この機能を使用すると
`make'が現在ビルドをしているターゲットの同じ変数に異なった値を定義する
ことができます。自動変数の場合は、ターゲットのコマンドスクリプトの文脈
の中だけでそれらの値は有効です（ほかのターゲット固有の割り当てにおい
て）。

ターゲット固有の変数の値のセットは以下のようにします。

     TARGET ... : VARIABLE-ASSIGNMENT

あるいは以下のようになります。

     TARGET ... : override VARIABLE-ASSIGNMENT

複数のターゲットの値は、ターゲットリストの個々のメンバーに対する変数の
値を作成します。

変数割り当てはいろいろな割り当ての有効な書式を取ることができます。再帰
的（`='）、静的（`:='）、追加（`+='）あるいは条件（`?='）といったもの
です。変数割り当てに現われるすべての変数はターゲットの文脈のなかで評価
されます。したがって、事前に定義されたターゲット固有の変数の値はすべて
有効となります。注意しなければならないのは、この変数の値はいかなるグロー
バルな変数の値とも実際には別個のものであることで、同一のフレーバーであ
る必要はありません。

ターゲット固有の変数はmakefileのほかの変数と同じプライオリティを持ちま
すが、コマンド行で提供される変数（そして、`-e'オプションのある場合の環
境において）は優先します。`override'ディレクティブの指定はターゲット固
有の変数の値を優先します。

ターゲット固有の変数にはもう1つ特別な特徴があります。ターゲット固有の
変数を定義する際、この変数の値はこのターゲットのすべての必要条件で有効
となります（その必要条件が自身のターゲット固有の変数の値をオーバーライ
ドしない限り）。したがって、ステートメントの例は以下のようになります。

     prog : CFLAGS = -g
     prog : prog.o foo.o bar.o

上記の例では、`prog'に対するコマンドスクリプトにおいて`-g'の`CFLAGS'を
セットしています。しかし、それによって`prog.o'、`foo.o'と`bar.o'とそれ
らの必要条件のすべてを作成しようとします。



File: make-jp.info, Node: Pattern-specific, Prev: Target-specific, Up: Using Variables

パターン固有の変数の値
======================

ターゲット固有の変数の値（*Note ターゲット固有の変数の値:
Target-specific..）だけでなく、GNUの`make'はパターン固有の変数の値もサ
ポートします。この場合、指定されたパターンにマッチするいかなるターゲッ
トに対しても変数の定義がされます。この方法で定義された変数は、ターゲッ
ト固有の変数が明示的に定義されたあとで、かつ親のターゲットに対してター
ゲット固有の変数が定義されるまえにサーチされます。

パターン固有の変数の値のセットは以下のようになります。

     PATTERN ... : VARIABLE-ASSIGNMENT

あるいは、以下のようになります。

     PATTERN ... : override VARIABLE-ASSIGNMENT

上記の例ではパターンは%-patternです。ターゲット固有の変数の値があるた
め、複数のパターンの値が個々のパターンに対してのパターン固有の変数の値
を作成します。また変数の割り当てはいろいろな割り当ての書式を取ることが
可能です。ただし、`override'が指定されていない限り、コマンド行での変数
のセットが優先されます。

たとえば、

     %.o : CFLAGS = -O

は、`CFLAGS'を`-o'の値をパターン`%.o'にマッチするすべてのターゲットに
対して割り当てます。



File: make-jp.info, Node: Conditionals, Next: Functions, Prev: Using Variables, Up: Top

Makefileの条件文
****************

makefileの"条件文"は、変数の値に依存し、値によってそれに従うか無視され
ます。また条件文はある変数とほかの変数の値、あるいは定数の文字列との比
較を行ないます。さらに、条件文は`make'がmakefileのなかで何を監視してい
るかをコントロールするため、実行時のシェルコマンドでコントロールされる
ことは*ありません*。

* Menu:

* Conditional Example::         Example of a conditional
* Conditional Syntax::          The syntax of conditionals.
* Testing Flags::               Conditionals that test flags.



File: make-jp.info, Node: Conditional Example, Next: Conditional Syntax, Up: Conditionals

条件文の例
==========

以下の例では、条件文が`make'に対して、`CC'変数が`gcc' の場合に、あるラ
イブラリのセットを使用し、そうでない場合には異なるライブラリを使用する
ように指示しています。2つのコマンド行のうちどちらかがルールのためのコ
マンドとして使われるかがコントロールされています。結果的に、`CC=gcc'が
`make'の引数として変更され、どちらのコンパイラとライブラリを使うかが決
定されます。

     libs_for_gcc = -lgnu
     normal_libs =

     foo: $(objects)
     ifeq ($(CC),gcc)
             $(CC) -o foo $(objects) $(libs_for_gcc)
     else
             $(CC) -o foo $(objects) $(normal_libs)
     endif

条件文は3つのディレクティブを使います。それらは、`ifeq'、`else'、と
`endif'です。

条件文は`ifreq'ディレクティブで始まり、条件を指定します。2つの引数があ
り、それらはカンマで区切られ、括弧で括られています。変数の代用は両者の
引数で行なわれ、比較されます。2つの引数がマッチしている場合には`ifreq'
に続くmakefileの行はそれに従い、そうでない場合は無視されます。

まえの条件が失敗した場合、`else'ディレクティブはそのあとに続く行を無視
させます。上記の例では、1番目の条件が合わない場合にはつねに2番目のリン
クコマンドが実行されることを示しています。条件文で`else'はオプションで
す。

`endif'ディレクティブは条件文の終わりを示します。すべての条件文は
`endif'で終わり、そのあとに条件文でないテキストが続きます。

この例が示すように、条件文はテキストのレベルで動作します。条件文は
makefileの一部として扱われ、無視されたり、その条件に従ったりします。こ
のことによって、ルールのような巨大なmakefileが条件文の開始から終わりま
で記述できるのです。

変数`CC'が値`gcc'を持つ場合、上記の例ではこのような効果があります。

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs_for_gcc)

変数`CC'が別の値を持つ場合、効果は以下のようになります。

     foo: $(objects)
             $(CC) -o foo $(objects) $(normal_libs)

変数割り当てのもう1つの条件文と変数の無条件使用によって同等の結果が得
られます。

     libs_for_gcc = -lgnu
     normal_libs =

     ifeq ($(CC),gcc)
       libs=$(libs_for_gcc)
     else
       libs=$(normal_libs)
     endif

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs)



File: make-jp.info, Node: Conditional Syntax, Next: Testing Flags, Prev: Conditional Example, Up: Conditionals

条件文のシンタックス
====================

`else'のない簡単な条件文のシンタックスは以下のようになります。

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     endif

TEXT-IF-TRUEはどこにあってもよいのですが、条件が真の場合にmakefileの一
部とみなされます。条件が偽である場合はテキストがかわりに用いられること
はありません。

複雑な条件文のシンタックスは以下のようになります。

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     else
     TEXT-IF-FALSE
     endif

条件が真の場合、TEXT-IF-TRUEが使用され、そうでない場合はTEXT-IF-FALSE
がかわりに使用されます。TEXT-IF-FALSEはテキストのどの行に置いてもかま
いません。

CONDITIONAL-DIRECTIVEのシンタックスは、条件文が単純だろうが複雑だろう
が同じです。異なる条件をテストするための4つの異なるディレクティブがあ
り、これを一覧にすると以下のようになります。

`ifeq (ARG1, ARG2)'
`ifeq 'ARG1' 'ARG2''
`ifeq "ARG1" "ARG2"'
`ifeq "ARG1" 'ARG2''
`ifeq 'ARG1' "ARG2"'
     ARG1とARG2におけるすべての変数参照を展開し、比較します。それらが
     同一である場合には、TEXT-IF-TRUEが有効となり、そうでない場合には
     TEXT-IF-FALSEが有効となります。

     変数が空でない値を持つかどうかをテストしたい場合があります。その
     値が変数やファンクションの複雑な展開によりもたらされ、空とみなし
     た展開が実際にはスペース文字を含み空でないように見える場合があり
     ます。しかしながらその場合は、`strip'ファンクション（*Note 文字列
     の代用と分析のファンクション: Text Functions..）を使用して空白を
     空でない値と解釈するのを回避することができます。たとえば、以下の
     ようになります。

          ifeq ($(strip $(foo)),)
          TEXT-IF-EMPTY
          endif

     `$(foo)'の展開が空白文字を含む場合でさえ、TEXT-IF-EMPTYを評価しま
     す。

`ifneq (ARG1, ARG2)'
`ifneq 'ARG1' 'ARG2''
`ifneq "ARG1" "ARG2"'
`ifneq "ARG1" 'ARG2''
`ifneq 'ARG1' "ARG2"'
     ARG1とARG2におけるすべての変数参照を展開し、比較します。それらが
     異なる場合には、TEXT-IF-TRUEが有効となり、そうでない場合には
     TEXT-IF-FALSEが有効となります。

`ifdef VARIABLE-NAME'
     変数VARIABLE-NAMEが空でない値を持つ場合、TEXT-IF-TRUEが有効となり、
     そうでない場合は、TEXT-IF-FALSEが有効となります。以前に定義されて
     いない変数は空の値を持つことになります。

     注意しなければならないのは、`ifdef'はある変数が値を持つかどうかだけを
     テストするということです。変数が空でない場合でもその変数の展開は行ないません。
     結果的に`ifdef'を用いたテストは`foo ='のようなものを除いたすべての
     定義に対して真を返します。空の値をテストする場合には、
     `ifeq ($(foo),)'を使用します。たとえば、以下のようなものです。

          bar =
          foo = $(bar)
          ifdef foo
          frobozz = yes
          else
          frobozz = no
          endif

     `frobozz'を`yes'にセットします。すると、

          foo =
          ifdef foo
          frobozz = yes
          else
          frobozz = no
          endif

     `frobozz'を`no'にセットします。

`ifndef VARIABLE-NAME'
     変数VARIABLE-NAMEが空の値を持つ場合、TEXT-IF-TRUEが有効となり、そ
     うでない場合は、TEXT-IF-FALSEが有効となります。

複数のスペースは条件文のディレクティブの行の始めに置かれても無視される
だけですが、タブは許されません。（もしタブで行が始まる場合には、ルール
に対するコマンドとみなされます。）これとは別ですが、ディレクティブ名あ
るいは引数を除けば、複数のスペースやタブはどこに置かれても何の効果もあ
りません。`#'で始まるコメントは行の終わりに置くことができます。

条件文のなかで役割を持つほかの2つのディレクティブは、`else'と`endif'で
す。それぞれのディレクティブは引数を持たず、1語で書かれます。複数のス
ペースを行の先頭に置くことができますが、それらは無視されます。終わりは
スペースかタブです。`#'で始まるコメントは行の終わりに置くことができま
す。

条件文は`make'が使用するmakefileの行に影響を与えます。条件が真であると
き`make'はTEXT-IF-TRUEの行をmakefileの一部として読みます。条件が偽であ
るときは`make'はその行を完全に無視します。したがって、ルールのような
makefileの文法的な単位は条件文の最初から最後まで安全に分離されるのです。

makefileを読み込むときに`make'は条件文を評価します。したがって、自動変
数を条件文のなかに使用することはできません。なぜならば、コマンドが実行
されるまでそれらは定義されないからです（*Note 自動変数: Automatic..）。

混乱を避ける意味で、1つのmakefileで条件文を開始し、別のmakefileで終了
するといった使い方は許可されません。しかし、条件文に`include' ディレク
ティブを記述することができ、インクルードファイルのなかでその条件文を終
了させることをしないようにさせています。



File: make-jp.info, Node: Testing Flags, Prev: Conditional Syntax, Up: Conditionals

フラグテストの条件文
====================

`findstring'ファンクション（*Note 文字列の代用と分析のファンクション:
Text Functions..）とともに変数`MAKEFLAGS'を使用して`-t'のような`make'
コマンドのフラグをテストする条件文を記述することができます。この方法は、
ファイルを最新であるようにするのに`touch'では十分ではない場合に有効で
す。

`findstring'ファンクションは、ある文字列が別の文字列の一部分として現わ
れるかどうかを決定します。`-t'フラグのテストをしようとする場合、前者に
`t'、後者に`MAKEFLAGS'の値を使用します。

例として、ここでは最新のアーカイブファイルをマークし終えるのに`ranlib
-t'をどのように使用するかを示します。

     archive.a: ...
     ifneq (,$(findstring t,$(MAKEFLAGS)))
             +touch archive.a
             +ranlib -t archive.a
     else
             ranlib archive.a
     endif

`+'プレフィックスはコマンド行を再帰的であるとしてマークし、それらのコ
マンド行は`-t'フラグの使用にもかかわらず実行されるようにします。*Note
`make'の再帰的用法: Recursion.。



File: make-jp.info, Node: Functions, Next: Running, Prev: Conditionals, Up: Top

テキスト変換のためのファンクション
**********************************

"ファンクション"は、makefileにおいて操作するファイルや使用するコマンド
の計算をするためにテキスト処理を行なうことを可能にします。ファンクショ
ンは"ファンクションコール"で用い、ファンクション名を与えた場所で操作を
行なうファンクションの引数をテキストとして与えます。この処理の結果をちょ
うど変数の代用のようにmakefileの呼び出した場所に代用するのです。

* Menu:

* Syntax of Functions::         How to write a function call.
* Text Functions::              General-purpose text manipulation functions.
* File Name Functions::         Functions for manipulating file names.
* Foreach Function::            Repeat some text with controlled variation.
* If Function::                 Conditionally expand a value.
* Call Function::               Expand a user-defined function.
* Origin Function::             Find where a variable got its value.
* Shell Function::              Substitute the output of a shell command.
* Make Control Functions::      Functions that control how make runs.



File: make-jp.info, Node: Syntax of Functions, Next: Text Functions, Up: Functions

ファンクションコールのシンタックス
==================================

ファンクションコールは、変数の参照と似ています。以下のように表わします。

     $(FUNCTION ARGUMENTS)

あるいは、以下のように表わします。

     ${FUNCTION ARGUMENTS}

ここで、FUNCTIONはファンクション名で、`make'の一部である短い名前のリス
トです。また、組み込みファンクションである`call'を使用して独自のファン
クションを作成することもできます。

ARGUMENTSはファンクションの引数で、ファンクション名と複数の
スペースまたはタブで区切られています。1つ以上の引数を持つ場合はカンマで
区切られます。しかし、空白やカンマは引数の値の一部ではありません。
括弧あるいはブラケットであろうと、ファンクションコールで用いたデリミタは
引数においてもペアで用い、そのほかのデリミタは単独で用います。引数自身が
ほかのファンクションコールや変数の参照を含む場合、すべての参照に対して同一の
デリミタを使用することが賢明です。すなわち、`$(subst a,b,${x})'
ではなく`$(subst a,b,$(x))'と記述するほうがよいのです。
このほうがわかりやすく参照の終わりをみつけるのに1種類のデリミタと
マッチさせられるからです。

個々の引数に対して書かれたテキストは変数の代用と引数の値を生み出すファ
ンクションコールの代用によって処理されます。その代用は引数の順序に従っ
て行なわれます。

カンマと対応のない括弧あるいはブラケットは引数のテキストに書いてはなり
ません。また、スペースは最初の引数に書いてはいけません。これらは変数の
代用による引数の値となるからです。最初にカンマとスペース文字とは異なる
変数`comma'と`space'の定義を行ないます。そしてそれらの文字が必要な場所
で代用をします。以下に例を示します。

     comma:= ,
     empty:=
     space:= $(empty) $(empty)
     foo:= a b c
     bar:= $(subst $(space),$(comma),$(foo))
     # barは`a,b,c'。

ここで、`subst'ファンクションは`foo'の値を通して、スペースをカンマで置
換し、結果を代用します。



File: make-jp.info, Node: Text Functions, Next: File Name Functions, Prev: Syntax of Functions, Up: Functions

文字列の代用と分析のファンクション
==================================

ここでは、文字列の操作を行なういくつかのファンクションを扱います。

`$(subst FROM,TO,TEXT)'
     TEXTにおいてテキストの置換を行ないます。FROMはTOですべて置換され
     ます。結果はファンクションコールに代用されます。たとえば、以下の
     ように、

          $(subst ee,EE,feet on the street)

     は、`fEEt on the strEEt'の文字列を代用します。

`$(patsubst PATTERN,REPLACEMENT,TEXT)'
     TESXTのなかの空白で区切られた語のPATTERNとマッチする部分をみつけ
     だし、REPLACEMENTでそれらを置換します。このPATTERNはワイルドカー
     ドの`%'を含み、語のなかのすべての文字とマッチさせます。
     REPLACEMENTにも`%'がある場合、その`%'はPATTERNのなかの`%'にマッチ
     したテキストに置換されます。

     `patsubst'ファンクション呼び出しにおいて`%'文字は先行するバックス
     ラッシュによって引用されます。`%'文字を別の形で引用するバックスラッ
     シュは、さらに複数のバックスラッシュで引用されます。`%'文字、ある
     いはほかのバックスラッシュを引用するバックスラッシュはファイル名
     の比較やstemの代用がされるまえにパターンから削除されます。たとえ
     ば、パターン`the\%weird\\%pattern\\'は`%'文字のまえに`the%weird\'
     を持ち`pattern\\'があとに続きます。終わりの2つのバックスラッシュ
     は`%'文字に何の影響も与えないため取り残されます。

     語と語のあいだの空白は1個の空白にまとめられ、それ以外のスペースは
     破棄されます。

     たとえば以下のようになります。

          $(patsubst %.c,%.o,x.c.c bar.c)

     は、`x.c.o bar.o'を導きます。

     代用参照（*Note 代用の参照: Substitution Refs..）は`patsubst'の効
     果を得るのに、より簡単な方法です。

          $(VAR:PATTERN=REPLACEMENT)

     は、以下と同じです。

          $(patsubst PATTERN,REPLACEMENT,$(VAR))

     2番目の方法としては、`patsubst'の一般的な用法の1つを簡素化したも
     ので、ファイル名の最後のサフィックスを置換するものです。

          $(VAR:SUFFIX=REPLACEMENT)

     は、以下と同じです。

          $(patsubst %SUFFIX,%REPLACEMENT,$(VAR))

     たとえば、以下のようなオブジェクトファイルのリストがあるとします。

          objects = foo.o bar.o baz.o

     対応するソースファイルのリストを得るには、以下のように簡単に書く
     ことができます。

          $(objects:.o=.c)

     一般的な書式を使うかわりに、

          $(patsubst %.o,%.c,$(objects))

     と書くことができます。

`$(strip STRING)'
     STRINGから前後の空白を切り取り、なかの複数の空白を1個のスペースで
     置換します。たとえば、`$(strip a b c )'の結果は`a b c'
     となります。

     `strip'ファンクションは条件文と連携して用いた場合には非常に有益で
     す。`ifeq'あるいは`ifneq'を使用して空の文字列と何かを比較する際、
     空白と空の文字列がマッチしてほしいと願うはずです（*Note Makefile
     の条件文: Conditionals..）。

     しかし、以下の例は望んだ結果とは異なる結果になるでしょう。

          .PHONY: all
          ifneq   "$(needs_made)" ""
          all: $(needs_made)
          else
          all:;@echo 'Nothing to make!'
          endif

     `ifneq'ディレクティブにおいて、ファンクションコール
     `$(strip $(needs_made))'を用いて変数参照
     `$(needs_made)'を置換するほうが確実です。

`$(findstring FIND,IN)'
     FINDの出現に対してINをサーチする場合、値はFINDになり、さもなけれ
     ば値は空になります。与えられた文字列の特定の部分文字列の存在をテ
     ストするために条件文のなかでこのファンクションを使用することがで
     きます。したがって、以下の2つの例

          $(findstring a,a b c)
          $(findstring a,b c)

     は、`a'と`'（空の文字）を導きます。`findstring'の実用的なアプリケー
     ションについては、*Note フラグテストの条件文: Testing Flags.。

`$(filter PATTERN...,TEXT)'
     どのPATTERNとマッチ*する*TEXTにおける空白で区切られた語のすべてを
     返します。そして、マッチ*しない*語はすべて削除します。ここで、パ
     ターンは`%'を使用して書かれたもので、`patsubst'ファンクションで用
     いられたものとよく似ています。

     `filter'ファンクションは変数におけるファイル名のような異なったタ
     イプの文字列を分離するのに用いられます。たとえば、以下のように、

          sources := foo.c bar.c baz.s ugh.h
          foo: $(sources)
                  cc $(filter %.c %.s,$(sources)) -o foo

     は、`foo'は`foo.c'、`bar.c'、`baz.s'と`ugh.h'に依存していますが、
     `foo.c'、`bar.c'と`baz.s'だけはコマンドでコンパイラに対して指定さ
     れているという意味です。

`$(filter-out PATTERN...,TEXT)'
     どのPATTERNともマッチ*しない*TEXTにおける空白で区切られた語のすべ
     てを返します。そしてマッチ*する*語はすべて削除します。これは
     `filter'ファンクションの完全に逆のファンクションです。

     PATTERNの語とマッチするTEXT中の空白で区切られたすべての語を削除し、
     マッチしないものだけを返します。この機能は`filter'とはまったく正
     反対のものです。

     たとえば、以下のようなものです。

          objects=main1.o foo.o main2.o bar.o
          mains=main1.o main2.o

     以下の例では、`main'にないすべてのオブジェクトファイルのすべての
     リストを生成します。

          $(filter-out $(mains),$(objects))

`$(sort LIST)'
     LISTの語を辞書的な順でソートし、重複した語を削除します。出力は1個
     のスペースで区切られた語のリストです。

          $(sort foo bar lose)

     は、値として`bar foo lose'を返します。

     `sort'は付随的に重複した語を削除しますので、ソートの順を気にせず
     にこれを使用することができます。

`subst'と`patsubst'の使用例として現実的なものをあげます。makefileが
`VPATH'変数によってディレクトリリストを指定し、`make'は必要条件のファ
イルをサーチするとしてください（*Note `VPATH'：すべての必要条件のサー
チパス: General Search..）。この例では、Cのコンパイラに対してディレク
トリの同じリストにおけるヘッダファイルをサーチすることをどのように伝え
るかを示しています。

`VPATH'の値は`src:../headers'のようなコロンで区切られたディレクトリの
リストです。最初に`subst'ファンクションでコロンがスペースに置換されま
す。

     $(subst :, ,$(VPATH))

この結果`src ../headers'が得られます。そして、`patsubst'がそれぞれのディ
レクトリ名を`-I'フラグに戻すために用いられます。この結果は変数`CFLAGS'
の値に付加され、Cコンパイラに自動的に渡されます。

     override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))

この効果はテキスト`-Isrc -I../headers'を以前に与えられた`CFLAGS' の値
に追加することになります。`override'ディレクティブは、以前の`CFLAGS'の
値がコマンドの引数で指定されていたとしても新しい値を割り当てるのに用い
られます（*Note `override'ディレクティブ: Override Directive..）。



File: make-jp.info, Node: File Name Functions, Next: Foreach Function, Prev: Text Functions, Up: Functions

ファイル名に対するファンクション
================================

ここでは、ファイル名やファイル名のリストに関連したいくつかの組み込み済
みの拡張ファンクションについて解説します。

以下のファンクションのそれぞれはファイル名について指定された変換を行な
うものです。ファンクションの引数は一連のファイル名としてみなされ、空白
で区切られます。（前後の空白は無視されます。）それぞれのファイル名は同
じ方法で変換され、1個のスペースで連結された結果となります。

`$(dir NAMES...)'
     NAMESのファイル名からディレクトリ部を抜き出します。ファイル名のディ
     レクトリ部はそのなかの最後のスラッシュよりまえのすべてです。スラッ
     シュを含まない場合は、ディレクトリ部は文字列`./'となります。

          $(dir src/foo.c hacks)

     の結果は、`src/ ./'となります。

`$(notdir NAMES...)'
     NAMESのファイル名からディレクトリ部でない部分を抜き出します。スラッ
     シュを含まない場合は、そのまま変更されません。または、最後のスラッ
     シュは破棄されます。

     スラッシュで終わるファイル名は空の文字列となります。結果がつねに、
     引数として持つ空白で区切られたファイル名と同じ数を持つわけではな
     いため、好ましくない結果を招きます。しかし、有効な選択肢はほかに
     見あたりません。

     たとえば、

          $(notdir src/foo.c hacks)

     の場合は、`foo.c hacks'という結果になります。

`$(suffix NAMES...)'
     NAMESにおけるファイル名のサフィックスを抜き出します。ピリオドを含
     む場合は、最後のピリオドからサフィックスが始まります。サフィック
     スが空の文字列の場合もあります。NAMESがない場合には結果は空となり、
     NAMESが複数のファイル名を含んでいる場合は、より少ないファイル名を
     含んだ結果になることを示しています。

     たとえば、

          $(suffix src/foo.c src-1.0/bar.c hacks)

     の場合は、`.c .c'という結果になります。

`$(basename NAMES...)'
     NAMESにおけるファイル名のサフィックスではない部分を抜き出します。
     ピリオドを含む場合は、最後のピリオドから前がベース名になります。
     ディレクトリ部のピリオドは無視されます。ピリオドがない場合には、
     ベース名はファイル名そのものになります。たとえば、

          $(basename src/foo.c src-1.0/bar hacks)

     の場合は、`src/foo src-1.0/bar hacks'となります。

`$(addsuffix SUFFIX,NAMES...)'
     引数のNAMESは一連の名前とみなされ、空白で区切られます。SUFFIXはユ
     ニットとして使用されます。SUFFIXの値は個々のファイル名の終わりに
     追加され、結果的に大きな名前になるものは1個のスペースをあいだに入
     れて連結されます。たとえば、

          $(addsuffix .c,foo bar)

     の場合は、`foo.c bar.c'となります。

`$(addprefix PREFIX,NAMES...)'
     引数のNAMESは一連の名前とみなされ、空白で区切られます。PREFIXはユ
     ニットとして使用されます。PREFIXの値は個々のファイル名の始めに追
     加され、結果的に大きな名前になるものは1個のスペースをあいだに入れ
     て連結されます。たとえば、

          $(addprefix src/,foo bar)

     の場合は、`src/foo src/bar'となります。

`$(join LIST1,LIST2)'
     2つの引数を1語ずつ連結します。2つの語（それぞれの引数から1語ずつ）
     を連結して1番目の結果とします。2番目についても同じように連結して
     これを繰り返します。結果的にN番目の語はそれぞれの引数のN番目を連
     結したものになります。片方の引数がもう一方より多くの語を持つ場合
     には、結果が変わらないように特別な語がコピーされます。

     例としては、`$(join a b,.c .o)'は`a.c b.o'を導きます。

     リストのなかの語のあいだのスペースは保存されず、1個のスペースに置
     き換えられます。

     このファンクションは、`dir'と`notdir'ファンクションの結果をマージ
     し、この2つのファンクションに与えられたファイルのリストを独自に作
     り出します。

`$(word N,TEXT)'
     TEXTのN番目の語を返します。このときのNは1から始まります。NがTEXT
     の語の数よりも多い場合には値は空になります。たとえば、

          $(word 2, foo bar baz)

     は、`bar'を返します。

`$(wordlist S,E,TEXT)'
     TEXTのなかのSで始まりEで終わる語のリストを返します。SとEの値は同
     じく1から始まります。EがTEXTの語の数よりも多い場合にはTEXTの終わ
     りまでの語を返し、SがEよりも多い場合には何も返しません。たとえば、

          $(wordlist 2, 3, foo bar baz)

     は、`bar baz'を返します。

`$(words TEXT)'
     TEXTのなかの語数を返します。したがって、TEXTの最後の語は
     `$(word $(words TEXT),TEXT)'となります。

`$(firstword NAMES...)'
     引数NAMESは空白で区切られた一連の名前とみなされます。値はその一連
     のなかの最初の名前となります。残りの名前は無視されます。

     たとえば、

          $(firstword foo bar)

     は、`foo'という結果を導きます。`$(firstword TEXT)'は`$(word
     1,TEXT)'と同じですが、`firstword'ファンクションはその簡便さを保ち
     ます。

`$(wildcard PATTERN)'
     引数PATTERNはファイル名のパターンで、一般にワイルドカード文字（シェ
     ルにおけるファイル名のパターンのように）を含みます。`wildcard'の
     結果はパターンにマッチした実在するファイル名のリストでそれはスペー
     スで区切られています。*Note ファイル名におけるワイルドカードの使
     用: Wildcards.。



File: make-jp.info, Node: Foreach Function, Next: If Function, Prev: File Name Functions, Up: Functions

`foreach'ファンクション
=======================

`foreach'ファンクションは、ほかのファンクションとは大きく異なります。
テキストのまとまりを繰り返し使用できるようにし、それぞれ異なる代用とと
もに使用されます。これはシェル`sh'における`for'コマンドやCシェル：
`csh'における`foreach'コマンドに似ています。

`foreach'ファンクションのシンタックスは以下のようになります。

     $(foreach VAR,LIST,TEXT)

VARとLISTの2つの引数はほかに先駆けて最初に展開されます。最後の引数に注
目してください。TEXTは同時に展開されません。LISTの展開された値のそれぞ
れの語に対して、VARの展開された値による変数名が語にセットされ、その後
TEXTが展開されます。おそらくTEXTは変数への参照を含むため、その展開結果
は毎回異なります。

結果として、LISTの空白で区切られた語の数と同じ回数TEXTは展開されます。
TEXTの複数展開はスペースで連結され、`foreach' ファンクションの結果とな
ります。

ここでの簡単な例では、リスト`dirs'のなかのディレクトリのすべてのファイ
ルのリストに対して変数`files'をセットします。

     dirs := a b c d
     files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))

ここで、TEXTは`$(wildcard $(dir)/*)'です。最初の繰り返しが`dir'に対す
る変数`a'でみつかります。したがって、`$(wildcard a/*)'という同じ結果を
導きます。2番目の繰り返しは`$(wildcard b/*)'を導き、3番目は`$(wildcard
c/*)'を導きます。

この例では以下の例と同じ結果（`dirs'へのセットを除けば）になります。

     files := $(wildcard a/* b/* c/* d/*)

TEXTが複雑な場合、付加的な変数を用いてそれに名前を与えて読みやすさを改
善することができます。

     find_files = $(wildcard $(dir)/*)
     dirs := a b c d
     files := $(foreach dir,$(dirs),$(find_files))

ここではその方法を用い、変数`find_files'を使用します。再帰的展開を行な
う変数を`='を使用して定義します。そしてその値は、`foreach'のコントロー
ルのもとで再度展開されるように実際のファンクションコールの値を持ちます。
`find_files'の定義の際に1度だけ`wildcard'が呼び出されるため、単純展開
される変数は定義できません。

`foreach'ファンクションは変数VARに対して永続的な効果を持ちません。
`foreach'ファンクションの呼び出し以降の変数の値とフレーバーは以前のも
のと同じです。LISTから得られたほかの値は`foreach'の実行のあいだの一時
的な効果しか持ちません。変数VARは`foreach'の実行のあいだは単純展開を行
なう変数です。もし`foreach'ファンクションの呼び出し以前にVARが定義され
ていない場合には、その呼出し語も定義されないままです。*Note 変数の2つ
のフレーバー: Flavors.。

変数名を、結果的に生じる複雑な変数表現を使用する際には注意しなければな
りません。理由は、多くの予期しないものが有効な変数名であるもののそれが
意図したものではないことがあるからです。たとえば、

     files := $(foreach Esta escrito en espanol!,b c ch,$(find_files))

`find_files'の値が、名前が`Esta escrito en espanol!'である変数を参照す
る場合は有益ですが、誤りのように見えます。



File: make-jp.info, Node: If Function, Next: Call Function, Prev: Foreach Function, Up: Functions

`if'ファンクション
==================

`if'ファンクションは文脈のなかで条件文の展開を補助する機能を提供します
（GNUの`make'のmakefileで`ifreq' （*Note 条件文のシンタックス:
Conditional Syntax..）のようなの条件文に対比されるもの）。

`if'ファンクションコールは2つあるいは3つの引数をとります。

     $(if CONDITION,THEN-PART[,ELSE-PART])

最初の引数であるCONDITIONは前後の空白を取り除かれ展開されます。空でな
い文字列に展開された場合、その条件は真とみなされます。反対に空の文字列
に展開された場合は偽とみなされます。

条件が真であるとき、2番目の引数THEN-PARTが評価されます。そして`if'ファ
ンクションの全体の評価の結果としてこれが使用されます。

条件が偽であるとき、3番目の引数ELSE-PARTが評価されます。そして`if'ファ
ンクションの結果としてこれが使用されます。3番目の引数がない場合には
`if'ファンクションは評価されません（空の文字列と評価）。

注意すべきことは、THEN-PARTあるいはELSE-PARTの一方だけが評価されること
で、両方評価されることはないということです。したがって、どちらの場合も
副次的な作用（`shell'ファンクションコールのような）を持つかもしれませ
ん。



File: make-jp.info, Node: Call Function, Next: Origin Function, Prev: If Function, Up: Functions

`call'ファンクション
====================

`call'ファンクションは新しいパラメータファンクションを作成する点でユニー
クです。変数の値に応じて複雑な表現を記述でき、`call'を使用して異なる値
でそれを展開することができます。

`call'ファンクションのシンタックスは以下のようになります。

     $(call VARIABLE,PARAM,PARAM,...)

`make'がこのファンクションを展開する際、個々のPARAMを一時的な変数
`$(1)'や`$(2)'などに割り当てます。変数`$(0)'にはVARIABLEが入ります。パ
ラメータの引数の数の最大値には制限がありません。最小値にも制限がありま
せんが、パラメータなしで`call'を使用するのは無意味です。

また、VARIABLEはそれらの一時的な割り当ての文脈のなかで`make'の変数とし
て展開されます。したがって、VARIABLEの値における`$(1)'に対するすべての
参照は`call'の呼び出しのなかの1番目のPARAMに決められます。

注意しなければならないのは、VARIABLEは変数の*名前*であって、その変数へ
の*参照*ではないことです。したがって、通常は記述する際に`$'や括弧を使
わないのです。（しかし、名前が定数でないことを望む場合は名前において変
数の参照を使用します。）

VARIABLEが組み込みファンクションの名前である場合にはその組み込みファン
クションがつねに呼び出されます（`make'の変数としてすでに存在したとして
も）。

`call'ファンクションはPARAM引数を一時的な変数に割り当てるまえに展開し
ます。このことはVARIABLEの値が特別な展開のルールを持つ`foreach'や`if'
のような組み込みファンクションへの参照を含んでいることを意味します。そ
してそれは期待どおりには働かないかもしれません。

いくつかの例がこのことを明らかにしてくれます。

このマクロは引数を単純に反対にします。

     reverse = $(2) $(1)

     foo = $(call reverse,a,b)

ここで、FOOは`b a'を含みます。

次の例はもう少し意味深いものです。`PATH'においてプログラムの最初のイン
スタンスをサーチするマクロを定義しています。

     pathsearch = $(firstword $(wildcard $(addsufix /$(1),$(subst :, ,$(PATH)))))

     LS := $(call pathsearch,ls)

変数`LS'は`/bin/ls'、あるいは似たものを含みます。

`call'ファンクションはネストが可能です。それぞれの再帰的な呼び出しは
`$(1)'に対する自身のローカルな値を得て、より上位の`call'の値をマスクし
ます。例としては、"map"ファンクションのインプリメンテーションがそれに
相当します。

     map = $(foreach a,$(2),$(call $(1),$(a)))

ここで、`origin'のような1つだけ引数をとるファンクションを1ステップで複
数の値にMAPできます。

     o = $(call map,origin,o map MAKE)

そして、`file file default'のような何かを含むOで終わることができます。

最終的な警告：`call'の引数に空白を加える際は注意してください。ほかのファ
ンクションと一緒に使用する場合、2番目と補助的な引数のなかのスペースは
保持されます。このことが奇妙な結果を招きます。一般的に、`call'にパラメー
タを提供する際にはすべての空白を取り除くことがもっとも安全な方法です。




File: make-jp.info, Node: Origin Function, Next: Shell Function, Prev: Call Function, Up: Functions

`origin'ファンクション
======================

`origin'ファンクションは変数の値に基づいて動作しないほかの大部分のファ
ンクションとは異なり、変数*について*の情報を示します。とくにその変数が
どこから由来するものかについて示します。

`origin'ファンクションのシンタックスは以下のようなものです。

     $(origin VARIABLE)

注意すべきことは、VARIABLEは問い合わせを行なう変数の*名前*であることで、
その変数への*参照*ではないことです。したがって、記述する際に通常は`$'
や括弧は使用しません。（しかし、名前が定数でないことを望む場合は名前に
おいて変数の参照を使用します。）

このファンクションの結果はVARIABLEがどのように定義されたかを示す文字列
です。

`undefined'

     VARIABLEが定義されていない場合。

`default'

     `CC'などで一般的なように、VARIABLEがデフォルトの定義を持つ場合。
     *Note 暗黙のルールで使用される変数: Implicit Variables.。そのデフォ
     ルトの値を再定義する場合には`origin'ファンクションはあとの定義の
     始まりを返すことに注意してください。

`environment'

     VARIABLEが環境変数として定義されている場合で、`-e'オプションが有
     効になって*いない*場合（*Note オプションのサマリー: Options
     Summary..）。

`environment override'

     VARIABLEが環境変数として定義されている場合で、`-e'オプションが有
     効になって*いる*場合（*Note オプションのサマリー: Options
     Summary..）。

`file'

     VARIABLEがmakefileのなかで定義されている場合。

`command line'

     VARIABLEがコマンド行で定義されている場合。

`override'

     VARIABLEがmakefileの`override'ディレクティブで定義されている場合
     （*Note `override'ディレクティブ: Override Directive..）。

`automatic'

     VARIABLEが個々のルールに対するコマンドの実行に対して定義された自
     動変数の場合（*Note 自動変数: Automatic..）。

この情報は変数の値を信用するかどうかを決める際にもっとも有益なものです
（好奇心のためではないとして）。たとえば、makefile `bar'を含む
makefile `foo'があると考えてください。コマンド`make -f bar'を
実行する場合には、たとえ環境変数に`bletch'の定義があるとしても、
変数`bletch'が`bar'で定義されていることを期待します。
しかしながら、`bar'をインクルードするまえに`foo'が`bletch'を
定義する場合、その定義をオーバーライドすることは望まないはずです。
これは`foo'のなかの`override'ディレクティブを使用することで
解決できます。これは、`bar'のなかのあとで定義されたものよりも
優位な定義を与えることです。しかし、`override'ディレクティブは
コマンド行での定義をオーバーライドしてしまうため、結果的に`bar'が
インクルードしてしまいます。

     ifdef bletch
     ifeq "$(origin bletch)" "environment"
     bletch = barf, gag, etc.
     endif
     endif

`bletch'が環境変数から定義される場合、再定義されます。

`-e'オプションが使用されていて、環境変数からきている`bletch'の以前の定
義をオーバーライドしたい場合には、以下のように記述します。

     ifneq "$(findstring environment,$(origin bletch))" ""
     bletch = barf, gag, etc.
     endif

`$(origin bletch)'が`environment'あるいは`environment override' を返す
場合に再定義が行なわれます。*Note 文字列の代用と分析のファンクション:
Text Functions.。



File: make-jp.info, Node: Shell Function, Next: Make Control Functions, Prev: Origin Function, Up: Functions

`shell'ファンクション
=====================

`shell'ファンクションは、`make'の外部との伝達をする点で`wildcard'ファ
ンクション（*Note ワイルドカードの機能: Wildcard Function..）を除いて
ほかのファンクションと似ていません。

`shell'ファンクションは多くのシェルでのバッククォート``'の動作と同様の
働き、すなわち"コマンドの展開"をします。これは、それがシェルコマンドで
ありコマンドの出力を返す引数をとることを意味しています。結果に対して
`make'が行なう唯一の処理は、周囲のテキストに代入するまえに、改行あるい
はキャリッジリターン／改行を1個のスペースに置換することです。また、最
後あるいは後続の改行（またはキャリッジリターン／改行）もまた取り除かれ
ます。

呼び出しによって`shell'ファンクションで実行されるコマンドはファンクショ
ンコールが展開されるときに実行されます。ほとんどのケースでは、makefile
が読み込まれるタイミングです。例外は、ルールのコマンドのなかのファンク
ションコールはコマンドが実行されるときであるということで、ほかの場合と
同じように`shell'ファンクションに適用されます。

ここに`shell'ファンクションの仕様のいくつかの例をあげます。

     contents := $(shell cat foo)

は、`contents'をファイル`foo'のコンテンツにセットします。このとき改行
ではなくスペースで各行を分離します。

     files := $(shell echo *.c)

は、`files'を`*.c'の展開にセットします。`make'がおかしな
シェルを使用しない限り、`$(wildcard *.c)'と同じ結果をもたらします。



File: make-jp.info, Node: Make Control Functions, Prev: Shell Function, Up: Functions

Makeをコントロールするファンクション
====================================

これらのファンクションはmakeの動作をコントロールします。一般的に、ある
種の環境によるエラーが検出された場合、それらはmakefileのユーザーに情報
を提供し、makeを停止させます。

`$(error TEXT...)'
     メッセージがTEXTである場所で致命的なエラーを生成します。注意しな
     ければならないのは、このファンクションが評価された場合はつねにエ
     ラーが生成されるということです。したがって、コマンドスクリプトの
     内部や再帰的変数割り当ての右側に置いた場合、評価されないままにな
     るでしょう。TEXTはエラーが生成されるまえに展開されます。

     たとえば

          ifdef ERROR1
          $(error error is $(ERROR1))
          endif

     は、`make'変数が`ERROR1'であると検出された場合に、makefileの読み
     込み時に致命的なエラーを生成します。

          ERR = $(error found an error!)

          .PHONY: err
          err: ; $(ERR)

     は、`err'ターゲットが呼び出された場合、`make'の実行中に致命的なエ
     ラーを生成します。

`$(warning TEXT...)'
     このファンクションは`error'ファンクションと似た動作をしますが、
     `make'は終了しません。かわりに、TEXTが展開され、結果のメッセージ
     が表示されます。しかしmakefileの処理は継続します。

     このファンクションの展開の結果は空の文字列となります。



File: make-jp.info, Node: Running, Next: Implicit Rules, Prev: Functions, Up: Top

`make'をどのように実行するか
****************************

プログラムを再コンパイルする方法を示すmakefileは複数の方法で用いられま
す。もっとも簡単なものは期限切れのすべてのファイルを再コンパイルするも
のです。通常は、引数なしで`make'を実行できるようにmakefileは記述されま
す。

しかし、ファイルのいくつかだけをアップデートしたい、異なったコンパイラ
を使用したい、異なるコンパイラオプションを用いたい、ファイルを変更せず
に期限切れのファイルをみつけたいといった要求があります。

`make'の実行時に引数を与えることで、多くのことが可能になります。

`make'の終了ステータスはつねに3つの値のうちのどれか1つです。
`0'
     `make'が成功したときの終了ステータスは0です。
`2'
     なんらかのエラーが起きたときの終了ステータスは2で、エラーについて
     のメッセージが表示されます。
`1'
     `-q'フラグを使用して`make'がターゲットの更新ができなかった場合の
     終了ステータスは1です。*Note コマンド実行の代替: Instead of
     Execution.。

* Menu:

* Makefile Arguments::          How to specify which makefile to use.
* Goals::                       How to use goal arguments to specify which
                                  parts of the makefile to use.
* Instead of Execution::        How to use mode flags to specify what
                                  kind of thing to do with the commands
                                  in the makefile other than simply
                                  execute them.
* Avoiding Compilation::        How to avoid recompiling certain files.
* Overriding::                  How to override a variable to specify
                                  an alternate compiler and other things.
* Testing::                     How to proceed past some errors, to
                                  test compilation.
* Options Summary::             Summary of Options



File: make-jp.info, Node: Makefile Arguments, Next: Goals, Up: Running

Makefile指定の引数
==================

makefileの名前を指定するには`-f'あるいは`--file'オプションを使用します。
（`--makefile'も同じです）たとえば、`-f altmake'はファイル`altmake'を
makefileとして指定します。

`-f'フラグを数回用い、引数にそれぞれ`-f'を使用する場合は、すべての指定
されたファイルはmakefileとして使用されます。

`-f'あるいは`--file'フラグを使用しない場合、デフォルトの設定では、
`GNUmakefile'、`makefile'そして`Makefile'がこの順序で試され、存在する
最初のものが使用されます（*Note Makefileの記述: Makefiles..）。



File: make-jp.info, Node: Goals, Next: Instead of Execution, Prev: Makefile Arguments, Up: Running

ゴールを指定する引数
====================

"ゴール"とは、`make'がアップデートするために最終的に努力すべきターゲッ
トです。ほかのターゲットはゴールの必要条件やゴールの必要条件の必要条件
などとなって現われる場合にアップデートされます。

デフォルトでは、ゴールはmakefileの1番目のターゲットです（ピリオドで始
まるターゲットはカウントしないとして）。したがって、makefileは通常、1
番目のターゲットがプログラムあるいは記述されたプログラム全体のコンパイ
ルのためであるように記述されます。makefileの最初のルールがいくつかのター
ゲットを持つ場合、そのルールの最初のターゲットがゴールとなり、そのすべ
てがゴールになるのではありません。

`make'の引数で異なるゴール（あるいは複数のゴール）を指定することができ
ます。その場合は引数としてゴールの名前を使用します。いくつかのゴールを
指定した場合、`make'は次々にそれらを処理しますが、順序は名前をつけた順
序です。

makefileのなかのどのターゲットもゴールとして指定できます（`-'で始まっ
たり、`='を含まず、それらがスイッチあるいは変数定義として解釈される限
り）。`make'がどのようにmakeするのかの明確なルールさえみつけることがで
きれば、makefileにないターゲットでさえ指定することができます。

`make'はコマンド行で指定したゴールのリストに対して特別な変数
`MAKECMDGOALS'をセットします。コマンド行でゴールを何も与えない場合はこ
の変数は空になります。注意しなければならないのは、この変数は特別な場合
にだけ用いられるということです。

適切な使用例は、`clean'ルール（*Note 必要条件の自動生成: Automatic
Prerequisites..）において`.d'ファイルのインクルードを回避する場合です。
その結果、`make'はそれらを作成せず、たんにふたたび削除するだけです。

     sources = foo.c bar.c

     ifneq ($(MAKECMDGOALS),clean)
     include $(sources:.c=.d)
     endif

ゴールの指定の一例は、プログラムのごく一部をコンパイルしたい、あるいは
いくつかのプログラムうちの1つだけコンパイルしたいという場合です。再構
成したいそれぞれのファイルをゴールとして指定します。たとえば、いくつか
のプログラムを含むディレクトリを考えた場合、makefileを以下のように開始
します。

     .PHONY: all
     all: size nm ld ar as

プログラム`size'で作業している場合、`make size'と指示して
そのプログラムだけを再コンパイルするようにしたいはずです。

ゴールの指定のもう1つの方法は、通常は作成されないファイルを作ることで
す。たとえば、デバッグの出力ファイル、あるいはテストのために特別にコン
パイルされたプログラムのバージョンがあるとすると、それらはmakefileのな
かにルールを持ちますがデフォルトゴールの必要条件ではないはずです。

さらにゴールの指定のもう1つの方法は、偽のターゲット
（*Note 偽のターゲット: Phony Targets..）あるいは空のターゲット
（*Note レコードイベントに対する空のターゲットファイル: Empty Targets..）を
持つコマンドを実行することです。makefileの多くは`clean'という名前の
偽のターゲットを持ち、ソースファイル以外のすべてを削除します。もちろん、
これは`make clean'という明確なリクエストをした場合にだけ
実行されます。以下の例は、一般的な偽あるいは空のターゲットの名前の
リストです。GNUソフトウェアパッケージで用いられる、
標準的なターゲットのすべてのリストについては
*Note ユーザーにとっての標準ターゲット: Standard Targets.。

`all'
     makefileの認識するトップレベルのターゲットのすべての作成。

`clean'
     `make'の実行によって通常作成されるすべてのファイルの削除。

`mostlyclean'
     `clean'に似ていますが、再コンパイルを望まないわずかなファイルの削
     除をやめます。たとえば、GCCに対する`mostlyclean'ターゲットは
     `libgcc.a'を削除しません。なぜならば、その再コンパイルはめったに
     必要がなく、時間がかかるからです。

`distclean'
`realclean'
`clobber'
     これらのターゲットは、`clean'よりも*もっと*多くのファイルの削除を
     行なうように定義されます。たとえば、makefile自身が作成できないと
     きでさえ、コンパイルのための準備として通常作成されたファイルへの
     リンクやコンフィギュレーションファイルを削除してしまいます。

`install'
     ユーザーが一般的にコマンドをサーチするディレクトリに実行ファイル
     をコピーします。また実行ファイルが使用する補助的なファイルもその
     ディレクトリにコピーします。

`print'
     変更のあったソースファイルのリストの出力。

`tar'
     ソースファイルのtarファイルの作成。

`shar'
     ソースファイルのシェルアーカイブ（shar file）の作成。

`dist'
     ソースファイルの配布用ファイルの作成。これはtarファイル、sharファ
     イルあるいはその圧縮形式であるかもしれませんし、それ以外である場
     合もあります。

`TAGS'
     プログラムに対するタグテーブルのアップデート。

`check'
`test'
     プログラムのmakefileの自己テスト。



File: make-jp.info, Node: Instead of Execution, Next: Avoiding Compilation, Prev: Goals, Up: Running

コマンド実行の代替
==================

makefileは`make'に対してターゲットが最新かどうかをどのように知り、どの
ように個々のターゲットをアップデートするかを知らせます。しかし、ターゲッ
トのアップデートはつねに希望どおりというわけではありません。オプション
によっては、`make'のほかの動作を指定します。

`-n'
`--just-print'
`--dry-run'
`--recon'

     "No-op"。その動作は、ターゲットをアップデートするためにどのコマン
     ドが用いられるかを出力しますが、実際にそれらを実行はしません。

`-t'
`--touch'

     "Touch"。その動作は、実際の変更は行なわずに最新のターゲットをマー
     クします。いいかえれば、`make'は中身を変えずにコンパイルだけを試
     みようとします。

`-q'
`--question'

     "Question"。その動作は、ターゲットがすでに最新であるかどうかを静
     かに見きわめます。しかし、どんな場合でもコマンドの実行は行ないま
     せん。いいかえれば、コンパイルも出力も何もしません。

`-W FILE'
`--what-if=FILE'
`--assume-new=FILE'
`--new-file=FILE'

     "What if"。`-W'フラグのあとにはファイル名が続きます。そのファイル
     の修正時刻は実際にはその修正時刻が残されますが、`make'によって現
     在として記録されます。特定のファイルを修正した場合に何が起きるの
     かを理解するために、`-n'フラグと組み合わせて`-W'フラグを使用する
     ことができます。

`-n'フラグがついた場合、実行しようとするコマンドを出力はするものの実際
に実行はしません。

`-t'フラグがついた場合、`make'はルールのなかのコマンドを無視します。そ
して再構成の必要な個々のターゲットに対して`touch'コマンドを使用します。
また、`-s'あるいは`.SILENT'が使用されない限り、`touch'コマンドもまた出
力されます。スピードの問題から、`make'は実際には`touch'プログラムを呼
び出さず、直接それを実行します。

`-q'フラグがついた場合、`make'は何も出力せず、コマンドも実行しません。
しかし、ターゲットがすでに最新であるとみなされる場合にだけ、返す終了ス
テータスを0にします。終了ステータスが1の場合、更新される必要があります。
`make'がエラーに遭遇する場合、終了ステータスは2となり、ターゲットが最
新でないためのエラーであると区別がつきます。

これらの3つのフラグの2つ以上を同じ`make'の呼び出しで用いるとエラーとな
ります。

`-n'、`-t'と`-q'オプションは`+'文字で始まる場合や`$(MAKE)'あるいは
`${MAKE}'文字列を含む場合のコマンド行には影響を与えません。注意しなけ
ればならないのは、`+'文字や文字列`$(MAKE)'あるいは`${MAKE}'を含む行だ
けはそれらのオプションを問わず実行されることです。同じルールのほかの行
は`+'で始まる場合も`$(MAKE)'あるいは`${MAKE}'を含んでいない限り実行さ
れません（*Note `MAKE'変数の働き: MAKE Variable..）。

`-W'フラグは2つの機能を提供します。

   * `-n'あるいは`-q'フラグを使用する場合、いくつかのファイルを修正す
     ることになっている場合、`make'が何を行なおうとするかがわかります。

   * `-n'あるいは`-q'フラグを使用しない場合、`make'が実際にコマンドを
     実行しようとする際に、実際にはファイルを変更することなしに、あた
     かも変更されたかのように`-W'フラグによって`make'が動作します。

オプション`-p'と`-v'によって、`make'や使用するmakefileについてのほかの
情報を得ることができます（*Note オプションのサマリー: Options
Summary..）。



File: make-jp.info, Node: Avoiding Compilation, Next: Overriding, Prev: Instead of Execution, Up: Running

いくつかのファイルの再コンパイルの回避
======================================

ときには、ソースファイルを変更したものの、それに依存したすべてのファイ
ルをコンパイルしたくない場合があります。たとえば、マクロや宣言文を多く
のほかのファイルが依存するあるヘッダファイルに追加した場合を考えます。
保守的に考えると、変更のあったヘッダファイルは依存するすべてのファイル
の再コンパイルを必要とすると`make'が仮定します。しかし、それらの再コン
パイルの必要がないことがわかっていて、コンパイルの時間をむだにしたくな
い場合もあります。

ヘッダファイルの変更前に問題がわかっている場合は、`-t'フラグを使用しま
す。このフラグは、`make'に対して、ルールのなかのコマンドを実行しないよ
うにさせて、最終更新時刻を変更することによってターゲットを最新にさせま
す。

  1. 再コンパイルが本当に必要なソースファイルの再コンパイルには`make' 
     コマンドを使用します。

  2. ヘッダファイルの変更をします。

  3. すべてのオブジェクトファイルを最新にするには、`make -t'コマンドを
     使用してください。次回`make'を実行する際にヘッダファイルの変更に
     よって再コンパイルが行なわれることはありません。

いくつかのファイルの再コンパイルが必要なときに、すでにヘッダファイルの変更を
していた場合には再コンパイルを行なうのでは遅すぎます。かわりに、
`-o FILE'フラグを使用して、特定のファイルを"old"
（*Note オプションのサマリー: Options Summary..）に設定できます。これで、
ファイル自身の再構成は行なわれず、ほかにも何も再構成されません。この手続きは
以下のようになります。

  1. 特定のヘッダファイルから独立しているためにコンパイルの必要なソー
     スファイルを`make -o HEADERFILE'をつけて再コンパイルします。いく
     つかのヘッダファイルが関係する場合には、それぞれのヘッダファイル
     に対して`-o'オプションを使用します。

  2. `make -t'を使用してすべてのオブジェクトファイルをtouchします。



File: make-jp.info, Node: Overriding, Next: Testing, Prev: Avoiding Compilation, Up: Running

変数のオーバーライド
====================

`='を含む引数は変数の値を指定します。たとえば、`V=X'は変数Vの値をXにセッ
トします。この方法で値を指定する場合、makefileにおいて通常の割り当てを
同じ変数に行なったものは無視されます。これを引数による変数の"オーバー
ライド"といいます。

この機能を用いるもっとも一般的な方法は、特別なフラグをコンパイラに渡す
ことです。たとえば、適切に記述されたmakefileにおいて、変数`CFLAGS'はそ
れぞれのコマンドに含まれていて、それはCコンパイラを実行します。その結
果、`foo.c'は以下のようにコンパイルされます。

     cc -c $(CFLAGS) foo.c

したがって、`CFALGS'にどんな値をセットしてもコンパイルに影響を与えます。
makfileはおそらく、通常の値を以下のように`CFLAGS'に指定するでしょう。

     CFLAGS=-g

もし望むなら、`make'を実行するたびにこの値をオーバーライドすることも可
能です。たとえば、`make CFLAGS='-g -O''とした場合、それぞれのCコンパイ
ルは、`cc -c -g -O'として実行されます。（このことは、オーバーライドす
るときには、変数の値におけるスペースやほかの特別な文字を取り囲むことを
シェルでどのように引用するかを説明しています。）

変数`CFLAGS'は多くの標準的な変数のなかで、この方法で変更できる唯一のも
のです。完全なリストについては、*Note 暗黙のルールで使用される変数:
Implicit Variables.。

また、ユーザーに対して、変数の変更によってmakefileがどのように働くかを
コントロールする権限を与えて、追加した変数をmakefileが注目するようにプ
ログラムすることができます。

コマンドの引数で変数をオーバーライドする場合、再帰的展開を行なう変数も
単純展開を行なう変数も定義することができます。前記の例では再帰的展開を
行なう変数が示されています。単純展開を行なう変数を作るには`='のかわり
に`:='を記述します。しかし、指定した*値*に変数への参照やファンクション
コールをインクルードしようとしない限り、作成した変数の種類は違いは生じ
ません。

オーバーライドした変数をmakefileが変更する方法が1つあります。
`override' ディレクティブを使用する方法で、`override VARIABLE = VALUE' 
のような1行を記述します（*Note `override'ディレクティブ: Override
Directive..）。



File: make-jp.info, Node: Testing, Next: Options Summary, Prev: Overriding, Up: Running

プログラムのコンパイルテスト
============================

シェルコマンドの実行でエラーが発生した際、普通は、`make'はただちにゼロ
でないステータスを返して終了します。いかなるターゲットに対してもそれ以
降のコマンドは実行されません。エラーは、ゴールが正しく再構成されないこ
とを暗示し、`make'はそれをただちにレポートします。

変更したばかりのプログラムをコンパイルする際にはこれは望ましくないこと
です。そのかわりにできるだけ多くのコンパイルエラーを提示させるために
`make'がすべてのファイルのコンパイルを試してみることを望むでしょう。

このような場合は、`-k'あるいは`--keep-going'フラグを使用すべきでしょう。
そうすると、`make'は保留されたターゲットのほかの必要条件を考慮し続け、
ゼロでないステータスを返して終了するまえに必要ならば再構成を行ないます。
たとえば、あるオブジェクトファイルのコンパイルでエラーが起きたあと、
`make -k'はリンクが不可能であることをすでにわかっていても、ほかのオブ
ジェクトファイルのコンパイルを続けようとします。加えて、シェルコマンド
の失敗のあとでも、`make -k'はターゲットや必要条件のファイルの作成の仕
方を知らないことを発見したあとでも可能な限り継続しようとします。このこ
とによってエラーメッセージが出されますが、`-k'がない場合には致命的なエ
ラーとなってしまいます（*Note オプションのサマリー: Options Summary..）。

`make'は、通常、ユーザーの目的がゴールを最新にすることだと仮定していま
す。いったんそれが不可能であると`make'が認識するとただちに失敗のレポー
トを出します。`-k'フラグは、実際の目的を、プログラム中の変更箇所を可能
な限り多くテストし、次回のコンパイルのまえに修正可能ないくつかの独立し
た問題を発見することとします。これは、Emacsのコマンド`M-x compile'がデ
フォルトで`-k'フラグに渡す理由です。



File: make-jp.info, Node: Options Summary, Prev: Testing, Up: Running

オプションのサマリー
====================

`make'で使用できるオプションの表を示します。

`-b'
`-m'
     これらのオプションは、ほかのバージョンの`make'では互換性がありま
     せん。

`-C DIR'
`--directory=DIR'
     makefileを読み込むまえにDIRディレクトリに移動します。複数の`-C' 
     オプションが指定されている場合は、それぞれまえのものと関係付けて
     解釈されます。たとえば、`-C / C etc'は、`-C /etc'と同じです。これ
     は、`make'の再帰的呼び出しにおいて一般的に用いられます（*Note
     `make'の再帰的用法: Recursion..）。

`-d'

     正常な処理に加えて、デバッグ情報を出力します。デバッグ情報は、ど
     のファイルが再構成のために考慮されるか、どのファイル日付と結果と
     が比較されるか、実際に再構成の必要なのはどのファイルか、どの暗黙
     のルールが考慮され、どれが適用されるかなど`make'が行なうべきこと
     の決定に関するあらゆることです。`-d'オプションは`--debug=a'と同等
     です（下記参照）。

`--debug[=OPTIONS]'

     正常な処理に加えて、デバッグ情報を出力します。さまざまなレベルと
     タイプの出力が選択できます。引数がない場合はbasicレベルのデバッグ
     情報になります。とりうる値は以下のとおりで、最初の文字だけが考慮
     されます。また値はカンマまたはスペースで区切られます。

     `a (all)'
          すべてのタイプのデバッグ情報の出力が可能です。`-d'を使用する
          のと同じです。

     `b (basic)'
          ビルドの成功にかかわらず、期限切れである個々のターゲットにつ
          いて基本的なデバッグ情報を出力します。

     `v (verbose)'
          `basic'よりも上のレベルです。どのmakefileをパースするか、再
          度ビルドの不要な必要条件などについてです。このオプションは
          `basic'によるメッセージも有効にします。

     `i (implicit)'
          個々のターゲットに対する暗黙のルールのを示すメッセージの出力。
          このオプションは`basic'によるメッセージも有効にします。

     `j (jobs)'
          指定されたサブコマンドの呼び出しにおける詳細を与えるメッセー
          ジの出力。

     `m (makefile)'
          デフォルトでは上記のメッセージはmakefileの再構成を試すあいだ
          は有効ではありません。このオプションはmakefileの再構成のあい
          だは有効です。注意すべきことは、`all'オプションがこのオプショ
          ンを有効にすることです。また、このオプションは`basic'による
          メッセージも有効にします。

`-e'
`--environment-overrides'
     makefileから得られる変数よりも優位な環境変数からの変数を与えます。
     *Note 環境（変数）からの変数の取得: Environment.。

`-f FILE'
`--file=FILE'
`--makefile=FILE'
     FILEという名前のファイルをmakefileとして読み込みます。*Note
     Makefileの記述: Makefiles.。

`-h'
`--help'

     `make'で使用できるオプションを表示し、終了します。

`-i'
`--ignore-errors'
     ファイルの再構成を実行するコマンドのエラーを無視します。*Note コ
     マンドのエラー: Errors.。

`-I DIR'
`--include-dir=DIR'
     インクルードされたmakefileをサーチするためのDIRディレクトリを指定
     します。*Note ほかのMakefileをインクルードする: Include.。いくつ
     かのディレクトリを指定するために`-I'オプションが使用される場合は、
     そのディレクトリのサーチは指定された順序で行なわれます。

`-j [JOBS]'
`--jobs[=JOBS]'
     同時に実行するジョブの数を指定します。引数がない場合は、`make'は
     可能な限り多くのジョブを同時に実行します。2つ以上の`-j'オプション
     がある場合は最後の1つが有効です。ただし、MS-DOSにおいてはこのオプ
     ションは無視されます。このコマンドの動作についての詳細については、
     *Note パラレル実行: Parallel.。

`-k'
`--keep-going'
     エラーが起きたあとでも可能な限り継続します。ターゲットの作成に失
     敗し、依存するファイルの再構成に失敗しても、ターゲットの必要条件
     は処理されます。*Note プログラムのコンパイルテスト: Testing.。

`-l [LOAD]'
`--load-average[=LOAD]'
`--max-load[=LOAD]'
     ほかのジョブが実行されていて、ロードアベレージが最低LOAD（小数）
     よりも低くなければ新しいジョブ（のコマンド）をスタートさせないよ
     うに指定します。*Note パラレル実行: Parallel.。

`-n'
`--just-print'
`--dry-run'
`--recon'

     実行できるコマンドを出力しますが、実際には実行しません。*Note コ
     マンド実行の代替: Instead of Execution.。

`-o FILE'
`--old-file=FILE'
`--assume-old=FILE'
     たとえ必要条件が古い場合でさえもFILEを再構成しません。またFILE の
     変更による再構成も行ないません。本質的にそのファイルは非常に古い
     ものとして扱われ、そのルールは無視されます。*Note いくつかのファ
     イルの再コンパイルの回避: Avoiding Compilation.。

`-p'
`--print-data-base'
     makefileから取得したルールと変数の値のデータベースの出力をします。そして、
     通常あるいは指定されたとおりに実行します。また、`-v'スイッチ
     （下記参照）によってバージョン情報の出力も行ないます。ファイルの再構成を
     試すことなしにデータベースの出力をする場合は、`make -qp'を
     使用します。また、事前に定義されたルールと変数のデータベースを出力するには、
     `make -p -f /dev/null'を使用します。データベースの出力には
     ファイル名と、コマンドと変数定義に関する情報の行番号が含まれていて、
     複雑な環境においてはデバッグツールにとって有益です。

`-q'
`--question'
     クエスチョンモード。コマンドは何も実行せず、何も出力しません。指
     定したターゲットがすでに最新である場合にステータスの0を返し、なん
     らかの再構成が必要なときは1、エラーが起きたときは2を返すだけです。
     *Note コマンド実行の代替: Instead of Execution.。

`-r'
`--no-builtin-rules'
     組み込み済みの暗黙のルール（*Note 暗黙のルールの使用: Implicit
     Rules..）を使用させないようにします。パターンルール（*Note パター
     ンルールの定義と再定義: Pattern Rules..）の記述によって、独自に定
     義することができます。`-r'オプションはサフィックスルール（*Note 
     古いスタイルのサフィックスルール: Suffix Rules..）に関するデフォ
     ルトのサフィックスのリストをクリアします。しかし、`.SUFFIXES'で独
     自のサフィックスとサフィックスルールを定義することができます。注
     意すべきことは、`-r'で影響を受けるのは*ルール*だけであってデフォ
     ルトの変数は有効のまま残されます（*Note 暗黙のルールで使用される
     変数: Implicit Variables..）。次の`-R'オプションを参照してくださ
     い。

`-R'
`--no-builtin-variables'
     組み込み済みのルール固有の変数（*Note 暗黙のルールで使用される変
     数: Implicit Variables..）の使用をさせないようにします。無論独自
     の変数の定義は可能です。`-R'オプションは自動的に`-r'オプション
     （上述）も有効にします。なぜなら、変数に対して何も定義がなければ、
     暗黙のルールは何の意味も持たないからです。

`-s'
`--silent'
`--quiet'

     サイレントオペレーション。実行されるコマンドを出力しません。*Note 
     コマンドエコー: Echoing.。

`-S'
`--no-keep-going'
`--stop'

     `-k'オプションの効果をキャンセルします。`MAKEFLAGS'を通してトップ
     レベルの`make'から受け継いだ`-k'による再帰的な`make'の場合、ある
     いは環境変数において`MAKEFLAGS' （*Note `make'の再帰的用法:
     Recursion..）に`-k'をセットする場合を除いて、必要となる場合はあり
     ません。

`-t'
`--touch'

     コマンドを実行するかわりに、内容を変更することなしにファイルを最
     新にします。コマンドが実行されたように見せかけ、次の`make'の呼び
     出しを騙すのです。*Note コマンド実行の代替: Instead of Execution.。

`-v'
`--version'
     `make'プログラムのバージョンとコピーライト、作者、無保証である注
     意を表示します。

`-w'
`--print-directory'
     makefileの実行前後の作業用ディレクトリを含むメッセージを出力しま
     す。再帰的な`make'コマンドの複雑なネストにおけるエラーの追跡に役
     に立ちます。*Note `make'の再帰的用法: Recursion.。（実際には、こ
     のオプションを指定することはめったにないはずです。なぜなら`make'
     がこれを行なってくれるからです。*Note `--print-directory'オプショ
     ン: -w Option.を参照。）

`--no-print-directory'
     `-w'が指定された場合でも作業用ディレクトリの表示をさせないように
     します。`-w'が自動的にオンで、メッセージの表示が不要な場合にこの
     オプションは有益です。*Note `--print-directory'オプション: -w
     Option.。

`-W FILE'
`--what-if=FILE'
`--new-file=FILE'
`--assume-new=FILE'
     ターゲットFILEが直前に修正されたように見せかけます。`-n' フラグが
     用いられるとき、そのファイルを修正すると何が起きるのかを示してく
     れます。`-n'フラグがない場合は、`make'が実行されるまえに与えられ
     たファイルに`touch'コマンドが実行されたのと同様になります。ただし、
     修正時刻はあくまで`make'によって仮想的に変更されるものです。*Note 
     コマンド実行の代替: Instead of Execution.。

`--warn-undefined-variables'
     `make'が未定義の変数に対する参照を行なうときにつねに表示されるワー
     ニングを表示します。複雑な方法で変数を使用していてmakefileのデバッ
     グをする際に有用です。



File: make-jp.info, Node: Implicit Rules, Next: Archives, Prev: Running, Up: Top

暗黙のルールの使用
******************

ターゲットファイルの再構成の標準的なある方法がしばしば用いられます。た
とえば、オブジェクトファイルを作成する習慣的な方法は、`cc'で用いられる
Cコンパイラによるソースファイルから作成する方法です。

"暗黙のルール"は`make'に対して習慣的なテックニックの使用を伝えるため、
それを用いる際には詳細に指定をする必要がありません。たとえば、Cのコン
パイルには暗黙のルールがあり、ファイル名が暗黙のルールを実行するものを
決定します。また、Cのコンパイルでは一般的に`.c'ファイルを使って`.o' ファ
イルを作成します。したがって、`make'はCのコンパイルにおいてはファイル
名の最後を見るという暗黙のルールを適用しているのです。

暗黙のルールの連鎖は順序に適用されます。たとえば、`make'は`.y' ファイ
ルから`.c'ファイルを経て`.o'ファイルを再構成します。

組み込まれた暗黙のルールはコマンドのなかでいくつかの変数を使用します。
そのためその変数の値の変更によって暗黙のルールの動作を変更することがで
きます。

"パターンルール"の記述によって独自の暗黙のルールを定義することができます。

"サフィックスルール"は、暗黙のルールを定義する制限のある方法です。パター
ンルールは、より汎用的で明確ですが、サフィックスルールは互換性のために
残されています。

* Menu:

* Using Implicit::              How to use an existing implicit rule
                                  to get the commands for updating a file.
* Catalogue of Rules::          A list of built-in implicit rules.
* Implicit Variables::          How to change what predefined rules do.
* Chained Rules::               How to use a chain of implicit rules.
* Pattern Rules::               How to define new implicit rules.
* Last Resort::                 How to defining commands for rules
                                  which cannot find any.
* Suffix Rules::                The old-fashioned style of implicit rule.
* Implicit Rule Search::        The precise algorithm for applying
                                  implicit rules.



Info file: make-jp.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `make-jp.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.







INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Make: (make).            Remake files automatically.
END-INFO-DIR-ENTRY


This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

This is Edition 0.55, last updated 04 April 2000, of `The GNU Make
Manual', for `make', Version 3.79.

Copyright (C) 1988, '89, '90, '91, '92, '93, '94, '95, '96, '97, '98,
'99, 2000 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.




File: make-jp.info, Node: Using Implicit, Next: Catalogue of Rules, Up: Implicit Rules

暗黙のルールの使用
==================

ターゲットファイルのアップデートに関する習慣的な方法を`make'がみつける
ようにするには、ユーザー自身がコマンドを指定するのを控えることです。そ
れは、コマンド行を用いずにルールを記述したり、何もルールを記述しないこ
とです。そうすることによって、存在するソースファイルに基づいてどの暗黙
のルールを適用するかといった動作を`make'が行ないます。

たとえば、このようなmakefileがあるとします。

     foo : foo.o bar.o
             cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)

`foo.o'に言及してもそれにルールを与えていないため、`make'が自動的にアッ
プデートの仕方を伝える暗黙のルールを探します。これは実際に`foo.o'が存
在してもしなくても起こります。

暗黙のルールがみつかる場合、コマンドと1つあるいは複数の必要条件（ソー
スファイル）を提供できます。ヘッダファイルのような暗黙のルールが提供で
きない特定の必要条件が必要な場合は、コマンド行なしで`foo.o'に対するルー
ルを記述したいはずです。

個々の暗黙のルールはターゲットパターンと必要条件のパターンを持ちます。
また、同じターゲットパターンを持つ多くの暗黙のルールがあります。たとえ
ば、多くのルールは`.o'ファイルを作成しますが、1つはCコンパイラで`.c'か
ら作成され、別のものはPascalコンパイラによって`.p'から作成されたりしま
す。実際に適用されるルールは、必要条件が存在するかあるいは作成可能であ
るものとなります。したがって、ファイル`foo.c'がある場合、`make'はCコン
パイラを実行し、反対にファイル`.p'がある場合は、Pascalコンパイラを実行
するといったことになります。

もちろん、makefileを記述する際、`make'がどの暗黙のルールを使用するかを
知っていて、どの必要条件のファイルが存在するかを知っているため、どれが
適用されるかも知っています。あらかじめ定義されている暗黙のルールのすべ
てのカタログについては、*Note 暗黙のルールのカタログ: Catalogue of
Rules.。

上記の場合、必要条件が存在するか作成可能の場合に暗黙のルールが適用され
ると書きましたが、ここで作成可能とは、ターゲットあるいは必要条件として
明確にmakefileで言及されている場合と、どのように作成するかが再帰的に発
見される暗黙のルールがある場合のことです。暗黙の必要条件が別の暗黙のルー
ルの結果である場合、"連鎖"が起きていると表現します。*Note 暗黙のルール
の連鎖: Chained Rules.。

一般的に、`make'は個々のターゲットに対して暗黙のルールをサーチし、コマ
ンドを持たない個々のダブルコロンルールに対しても暗黙のルールをサーチし
ます。必要条件として言及されているファイルは何も指定しないルールを持つ
ターゲットとしてみなされ、暗黙のルールのサーチがそれに対して行なわれま
す。どのようにサーチが行われるかの詳細については、*Note 暗黙のルールの
サーチアルゴリズム: Implicit Rule Search.。

明示的な必要条件は暗黙のルールのサーチに対して影響を与えません。たとえ
ば、この明示的なルールの例です。

     foo.o: foo.p

`foo.p'の必要条件は必ずしも`make'がオブジェクトファイルを作成する暗黙
のルール、すなわち`.p'ファイルのPascalのソースファイルから`.o'ファイル
を作成するルールを必要としているわけではありません。たとえば、`foo.c'
もまた存在する場合、暗黙のルールはオブジェクトファイルをCのソースファ
イルから作成しようとします。その理由は、事前に定義されたリストのなかで
はPascalルールよりも先に現われるからです（*Note 暗黙のルールのカタログ:
Catalogue of Rules..）。

コマンドのないターゲットに対して暗黙のルールが使用されないように望む場
合、セミコロンを使用して空のコマンドをそのターゲットに与えます（*Note 
空のコマンドの使用: Empty Commands..）。



File: make-jp.info, Node: Catalogue of Rules, Next: Implicit Variables, Prev: Using Implicit, Up: Implicit Rules

暗黙のルールのカタログ
======================

ここに、事前に定義された暗黙のルールのカタログがあり、それらはmakefile
が明確にオーバーライドするか無効にされない限りつねに利用可能です。暗黙
のルールのキャンセル、もしくはオーバーライドについては、*Note 暗黙のルー
ルのキャンセル: Canceling Rules.。`-r'あるいは`--no-builtin-rules'オプ
ションはすべての事前に定義されたルールを無効にします。

`-r'オプションが与えられていない場合でさえ、これらのルールのすべてがつ
ねに定義されているわけではありません。定義された暗黙のルールの多くは
`make'にサフィックスルールとしてインプリメントされています。したがって、
"サフィックスのリスト"（特別なターゲットの`.SUFFIXES'）に依存していま
す。デフォルトのサフィックスのリストは、`.out'、`.a'、`.ln'、`.o'、
`.c'、`.cc'、`.C'、`.p'、`.f'、`.F'、`.r'、`.y'、`.l'、`.s'、`.S'、
`.mod'、`.sym'、`.def'、`.h'、`.info'、`.dvi'、`.tex'、`.texinfo'、
`.texi'、`.txinfo'、`.w'、`.ch'、`.web'、`.sh'、`.elc'、`.el' です。以
下で説明される暗黙のルールのすべては、その必要条件がサフィックスのどれ
か1つを持っています。サフィックスリストを修正する場合、事前に定義され
た有効なサフィックスルールだけが、指定したリストにある1つあるいは2つの
サフィックスによって名前をつけられたルールになります。リストにないサ
フィックスのルールは無効になります。すべてのサフィックスのルールの詳細
は、*Note 古いスタイルのサフィックスルール: Suffix Rules.。

Cプログラムのコンパイル
     `N.o'はコマンド`$(CC) -c $(CPPFLAGS) $(CFLAGS)'によって、`N.c'か
     ら自動的に作成されます。

C++プログラムのコンパイル
     `N.o'はコマンド`$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)'によって、
     `N.cc'または`N.C'から自動的に作成されます。C++ソースファイルに関
     しては、`.C'のかわりにサフィックス`.cc'を使用することをすすめます。

Pascalプログラムのコンパイル
     `N.o'はコマンド`$(PC) -c $(PFLAGS)'によって、`N.p' から自動的に作
     成されます。

FortranとRatforプログラムのコンパイル
     `N.o'はFortranコンパイラの実行によって、`N.r'、`N.F'あるいは`N.f'
     から自動的に作成されます。使用される正確なコマンドは以下のように
     なります。

     `.f'
          `$(FC) -c $(FFLAGS)'.
     `.F'
          `$(FC) -c $(FFLAGS) $(CPPFLAGS)'.
     `.r'
          `$(FC) -c $(FFLAGS) $(RFLAGS)'.

FortranとRatforプログラムのプリプロセッシング
     `N.f'は、`N.r'あるいは`N.F'から自動的に作成されます。このルールは、
     Ratforのコンバートを行なうプリプロセッサあるいはプリプロセッサを
     通すFortranプログラムを正しいFortranプログラムに変換するだけです。
     使用される正確なコマンドは以下のようになります。

     `.F'
          `$(FC) -F $(CPPFLAGS) $(FFLAGS)'.
     `.r'
          `$(FC) -F $(FFLAGS) $(RFLAGS)'.

Modula-2プログラムのコンパイル
     `N.sym'は、コマンド`$(M2C) $(M2FLAGS) $(DEFFLAGS)'によって
     `N.def'から作成されます。`N.o'は`N.mod'か
     ら作成されますが、そのコマンドの書式は、
     `$(M2C) $(M2FLAGS) $(MODFLAGS)'となります。

アセンブラプログラムのアセンブリとプリプロセッシング
     `N.o'は、`N.s'からアセンブラ`as'を実行することで自動的に作成され
     ます。正確なコマンドは`$(AS) $(ASFLAGS)'です。

     `N.s'は、`N.S'からCのプリプロセッサ`cpp'を
     実行することで自動的に作成されます。
     正確なコマンドは`$(CPP) $(CPPFLAGS)'です。

単一オブジェクトファイルのリンク
     `N'は、`N.o'からリンカ（通常は`ld'）の実行によって
     Cコンパイラを経由して自動的に作成されます。正確なコマンドは
     `$(CC) $(LDFLAGS) N.o $(LOADLIBES) $(LDLIBS)'です。

     このルールは、1つのソースファイルから簡単なプログラムのためにある
     ことをします。それは、複数のオブジェクトファイル（おそらくほかの
     いろいろなソースファイルからくる）がある場合、そのうちの1つは実行
     ファイル名とマッチするということです。したがって、

          x: y.o z.o

     `x.c'、`y.c'と`z.c'がすべて存在するときには、以下を実行します。

          cc -c x.c -o x.o
          cc -c y.c -o y.o
          cc -c z.c -o z.o
          cc x.o y.o z.o -o x
          rm -f x.o
          rm -f y.o
          rm -f z.o

     より複雑な場合、たとえば実行ファイル名から派生しているオブジェク
     トファイルが何もない場合は、リンクのための明確なコマンドを記述す
     る必要があります。

     自動的に`.o'オブジェクトファイルを作成される個々の種類のファイル
     はコンパイラによって`-c'オプションなしに自動的にリンクされます
     （`$(CC)'、`$(FC)'あるいは`$(PC)'。`$(CC)'は`.s' ファイルのアセン
     ブルに使用されます）。この場合、`.o' オブジェクトファイルが中間ファ
     イルとして使用されます。しかし、コンパイルとリンクを1ステップで行
     なうよりも速く実行できます。

CプログラムのためのYacc
     `N.c'は、`N.y'からYaccをコマンド`$(YACC) $(YFLAGS)' を実行するこ
     とで自動的に作成されます。

CプログラムのためのLex
     `N.c'は、`N.l'から、Lexを実行することで自動的に作成されます。実際
     のコマンドは、`$(LEX) $(LFLAGS)'です。

RatforプログラムのためのLex
     `N.r'は、`N.l'から、Lexを実行することで自動的に作成されます。実際
     のコマンドは、`$(LEX) $(LFLAGS)'です。

     CあるいはRatforのコードを作ることにかかわらず、Lexファイルに対し
     て同じサフィックス`.l'を使用する習慣は、ある場合においてどちらの
     言語を使うかどうかを`make'が決定するのを困難にします。`.l'ファイ
     ルからオブジェクトファイルを作る際に`make'が呼び出された場合、ど
     ちらのコンパイラを使用するか決めなければなりませんが、普通はより
     一般的なCコンパイラです。Ratforを使用する場合は、makefileのなかに
     `N.r'への言及を置き、`make'がそれを認識できるようにしなければなり
     ません。あるいは排他的にCを使用せずにRatforを使用する場合には、暗
     黙のルールのサフィックスのリストから`.c'を取り除いてください。

          .SUFFIXES:
          .SUFFIXES: .o .r .f .l ...

C、Yacc、またはLexプログラムから生成されるLintライブラリ
     `N.ln'は、`N.c'から`lint'を実行することで自動的に
     作成されます。正確なコマンドは`$(LINT) $(LINTFLAGS) $(CPPFLAGS) -i'
     です。同じコマンドがCのコードを作成される際に`N.y'あるいは
     `N.l'として使用されます。

TeXとWeb
     `N.dvi'は、`N.tex'からコマンド`$(TEX)'によって作成されます。また
     `N.tex'は、`N.web'から`$(WEAVE)' によって作成されます。あるいは
     `N.w'（存在しているか作成可能であれば）から`$(CWEAVE)'によって作
     成されます。また、`N.p'は、`N.web'から`$(TANGLE)'で、`N.c'は、
     `N.w'（存在しているか作成可能であれば`N.ch'から）から`$(CTANGLE)'
     で作成されます。

TexinfoとInfo
     `N.dvi'は、`N.texinfo'、`N.texi'あるいは
     `N.txinfo'からコマンド`$(TEXI2DVI) $(TEXI2DVI_FLAGS)'
     によって作成されます。また、`N.info'は、`N.texinfo'、
     `N.texi'あるいは`N.txinfo'からコマンド
     `$(MAKEINFO) $(MAKEINFO_FLAGS)'によって作成されます。

RCS
     どのようなファイル`N'も必要である場合には、`N,v'
     あるいは`RCS/N,v'のどちらかの名前のRCSファイルから展開されます。
     正確なコマンドは、`$(CO) $(COFLAGS)'です。ただし、RCSファイルが
     新しいものであっても、すでに存在している場合には`N'は
     展開されません。RCSに対するルールは最終的なもので
     （*Note 何にでもマッチするパターンルール: Match-Anything Rules..）、ほかの
     ソースからRCSファイルが生成されることはなく実際に存在していなければなりません。

SCCS
     どのようなファイル`N'も必要である場合には、`s.N'
     あるいは`SCCS/s.N'のどちらかの名前のSCCSファイルから展開されます。
     正確なコマンドは、`$(GET) $(GFLAGS)'です。SCCSに対するルールは
     最終的なもので
     （*Note 何にでもマッチするパターンルール: Match-Anything Rules..）、ほかの
     ソースからRCSファイルが生成されることはなく実際に存在していなければなりません。

     ファイル`N'は`N.sh'からコピーされて実行可能となります。これはシェ
     ルスクリプトによるSCCSのチェックです。RCSがファイルの実行パーミッ
     ションを保持するため、RCSでこの機能を使用する必要はありません。

     SCCSの使用は避けたほうがよいのです。RCSはより優れていて広く用いら
     れ、また、フリーです。競合する（あるいは下級の）市販のソフトウェ
     アのかわりにフリーソフトウェアを選択することによって、フリーソフ
     トウェアのムーブメントを支えることにつながります。

普通、前記の一覧のうち変数だけを変更したいと望むでしょう。以降の節で解
説します。

しかしながら、組み込み済みの暗黙のルールのコマンドは実際には、
`COMPILE.c'、`LINK.p'や`PREPROCESS.S'といった前記のリストのコマンドを
含んだ値を持つ変数を使用します。

`make'はソースファイル`.X'をコンパイルするルールが変数`COMPILE.X'を使
用するという習慣に従います。同じように、ファイル`.X'から実行ファイルを
作るルールは`LINK.X'を使用します。またファイル`.X'をプリプロセスするルー
ルは`PREPROCESS.X'を使用します。

オブジェクトファイルを作るすべてのルールは変数`OUTPUT_OPTION'を
使用します。`make'はコンパイルのタイミングに応じて、この変数に
`-o $@'を含むか空にしておくかを定義します。`VPATH'
（*Note 必要条件のためのディレクトリサーチ: Directory Search..）を
使用する際は、ソースファイルの場所と異なる場合に正しいファイルに出力が
されるように`-o'オプションを使用する必要があります。しかし、
コンパイラによってはオブジェクトファイルに対しての`-o'スイッチを
受け入れない場合があります。そのようなシステムの場合で`VPATH'を
使用する場合は、コンパイルが誤った場所に出力をする場合があります。
このような問題を解決するには、`OUTPUT_OPTION'に値
`; mv $*.o $@'を与えます。



File: make-jp.info, Node: Implicit Variables, Next: Chained Rules, Prev: Catalogue of Rules, Up: Implicit Rules

暗黙のルールで使用される変数
============================

組み込み済みの暗黙のルールにおけるコマンドはある事前に定義された変数の
自由度の高い使用ができます。`make'に対する引数や、ルールを再定義するこ
となしにどのように暗黙のルールが働くかを変更する環境においてmakefileの
なかで変数を変更することができます。その場合、`-R'あるいは
`--no-builtin-variables'オプションによって、暗黙のルールで用いられるす
べての変数を無効にすることができます。

たとえば、Cのソースファイルをコンパイルする場合の実際のコマンドは、
`$(CC) -c $(CFLAGS) $(CPPFLAGS)'です。また、コマンド`cc -c' 使用される
変数のデフォルトの値は`cc'だけです。`CC'を`ncc'と再定義することによっ
て、暗黙のルールで行なわれるすべてのCのコンパイルに対して`ncc'を起動す
ることができます。また、`CFLAGS'を`-g' であるように再定義すると、`-g'
オプションを個々のコンパイルに渡すことができます。Cのコンパイルを行な
う*すべて*の暗黙のルールはプログラム名を取得するために`$(CC)'を使用し、
コンパイラに与えられる引数における`$(CFLAGS)'を*すべて*インクルードし
ます。

暗黙のルールで用いられる変数は2つのクラスに分けられます。1つはプログラ
ムの名前（`CC'のような）、もう1つはプログラムに対する引数を含むもの
（`CFLAGS'）です（ここでプログラム名という場合にはコマンドの引数を含む
場合もあります。しかし名前は必ず実行プログラムの名前で始まります）。変
数が、1つよりも多い引数を含む場合にはスペースで区切ります。

ここに、組み込み済みのルールによるプログラム名として使用される変数の一
覧を示します。

`AR'
     アーカイブのメインテナンスプログラム；デフォルトでは、`ar'。

`AS'
     アセンブリの実行プログラム；デフォルトでは、`as'。

`CC'
     Cプログラムのコンパイルプログラム；デフォルトでは、`cc'。

`CXX'
     C++プログラムのコンパイルプログラム；デフォルトでは、`g++'。

`CO'
     RCSからの展開プログラム；デフォルトでは、`co'。

`CPP'
     Cのプリプロセッサプログラム、標準出力への結果；デフォルトでは、
     `$(CC) -E'。

`FC'
     FortranとRatforプログラムのためのコンパイルあるいはプリプロセッサ
     プログラム；デフォルトでは、`f77'。

`GET'
     SCCSからの展開プログラム；デフォルトでは、`get'。

`LEX'
     Lex文法のものをCあるいはRatforに変換するプログラム；デフォルトで
     は、`lex'。

`PC'
     Pascalプログラムのコンパイルプログラム；デフォルトでは、`pc'。

`YACC'
     Yacc文法のものをCあるいはRatforに変換するプログラム；デフォルトで
     は、`yacc'。

`YACCR'
     Yacc文法のものをRatforに変換するプログラム；デフォルトでは、`yacc
     -r'。

`MAKEINFO'
     TexinfoソースファイルをInfoファイルに変換するプログラム；デフォル
     トでは、`makeinfo'。

`TEX'
     TeXソースからTeX DVIファイルを作成するプログラム；デフォルトでは、
     `tex'。

`TEXI2DVI'
     TexinfoソースからTeX DVIファイルを作成するプログラム；デフォルト
     では、`texi2dvi'。

`WEAVE'
     WebをTeXに翻訳するプログラム；デフォルトでは、`weave'。

`CWEAVE'
     C WebをTeXに翻訳するプログラム；デフォルトでは、`cweave'。

`TANGLE'
     WebをPascalに翻訳するプログラム；デフォルトでは、`tangle'。

`CTANGLE'
     C WebをCに翻訳するプログラム；デフォルトでは、`ctangle'。

`RM'
     ファイルを削除するコマンド；デフォルトでは、`rm -f'。

前記のプログラムの付加的な引数である値を持つ変数の一覧を示します。デフォ
ルトの値はとくに注意書きがない限りすべて空です。

`ARFLAGS'
     アーカイブメインテナンスプログラムに与えるフラグ；デフォルトでは、
     `rv'。

`ASFLAGS'
     アセンブラに与えるフラグ（`.s'あるいは`.S'ファイルについて明示的
     に呼び出される場合）。

`CFLAGS'
     Cコンパイラに与えるフラグ。

`CXXFLAGS'
     C++コンパイラに与えるフラグ。

`COFLAGS'
     RCS `co'プログラムに与えるフラグ。

`CPPFLAGS'
     Cのプリプロセッサとプログラムに与えるフラグ（CとFortranコンパイ
     ラ）。

`FFLAGS'
     Fortranコンパイラに与えるフラグ。

`GFLAGS'
     SCCS `get'プログラムに与えるフラグ。

`LDFLAGS'
     リンカ`ld'を呼び出すときにコンパイラに与えるフラグ。

`LFLAGS'
     Lexに与えるフラグ。

`PFLAGS'
     Pascalコンパイラに与えるフラグ。

`RFLAGS'
     Ratforプログラムに対するFortranコンパイラに与えるフラグ。

`YFLAGS'
     Yaccに与えるフラグ。



File: make-jp.info, Node: Chained Rules, Next: Pattern Rules, Prev: Implicit Variables, Up: Implicit Rules

暗黙のルールの連鎖
==================

ファイルは暗黙のルールのシーケンスによって作成される場合があります。た
とえば、ファイル`N.o'は、最初にYacc、次に`cc'を実行することによって
`N.y'から作成されます。このようなシーケンスを"連鎖"と呼びます。

ファイル`N.c'が存在したり、makefileで言及されている場合、特別なサーチ
は必要ではありません。`make'はオブジェクトファイルがCのコンパイルによっ
て`N.c'から作成されることをみつけます。その後、`N.c'の作成法を考慮し、
Yaccの実行のルールが用いられます。最終的に、`N.c'と`N.o'の両方がアップ
デートされます。

しかしながら、`N.c'が存在せず、言及もされない場合でも`make'は`N.o'と
`N.y'のあいだの失われた関係を想像することができます。この場合は、`N.c'
が中間ファイルと呼ばれます。いったん`make'が"中間ファイル"を使用するこ
とを決定した場合、それはmakefileのなかで言及されているかのごとく、作成
方法を伝える暗黙のルールに沿ってデータベースに入力されます。

中間ファイルは、ほかのすべてのファイルとまったく同じようにルールに基づ
いて再作成されます。しかし、2つの事柄において中間ファイルの扱いは異な
ります。

1番目の違いは、中間ファイルが存在しない場合に起きる事柄です。普通のファ
イルBが存在しない場合で、`make'がターゲットはBに依存しているとみなした
場合は、Bが作成されそれによってターゲットのアップデートが行なわれます。
しかし、Bが中間ファイルの場合は、そのままにしておきます。Bのいくつかの
必要条件がターゲットより新しいかターゲットをアップデートするなんらかの
理由がない限り、Bやあるいは最終のターゲットのアップデートは行ないませ
ん。

2番目の違いは、何かほかのものをアップデートするために`make'がBを作成*
する*場合、必要がなくなったあとにBを削除することです。したがって、
`make'以前に存在しない中間ファイルは`make'のあとに存在しないのです。
`make'はどのファイルが削除されたかを示すコマンド`rm -f'によってその削
除を知らせます。

通常、ターゲットや必要条件としてmakefileのなかで言及されている場合には
あるファイルが中間ファイルになることはできません。しかし、特別なターゲッ
トである`.INTERMEDIATE'の必要条件としてリストされることによって明示的
に中間ファイルとしてマークすることができます。ほかの方法で明示的に言及
されている場合でも、この方法は有効です。

中間ファイルを"二次的"なファイルとしてマークすることで、自動的な削除を
回避することができます。これを行なうためには、特別なターゲット
`.SECONDARY'の必要条件としてリストすることです。ファイルが二次的である
場合、`make'はすでに存在しないためファイルを作成することはありませんが、
自動的に削除することもありません。ファイルを二次的であるとマークするこ
とは、中間ファイルとしてマークすることでもあります。

特別なターゲット`.PRECIOUS'の必要条件として、ファイル名とターゲットパ
ターンがマッチした暗黙のルールによって作られた中間ファイルを保存する目
的で、暗黙のルール（たとえば`%.o'のような）のターゲットパターンをリス
トすることができます。*Note `make'の中断あるいはkill: Interrupts.を参
照してください。

連鎖は2つよりも多い暗黙のルールを含んでいます。たとえば、RCS、Yacc、
`cc' の実行によって、`RCS/foo.y,v'から`foo'を作成することができます。
そして、`foo.y'と`foo.c'はどちらも中間ファイルで、最後には削除されます。

単一の暗黙のルールは、連鎖のなかで一度しか現われることができません。こ
の意味は、`make'によってリンカを2度実行して`foo.o.o'から`foo'を作成す
るような馬鹿なことは起きないことを考慮しているのです。この強制的な動作
は暗黙のルールの連鎖において、サーチの無限ループを避けることになってい
ます。

ルールの連鎖の違った形で処理される特別なケースを最適化するために、いく
つかの特別な暗黙のルールがあります。たとえば、`foo.c'から`foo'を作成す
るのはコンパイルとリンクという分離された連鎖ルールで、`foo.o'を中間ファ
イルとして使用します。しかし、実際に起きることは、この場合のルールは単
一の`cc'コマンドでコンパイルとリンクが行なわれることです。最適化された
ルールは段階的な連鎖に対する優位性で用いられ、それはルールのオーダー順
によるものです。



File: make-jp.info, Node: Pattern Rules, Next: Last Resort, Prev: Chained Rules, Up: Implicit Rules

パターンルールの定義と再定義
============================

"パターンルール"の記述によって暗黙のルールを定義することが可能です。パ
ターンルールは普通のルールと似ていますが、`%'文字をターゲットに含んで
いる点が違います。ターゲットはファイル名にマッチするパターンとしてみな
されます。`%'はほかの文字が自分自身としかマッチできなくとも、空でない
部分文字列の何とでもマッチすることが可能です。必要条件はその名前がター
ゲット名とどのように関係するかを示すために`%'を使用します。

したがって、パターンルール`%.o : %.c'は別のファイル`STEM.c'から
`STEM.o'を作成する方法を示します。

パターンルールにおいて`%'を使用した展開は、どんな変数やファンクション
の展開のあとでも、makefileが読み込まれたときに起こることに注意してくだ
さい。*Note 変数の使用法: Using Variables.と*Note テキスト変換のための
ファンクション: Functions.を参照してください。

* Menu:

* Pattern Intro::               An introduction to pattern rules.
* Pattern Examples::            Examples of pattern rules.
* Automatic::                   How to use automatic variables in the
                                  commands of implicit rules.
* Pattern Match::               How patterns match.
* Match-Anything Rules::        Precautions you should take prior to
                                  defining rules that can match any
                                  target file whatever.
* Canceling Rules::             How to override or cancel built-in rules.



File: make-jp.info, Node: Pattern Intro, Next: Pattern Examples, Up: Pattern Rules

パターンルールへのイントロダクション
------------------------------------

パターンルールはターゲットのなかに`%'文字を含んでいます。そうでなけれ
ば普通のルールのように見えます。ターゲットはファイル名にマッチしたパター
ンで、`%'はほかの文字が自分自身としかマッチできなくとも、空でない部分
文字列の何とでもマッチすることが可能です。

たとえば、パターンとしての`%.c'は`.c'で終わるどんなファイル名ともマッ
チします。また、パターンとしての`s.%.c'は`s.'で始まり、`.c'で終わる最
低5文字の長さのファイル名とマッチします（`%'とマッチするには最低でも1
文字必要です）。`%'がマッチする部分文字列は"stem"と呼ばれます。

パターンルールの必要条件の`%'は、ターゲットの`%'でマッチした同じstemと
同等です。パターンルールがあてはまるように、そのターゲットパターンは考
慮中のファイル名とマッチしなければならず、その必要条件のパターンは存在
するか作成可能なファイル名をつけなければなりません。それらのファイルは
ターゲットの必要条件になります。

したがって、書式のルールは、

     %.o : %.c ; COMMAND...

となり、ファイル`N.o'の作成法を別のファイル`N.c'をその必要条件として指
定します。このとき`N.c'は存在するか作成可能です。

`%'を使用しない必要条件もあるかもしれません。そのような必要条件は、こ
のパターンルールで作られたすべてのファイルに付属しています。このような
変化しない必要条件は場合によっては有益です。

`%'を含む必要条件をまったく必要としないパターンルールのようなルールは、
ワイルドカードのようなものです。それは、ターゲットパターンにマッチする
どんなファイルでも作成できてしまいます。*Note 最後の手段のルールの定義:
Last Resort.。

パターンルールは複数のターゲットを持つことができます。通常のルールと違
い、これは同じ必要条件とコマンドによる多くの種々のルールとして動作しま
せん。もし、パターンルールが複数のターゲットを持つ場合、`make'は、ルー
ルのコマンドが、ターゲットのすべてを作成することについて責任があると知っ
ています。コマンドは、すべてのターゲットを作成するために、1回だけ実行
されます。ターゲットとマッチするようにパターンルールを検索する際には、
ルールの必要なターゲットにマッチしているものを除いたルールのターゲット
パターンが偶然の一致となります。`make'は、ファイルに与えるコマンドと必
要条件だけについて検討します。しかし、このファイルのコマンドが実行され
るときには、ほかのターゲットはそれ自身がアップデートされたかのようにマー
クされます。

makefileにおいてパターンルールの現われる順序は重要です。なぜなら、それ
がパターンの考慮の順序になるからです。等しく適用可能なルールでも、みつ
けられた最初のものだけが使用されます。組み込まれたルールよりも記述した
ルールが優先します。しかし、注意しなければならないのは、ルールの必要条
件が実際に存在していること、あるいは、ほかの暗黙のルールの連鎖によって
作成される必要条件を持つルールよりもつねに優位に言及されていることが必
要です。



File: make-jp.info, Node: Pattern Examples, Next: Automatic, Prev: Pattern Intro, Up: Pattern Rules

パターンルールの例
------------------

ここにはいくつかのパターンルールの例があり、それらは`make'において事前
に定義されているものです。最初は、`.c'ファイルを`.o' ファイルにコンパ
イルするルールです。

     %.o : %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

は、`X.c'から`X.o'を何でも作成できるルールです。コマンドが自動変数`$@'
を使用し、`$<'でターゲットファイルとソースファイルを代用するルールです
（*Note 自動変数: Automatic..）。

また、2つめの組み込み済みルールがあります。

     % :: RCS/%,v
             $(CO) $(COFLAGS) $<

は、サブディレクトリ`RCS'においてファイル`X,v'に対応したファイル`X'を
何でも作成できるルールを定義しています。ターゲットが`%'なので、存在す
る適切な必要条件ファイルのどのようなファイルにでもこのルールを適用でき
ます。ダブルコロンは"最終的"なもので、その意味は、その必要条件が中間ファ
イルではないかもしれないという意味です（*Note 何にでもマッチするパター
ンルール: Match-Anything Rules..）。

このパターンルールの場合は2つのターゲットを持ちます。

     %.tab.c %.tab.h: %.y
             bison -d $<

この例では、`make'に対してコマンド`bison -d X.y'が`X.tab.c' と
`X.tab.h'の両方を作成するように示しています。ファイル`foo'がファイル
`parse.tab.o'と`scan.o'に依存して、ファイル`scan.o'がファイル
`parse.tab.h'に依存している場合、`parse.y'が変更されたとき、コマンド
`bison -d parse.y'が1度だけ実行され、`parse.tab.o'と`scan.o'の両方の必
要条件が満足されます。（おそらく、ファイル`parse.tab.o'は`parse.tab.c'
から、`scan.o'は`scan.c'から再コンパイルされ、`foo'は`parse.tab.o'、
`scan.o'とそのほかの必要条件からリンクされ、うまく実行できるようになる
でしょう。）



File: make-jp.info, Node: Automatic, Next: Pattern Match, Prev: Pattern Examples, Up: Pattern Rules

自動変数
--------

`.c'ファイルを`.o'ファイルにコンパイルするパターンルールを記述するとし
ます。この場合、`cc'コマンドで正しいファイルを操作するようにするにはど
のように記述したらよいでしょうか。暗黙のルールが適用されるごとにファイ
ル名が異なるので、コマンドにファイル名を書くことはできません。

この場合、`make'の特別な機能、すなわち"自動変数"を使用することになりま
す。この変数はルールのターゲットと必要条件に基づいて、ルールが実行され
るたびに計算された値を持ちます。この例では、オブジェクトファイル名に
`$@'、ソースファイル名に`$<'を使用します。

自動変数についてまとめた一覧が以下のものです。

`$@'
     ルールにおけるターゲットのファイル名。ターゲットがアーカイブのメ
     ンバーである場合、`$@'はそのアーカイブファイルの名前になります。
     複数のターゲットを持つパターンルールの場合は（*Note パターンルー
     ルへのイントロダクション: Pattern Intro..）、`$@'は、ルールのコマ
     ンドが実行されるターゲットのどれかの名前になります。

`$%'
     ターゲットがアーカイブのメンバーの場合は、ターゲットメンバーの名
     前。*Note アーカイブファイルのアップデートに`make'を使用する:
     Archives.。たとえば、ターゲットが`foo.a(bar.o)'ならば、`$%'は
     `bar.o'で`$@'は`foo.a'になります。アーカイブのメンバーでない場合
     は、`$%'は空です。

`$<'
     最初の必要条件の名前。ターゲットが暗黙のルールからそのコマンドを
     取得した場合、暗黙のルールによって付加された最初の必要条件になり
     ます（*Note 暗黙のルールの使用: Implicit Rules..）。

`$?'
     ターゲットよりも新しいすべての必要条件の名前で、スペースで区切ら
     れています。アーカイブメンバーの必要条件の場合は、メンバーの名前
     が使用されます（*Note アーカイブファイルのアップデートに`make'を
     使用する: Archives..）。

`$^'
     スペースで区切られたすべての必要条件の名前。アーカイブメンバーの
     必要条件の場合は、メンバーの名前が使用されます（*Note アーカイブ
     ファイルの アップデートに`make'を使用する: Archives..）。ターゲッ
     トはほかのファイルに依存した必要条件を1つだけ持ち、個々のファイル
     が必要条件として何回リストされたかは問題ではありません。あるター
     ゲットに関して必要条件を複数回リストしたとしても、`$^'の値にはたっ
     た1つの名前がコピーされるだけです。

`$+'
     これは`$^'に似ていますが、makefile中でリストされた順序に従って、1
     回以上リストされた必要条件が重複します。ある特別な順序でライブラ
     リのファイル名を繰り返す場合のリンクコマンドにおいて有益です。

`$*'
     暗黙のルールがマッチするstem（*Note パターンマッチの方法: Pattern
     Match..）。ターゲットが`dir/a.foo.b'でターゲットパターンが`a.%.b'
     の場合、stemは`dir/foo'です。stemは関連する名前の構築の際に有用で
     す。

     静的なパターンルールでは、stemはファイル名の一部でターゲットパター
     ンにおいては`%'にマッチします。

     明示的なルールの場合にはstemはありません。したがって、`$*'はこの
     方法では決定できません。かわりに、ターゲット名が既知のサフィック
     スで終わる場合（*Note 古いスタイルのサフィックスルール: Suffix
     Rules..）、`$*'はターゲット名からサフィックスを取ったものとなりま
     す。たとえば、ターゲット名が`foo.c'の場合は、`$*'は`foo'とセット
     されます。なぜなら、`.c'がサフィックスだからです。ほかの`make'の
     インプリメンテーションとの互換性のためだけにGNUの`make'はこの奇妙
     な動作を行ないます。一般的には、暗黙のルールあるいは静的なパター
     ンルールを除いて`$*'の使用は避けたほうがよいのでしょう。

     明示的なルールのターゲットが既知のサフィックスで終わっていない場
     合、`$*' はそのルールに関して、空の文字列としてセットされます。

明示的なルールにおいて、変更された必要条件だけを操作したいと考えるとき
に`$?'は有益です。たとえば、アーカイブ名`lib'はいくつかのオブジェクト
ファイルのコピーを含むことが考えられますが、このルールは変更のあったオ
ブジェクトファイルだけをアーカイブにコピーします。

     lib: foo.o bar.o lose.o win.o
             ar r lib $?

上記リストにおける4つの変数は単一のファイル名を持ち、3つはファイル名の
リストの値を持ちます。これらの7つはファイルのディレクトリ名だけだった
り、そのディレクトリのファイル名だけだったりするバリエーションを持って
います。それらの名前は`D'あるいは`F'を追加される書式となります。これら
の変数はGNUの`make'ではやや時代遅れとなっています。なぜならば、同じ効
果を持つものとしてファンクション`dir'と`notdir'が使用されるからです
（*Note ファイル名に対するファンクション: File Name Functions..）。し
かしながら、注意してほしいのは、`F'バリアントは`dir' ファンクションの
出力でつねに現われる後続のスラッシュをすべて省略してしまうことです。以
下にバリアントの一覧を示します。

`$(@D)'
     ターゲットのファイル名のディレクトリ部でうしろのスラッシュを除い
     たもの。`$@'の値が`dir/foo.o'のとき、`$(@D)'は`dir'です。`$@'がス
     ラッシュを含まないときは値は`.'となります。

`$(@F)'
     ターゲットのファイル名のファイル名の部分。`$@'の値が`dir/foo.o'の
     ときは、`$(@F)'は`foo.o'です。`$(@F)'は`$(notdir $@)'と同等です。

`$(*D)'
`$(*F)'
     ディレクトリ部とstemのファイル名。この例では`dir'と`foo'。

`$(%D)'
`$(%F)'
     ターゲットのアーカイブメンバーのディレクトリ部とファイル名。これ
     は、書式`ARCHIVE(MEMBER)'のアーカイブメンバーのターゲットでしか意
     味がありません。また、MEMBERがディレクトリ名を含む場合にだけ有益
     です（*Note ターゲットとしてのアーカイブメンバー: Archive
     Members..）。

`$(<D)'
`$(<F)'
     最初の必要条件のディレクトリ部とファイル名。

`$(^D)'
`$(^F)'
     すべての必要条件のディレクトリ部とファイル名のリスト。

`$(?D)'
`$(?F)'
     ターゲットよりも新しいすべての必要条件のディレクトリ部とファイル
     名のリスト。

これらの自動変数について話題にするときに、ある特別な従来からのスタイルを
用いることに注意してください。それは、`objects'と`CFLAGS'のように、
通常の変数を記述するように"the variable `<'"ではなくthe value
of `$<'と記述することです。この従来のものをこの特別なケースでは
自然であると考えます。とくに深い意味があるわけではなく、`$<'は`<'と
名付けられた変数を参照し、ちょうどこれは`$(CFLAGS)'が`CFLAGS'と
名付けられた変数を参照することと同じです。したがって、同じように`$<'の
場所で`$(<)'を使うことができます。



File: make-jp.info, Node: Pattern Match, Next: Match-Anything Rules, Prev: Automatic, Up: Pattern Rules

パターンマッチの方法
--------------------

ターゲットパターンは、プレフィックスとサフィックスの2つあるいは両方と
も空の場合も含めて両者のあいだの`%'から構成されています。オーバーラッ
プなしで、ファイル名がプレフィックスで始まり、サフィックスで終わる場合
にだけパターンはファイル名にマッチします。プレフィックスとサフィックス
のあいだのテキストは"stem"と呼ばれます。したがって、パターン`%.o'がファ
イル名`test.o'にマッチするときのstemは`test'です。パターンルールの必要
条件はstemを`%'文字で代用することによって実際のファイル名に変えられま
す。したがって、同じ例で、必要条件の1つが`%.c'と書かれた場合、それは
`test.c'と展開されます。

ターゲットパターンがスラッシュを含まないとき（通常はそうではありません
が）、ファイル名のディレクトリ名はターゲットのプレフィックスとサフィッ
クスと比較されるまえにファイル名から取り除かれます。ファイル名とターゲッ
トパターンの比較のあと、スラッシュで終わるディレクトリ名が、パターンルー
ルの必要条件パターンとファイル名から生成された必要条件のファイル名に加
えられます。ディレクトリは、ルールのアプリケーションのなかではなく、使
用される暗黙のルールの発見の目的のためだけに無視されます。したがって、
`e%t'は`src/a'をstemとしてファイル名`src/eat'にマッチします。必要条件
がファイル名に変えられるとき、stemからのディレクトリは先頭に加えられ、
stemの残りは`%'で代用されます。必要条件のパターン`c%r'を伴う
stem`src/a'はファイル名`src/car'を与えます。



File: make-jp.info, Node: Match-Anything Rules, Next: Canceling Rules, Prev: Pattern Match, Up: Pattern Rules

何にでもマッチするパターンルール
--------------------------------

パターンルールのターゲットが`%'だけであった場合、それはどんなファイル
名にでもマッチします。このようなルールを、"何にでもマッチする" ルール
と呼びます。これは非常に便利ですが、`make'がそれを検討するのに多くの時
間を費やします。なぜなら、ターゲットあるいは必要条件としてリストされた
個々のファイル名に対してすべて考慮しなければならないからです。

makefileが`foo.c'に言及する場合、このターゲットに対して、`make'はオブ
ジェクトファイル`foo.c.o'のリンク、あるいは`foo.c.c'からの1ステップで
のCコンパイルとリンク、あるいは`foo.c.p'からのPascal コンパイルとリン
クなどによってmakeすることを考慮しなければなりません。

しかし、これらの可能性は`foo.c'がCのソースファイルであって実行可能では
ないことを知っているため滑稽だと感じます。`make'がこれらの可能性を考慮
する場合、最終的にはそれらを拒絶するでしょう。なぜなら、`foo.c.o'と
`foo.c.p'のようなファイルが存在しないからです。しかし、このような可能
性が多ければ、`make'がそれらを考慮した場合には非常に動作が遅くなってし
まいます。

スピードを上げるには、`make'が何にでもマッチするルールを考慮する方法に
さまざまな制約を置きます。適用できる制約は2つあります。何にでもマッチ
するルールを適用する際には、どちらか一方のルールを選択しなければなりま
せん。

1つめの選択は、ダブルコロンを用いて何にでもマッチするルールを"ターミナ
ル"であるとしてマークすることです。ルールがターミナルであるとき、その
必要条件が実際に存在しない限りそれは適用されません。ほかの暗黙のルール
によって作られた必要条件は十分なものではありません。いいかえれば、ター
ミナルルールを越えて連鎖は許可されないのです。

たとえば、RCSやSCCSファイルからソースを展開する組み込み済みの暗黙のルー
ルはターミナルです。結果的に`foo.c,v'が存在しない場合、`make'は
`foo.c,v.o'あるいは`RCS/SCCS/s.foo.c,v'からの中間ファイルとしてそれを
みなそうとしません。RCSとSCCSファイルは一般的に究極のソースファイルで
あり、ほかのファイルから作り出されることはありません。したがって、
`make'はそれらを再構成する方法を探さないことで時間を節約できるのです。

もし、何にでもマッチするルールをターミナルであるとマークしない場合には
ターミナルでないことになります。ターミナルでない何にでもマッチするルー
ルは特別なタイプのデータを示すファイル名には適用できないことになります。
何にでもマッチしない暗黙のルールのターゲットがマッチしない場合、ファイ
ル名は特別なタイプのデータを示すことになります。

たとえば、ファイル名`foo.c'はパターンルール`%.c : %.y'（Yaccを実行する
ルール）に対するターゲットとマッチします。このルールが実際に適用可能か
どうかにかかわらず（`foo.y'が存在するときにだけ起こりますが）、ターゲッ
トがマッチするという事実は、ファイル`foo.c'に対するいかなるターミナル
でない何にでもマッチするルールを考慮するのを妨げるのに十分です。したがっ
て、`make'は`foo.c.o'、`foo.c.c'、`foo.c.p'などから実行ファイルとして
`foo.c'を作成しようと考慮することさえしないのです。

このような制約の理由は、ターミナルでない何にでもマッチするルールが、特
別なタイプのデータを含むファイル（たとえば実行ファイル）と既知のサフィッ
クスが特別なタイプのデータを示すファイル名（たとえばCのソース）を作成
するのに用いられるためです。

特定のファイル名を認識するために組み込み済みのダミーのパターンルールが
提供されていて、ターミナルでない何にでもマッチするルールは考慮されませ
ん。このようなダミーのルールは必要条件やコマンドを何も持たず、ほかの目
的に対しては無視されます。たとえば組み込み済みの暗黙のルール、

     %.p :

は、`foo.p'のようなPascalのソースファイルが特別なターゲットパターンに
マッチするかを確認し、これによって、`foo.p.o'や`foo.p.c'を探すための時
間をむだにすることを回避するのです。

`%.p'に対するもののようなダミーパターンルールは、サフィックスルールで
使用される正しくリストされたサフィックスに対して作られています（*Note 
古いスタイルのサフィックスルール: Suffix Rules..）。



File: make-jp.info, Node: Canceling Rules, Prev: Match-Anything Rules, Up: Pattern Rules

暗黙のルールのキャンセル
------------------------

組み込み済みの暗黙のルール（あるいは独自に定義したルール）を同じターゲッ
トと必要条件で新しいパターンルールを定義することでオーバーライドするこ
とが可能です。ただし、この場合コマンドは異なるものが必要です。新しいルー
ルが定義されると組み込み済みのものは置き換えられます。暗黙のルールのシー
ケンスにおける新しいルールの位置は、新しいルールを書いた場所によります。

組み込み済みの暗黙のルールを、同じターゲットと必要条件で新しいパターン
ルールを定義することでキャンセルすることが可能です。ただし、この場合コ
マンドは異なるものが必要です。たとえば、以下の例ではアセンブラの実行を
行なうルールをキャンセルできます。

     %.o : %.s



File: make-jp.info, Node: Last Resort, Next: Suffix Rules, Prev: Pattern Rules, Up: Implicit Rules

最後の手段のルールの定義
========================

必要条件なしにターミナルな何にでもマッチするパターンを記述することで最
後の手段ともいえる暗黙のルールを定義することができます（*Note 何にでも
マッチするパターンルール: Match-Anything Rules..）。これはほかのパター
ンルールと非常に似ていますが、いかなるターゲットにもマッチするという唯
一の点で異なります。したがって、そのようなルールのコマンドは暗黙のルー
ルが何も適用されず、自身のコマンドを持たないすべてのターゲットと必要条
件に対して用いられます。

たとえば、makefileのテストの際、ソースファイルが実データを持つ場合、存
在するだけなので気にしてはなりません。そして、以下のようにします。

     %::
             touch $@

は、すべてのソースファイル（必要条件として）が自動的に作成される必要が
あるようにします。

かわりに、ルールがまったくない場合のターゲットに対して用いられるコマン
ドを、ターゲットがコマンドを指定しなくとも、定義することができます。こ
の場合、ターゲット`.DEFAULT'に対してルールを書くことが必要です。そのよ
うなルールのコマンドは、いかなる明示的なルールにも現われないすべての必
要条件と暗黙のルールが適用されないものに対して用いられます。もちろん、
記述しない限り`.DEFAULT'ルールはありません。

コマンドや必要条件なしに`.DEFAULT'を使用する場合、

     .DEFAULT:

`.DEFAULT'に以前に保存されたコマンドはクリアされます。すると、`make'は
`.DEFAULT'がまったく定義されていないかのように動作します。

ターゲットが何にでもマッチするパターンルールあるいは`.DEFAULT'からコマ
ンドを取得するのを望まない場合で、しかしターゲットに対して何もコマンド
の実行を望まない場合は空のコマンドを与えることができます（*Note 空のコ
マンドの使用: Empty Commands..）。

別のmakefileの一部をオーバーライドするために、最後の手段のルールを使用
することができます。*Note ほかのMakefileの部分的なオーバーライド:
Overriding Makefiles.。



File: make-jp.info, Node: Suffix Rules, Next: Implicit Rule Search, Prev: Last Resort, Up: Implicit Rules

古いスタイルのサフィックスルール
================================

"サフィックスルール"は、`make'に対して暗黙のルールを定義するための古い
スタイルの方法です。サフィックスルールは、パターンルールがより一般的で
わかりやすいので時代遅れです。GNUの`make'では古いmakefileとの互換性を
とるためにサポートされます。ルールには2種類あり、それらは"ダブルサフィッ
クス"と"シングルサフィックス"です。

ダブルサフィックスルールは、ターゲットとソースのサフィックスのペアによ
るものです。ターゲットのサフィックスで終わるどんなファイル名ともマッチ
します。関係する暗黙の必要条件はファイル名でターゲットのサフィックスを
ソースのそれに置き換えられて作られます。2つのサフィックスによるルール
の場合は、ターゲットとソースが`.o'と`.c'で、`%.o : %.c'と同じです。

一方、シングルサフィックスルールは1つのサフィックスで定義されます。そ
れはソースのサフィックスです。それはどんなファイルともマッチし、関連し
た暗黙の必要条件の名前はソースのサフィックスが付け加えられます。シング
ルサフィックスルールで、`.c'はパターンルールの`% : %.c'と同じです。

サフィックスルールの定義は、既知のサフィックスのリストとそれぞれのルー
ルのターゲットとの比較で認識されます。`make'が既知のサフィックスをルー
ルにみつけた場合、そのルールはシングルサフィックスルールとみなされます。
`make'が既知の2つの連続したサフィックスをルールにみつけた場合、そのルー
ルはダブルサフィックスルールとみなされます。

たとえば、`.c'と`.o'の両方は既知のサフィックスのデフォルトのリストにあ
ります。したがって、ターゲットが`.c.o'であるルールを定義する場合、
`make'はソースサフィックス`.c'とターゲットサフィックス`.o'のダブルサ
フィックスルールであるようにします。ここで、Cコンパイラに対するルール
の定義の古い方法を示します。

     .c.o:
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

サフィックスルール自体は必要条件を何も持つことができません。もし持って
いる場合には、それはサフィックスルールではなく、妙な名前を持った通常の
ファイルとして扱われます。したがって、以下のルール

     .c.o: foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

は、必要条件ファイル`foo.h'からファイル`.c.o'を作成する方法を示してい
ます。

     %.o: %.c foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

上記は、`.c'ファイルから`.o'ファイルを作成する方法を示していて、
`foo.h'にも依存したパターンルールを使ってすべての`.o'ファイルを作成し
ます。

コマンドなしのサフィックスルールは無意味です。コマンドのないパターンルー
ルと同じくそれらのルールは以前のルールを取り除きません（*Note 暗黙のルー
ルのキャンセル: Canceling Rules..）。それらは、サフィックスあるいは連
結されたサフィックスをターゲットとしてデータベースに入力します。

既知のサフィックスはたんに特別なターゲット`.SUFFIXES'の必要条件の名前
で、`.SUFFIXES'に対するルールを記述することによって独自のサフィックス
を追加することが可能です。そうすることによって、必要条件も追加すること
になります。

     .SUFFIXES: .hack .win

上記は、サフィックスのリストの最後に`.hack'と`.win'を追加します。

たんに追加するかわりにデフォルトの既知のサフィックスを取り除きたい場合
は、必要条件なしに`.SUFFIXES'にルールを記述します。これによって、特別
な分配によって、すべての既存の`.SUFFIXES'の必要条件を取り除きます。ま
た、希望するサフィックスを追加するために別のルールを記述することもでき
ます。

     .SUFFIXES:            # デフォルトサフィックスを削除
     .SUFFIXES: .c .o .h   # サフィックスリストを定義

`-r'あるいは`--no-builtin-rules'フラグはサフィックスのデフォルトのリス
トを空にします。

変数`SUFFIXES'は、`make'がどのmakefileでも読み込むまえにサフィックスの
デフォルトのリストに定義されます。特別なターゲットの`.SUFFIXES'に対す
るルールでサフィックスのリストを変更できますが、この変数を変更するわけ
ではありません。



File: make-jp.info, Node: Implicit Rule Search, Prev: Suffix Rules, Up: Implicit Rules

暗黙のルールのサーチアルゴリズム
================================

`make'が、ターゲットTに対する暗黙のルールをサーチするのに用いる手続き
があります。この手続きは、コマンドなしの個々のダブルコロンルール、コマ
ンドを持たないここの通常のルールのターゲット、どのルールのターゲットで
もない個々の必要条件に従われます。また、ルールの連鎖において、暗黙のルー
ルからの必要条件に関して再帰的に従われます。

サフィックスルールはこのアルゴリズムでは言及されません。なぜならば、サ
フィックスルールは、いったんmakefileが読み込まれると、パターンルールに
変換されてしまうからです。

`ARCHIVE(MEMBER)'の書式を持つアーカイブメンバーのターゲットに対して、
以下のアルゴリズムは2回実行されます。1回目はターゲット名Tをすべて使用
し、1回目でルールを発見できない場合に、2回目は`(MEMBER)'をターゲット名
Tとして使用します。

  1. TをDと呼ばれるディレクトリとNと呼ばれる残りに分離します。たとえば、
     Tが`src/foo.o'のとき、Dは`src/'でNは`foo.o'です。

  2. そのターゲットうちの1つがTあるいはNにマッチするパターンルールのす
     べてのリストを作成します。ターゲットパターンがスラッシュを含む場
     合、Tにマッチし、ほかはNにマッチします。

  3. リストのどのルールも何にでもマッチするルールでは*ない*場合、その
     リストからすべてのターミナルでない何にでもマッチするルールを削除
     します。

  4. コマンドのないすべてのルールをリストから削除します。

  5. リストの個々のパターンルールに対して、

       a. stemを発見します。TあるいはNの空でない一部がターゲットパター
          ンの`%'でマッチしたものです。

       b. `%'に対するSの代用により必要条件を計算します。ターゲットパター
          ンがスラッシュを含まないとき、個々の必要条件の名前の先頭にD
          を追加します。

       c. すべての必要条件が存在するか、あるいはすべきかをテストします。
          （ファイル名がmakefileのなかでターゲットあるいは明示的な必要
          条件として言及されている場合、それは存在すべきであるといえま
          す。）

          すべての必要条件が存在するか、あるいはすべきであるとき、もし
          くは何も必要条件がない場合にこのルールが適用されます。

  6. もし、どんなルールも発見されない場合、リストの個々のパターンに対
     して、

       a. ルールがターミナルである場合、それを無視し次のルールに進みま
          す。

       b. そのまえに必要条件の名前を計算します。

       c. すべての必要条件が存在するかあるいはすべきかをテストします。

       d. 必要条件が存在しない場合、暗黙のルールによる作成が可能かどう
          か、このアルゴリズムを再帰的に適用します。

       e. 必要条件が存在する場合あるいは存在すべき場合、または暗黙のルー
          ルによって作成可能な場合、このルールを適用します。

  7. いかなる暗黙のルールも適用されない場合、`.DEFAULT'に対するルール
     も適用されない場合。そのような場合には、`.DEFAULT'の持つ同じコマ
     ンドをTに与えます。さもなければ、Tに対しては何もコマンドがありま
     せん。

いったん、適用されるルールがみつかると、TあるいはNにマッチしたもの以外
のルールの個々のターゲットパターンに対して、パターンのなかの`%'はSで置
き換えられ、結果的なファイル名はターゲットファイルTを再構成するコマン
ドが実行されるまで保存されます。それらのコマンドの実行後、保存された個々
のファイル名はデータベースに格納され、アップデートされてファイルTとし
てステータスもアップデートされたとしてマークされます。

Tに対してパターンルールのコマンドが実行される場合、自動変数はターゲッ
トと必要条件が一致しているようにセットされます。*Note 自動変数:
Automatic.。



File: make-jp.info, Node: Archives, Next: Features, Prev: Implicit Rules, Up: Top

アーカイブファイルのアップデートに`make'を使用する
**************************************************

"アーカイブファイル"は"メンバー"と呼ばれるサブファイルを含んでいます。
それらはプログラム`ar'でメインテナンスされ、リンクのためのサブルーチン
ライブラリとして使用されます。

* Menu:

* Archive Members::             Archive members as targets.
* Archive Update::              The implicit rule for archive member targets.
* Archive Pitfalls::            Dangers to watch out for when using archives.
* Archive Suffix Rules::        You can write a special kind of suffix rule
                                  for updating archives.



File: make-jp.info, Node: Archive Members, Next: Archive Update, Up: Archives

ターゲットとしてのアーカイブメンバー
====================================

`make'では、アーカイブファイルの個々のメンバーがターゲットとして使用さ
れます。以下のようにアーカイブファイルARCHIVEのMEMBERと名付けられたメ
ンバーを指定します。

     ARCHIVE(MEMBER)

この構成はターゲットと必要条件においてだけ利用可能で、コマンドでは利用
できません。コマンドで用いる大部分のプログラムはこのシンタックスをサポー
トせず、アーカイブメンバーに直接働くことはありません。ただし、`ar'とアー
カイブに対して操作を行なうように設計されたプログラムだけはそれが可能で
す。したがって、アーカイブメンバーのターゲットをアップデートする適切な
コマンドは`ar'を使用すべきです。たとえば、このルールはメンバー`hack.o'
をアーカイブ`foolib'にファイル`hack.o'をコピーすることで作成します。

     foolib(hack.o) : hack.o
             ar cr foolib hack.o

実際には、ほとんどのアーカイブメンバーのターゲットはこの方法でだけアッ
プデートされ、そこには暗黙のルールがあります。*［Note:］* アーカイブファ
イルがすでに存在している場合には`ar'に対する`c' フラグが必要であること
に注意してください。

同一のアーカイブでいくつかのメンバーを指定するには、括弧のなかにそのす
べてのメンバーを記述します。たとえば、

     foolib(hack.o kludge.o)

は、以下と同じです。

     foolib(hack.o) foolib(kludge.o)

アーカイブメンバーの参照にはシェルスタイルのワイルドカードが使用できます。
*Note ファイル名におけるワイルドカードの使用: Wildcards.。
たとえば、`foolib(*.o)'は`foolib'アーカイブの`.o'で終わる
名前のすべてのメンバーに展開されます。この例では、`foolib(hack.o) 
foolib(kludge.o)'となります。



File: make-jp.info, Node: Archive Update

アーカイブメンバーのターゲットに対する暗黙のルール
==================================================

`A(M)'のように見えるターゲットはアーカイブファイルAのMと名付けられたメ
ンバーを表わすことを思い出してください。

`make'がそのようなターゲットに対する暗黙のルールを探す際、特殊な機能と
して、実際のターゲット`A(M)'にマッチするのと同様に、`(M)'とマッチする
暗黙のルールを考慮します。

これは、ターゲットが`%'である特別なルールをマッチさせます。このルール
は、ファイルMをアーカイブにコピーすることによってターゲット`A(M)'をアッ
プデートします。たとえば、*ファイル* `bar.o'をアーカイブファイル
`foo.a'に`bar.o' という名前の*メンバー*としてコピーすることによってアー
カイブメンバーのターゲット`foo.a(bar.o)'をアップデートします。

このルールがほかのルールと連鎖になっている場合は非常に強力です。たとえ
ば、`bar.c'の存在のうえで`make "foo.a(bar.o)"'（クォート記号は、シェル
によって解決される際に、`('と`)'を使用する場合に必要です）は、たとえ
makefileがない場合でも、以下のコマンドを実行するのに十分です。

     cc -c bar.c -o bar.o
     ar r foo.a bar.o
     rm -f bar.o

ここで、`make'はファイル`bar.o'を中間ファイルとして想定しました。*Note 
暗黙のルールの連鎖: Chained Rules.。

このような暗黙のルールは自動変数`%'を使用して書かれています。*Note 自
動変数: Automatic.。

アーカイブのメンバーの名前はディレクトリを含むことはできません。しかし、
makefile中でそうみせかけることが有益な場合もあります。アーカイブメンバー
のターゲット`foo.a(dir/file.o)'を記述する際、`make'はこのコマンドで自
動的にアップデートを行ないます。

     ar r foo.a dir/file.o

これは、ファイル`dir/file.o'を`file.o'と名付けられたメンバーにコピーす
ることになります。そのような用法においては、自動変数`%D'と`%F'が有益で
す。

* Menu:

* Archive Symbols::             How to update archive symbol directories.



File: make-jp.info, Node: Archive Symbols, Up: Archive Update

アーカイブシンボルディレクトリのアップデート
--------------------------------------------

ライブラリとして使用されるアーカイブファイルは通常、ほかのすべてのメン
バーによって定義された外部のシンボル名のディレクトリを含む特別なメンバー
`__.SYMDEF'を含んでいます。何かほかのメンバーをアップデートしたあと、
ほかのメンバーを適切に要約するように、`__.SYMDEF'をアップデートする必
要があります。

     ranlib ARCHIVEFILE

通常、このコマンドをアーカイブファイルのためのルールに入れ、アーカイブ
ファイルのすべてのメンバーをルールの必要条件にします。たとえば、

     libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
             ranlib libfoo.a

の場合は、アーカイブメンバーの`x.o'や`y.o'などをアップデートし、
`ranlib'の実行によって、シンボルディレクトリメンバーである`__.SYMDEF'
のアップデートをします。メンバーのアップデートに関するルールはここでは
示されません。おそらく、それは省略され、先の節で記述したようにアーカイ
ブにファイルをコピーする暗黙のルールが用いられます。

GNUの`ar'プログラムを使用する場合は、`__.SYMDEF'のメンバーは自動的にアッ
プデートされるため、これは必要ではありません。



File: make-jp.info, Node: Archive Pitfalls

アーカイブ使用する際の危険性
============================

パラレル実行（`-j'スイッチ、*Note パラレル実行: Parallel..）を使用する
際は慎重に行なうことが重要です。同時に複数の`ar'コマンドが同じアーカイ
ブファイルに対して実行されるとき、互いにそれを知らないため、ファイルが
不完全になる可能性があります。

おそらく将来のバージョンの`make'では、同じアーカイブファイルへのすべて
のコマンド操作を連続して行なうようにしてこの問題を解決するメカニズムを
提供すると考えられますが、それまで時間がない場合には、ほかの方法でこの
問題を回避するようにmakefileに記述するか、`-j'を使用しないことが必要で
す。



File: make-jp.info, Node: Archive Suffix Rules, Prev: Archive Pitfalls, Up: Archives

アーカイブファイルに対するサフィックスルール
============================================

アーカイブファイルを扱うために、特別な種類のサフィックスルールを記述す
ることができます。サフィックスルールの詳細な説明は*Note 古いスタイルの
サフィックスルール: Suffix Rules.。アーカイブサフィックスルールはGNUの
`make'では時代遅れです。なぜならば、アーカイブに対するパターンルールが
より汎用的なメカニズム（*Note アーカイブメンバーのターゲットに対する 
アップデート: Archive Update..）だからです。しかし、ほかの`make'との互
換性のために残されています。

アーカイブに対するサフィックスルールを書くためには、ターゲットのサフィッ
クス`.a'を使ってサフィックスルールを簡単に書くだけです。たとえば、ここ
にCのソースファイルからライブラリのアーカイブをアップデートする古いス
タイルのサフィックスルールがあります。

     .c.a:
             $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
             $(AR) r $@ $*.o
             $(RM) $*.o

あたかもパターンルールを記述してあるかのごとく動作します。

     (%.o): %.c
             $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
             $(AR) r $@ $*.o
             $(RM) $*.o

実際には、`.a'をターゲットサフィックスとしてサフィックスルールを
`make'が読み込んだときに行なう動作がこれです。どんな
ダブルサフィックスルール`.X.a'もターゲットパターン
`(%.o)'と`%.X'の必要条件パターンを持つパターンルールに
変換されます。

ほかのいくつかの種類のファイルに対して`.a'をサフィックスとして
使用したいかもしれないため、`make'は普通、アーカイブサフィックスを
パターンルールに変換します（*Note 古いスタイルのサフィックス ルール: Suffix Rules..）。したがって、ダブルサフィックスルール`.X.a'は
2つのパターンルールを導きます。それは、`(%.o): %.X'と
`%.a: %.X'です。



File: make-jp.info, Node: Features, Next: Missing, Prev: Archives, Up: Top

GNU `make'の機能
****************

ここではGNU `make'の機能のうち、ほかのバージョンの`make'に対する著作表
示の対比におけるサマリーを示します。`make'の機能のベースは4.2 BSDシス
テムであるとみなしています。もし、ポータブルなmakefileを書こうとしてい
る場合は、ここにあげられている`make'の機能は使用すべきではないでしょう。
あるいは、*Note 非互換性と欠けている機能: Missing.についても同様です。

多くの機能がSystem Vの`make'のバージョンからきています。

   * `VPATH'変数とその特殊な意味。*Note 必要条件のためのディレクトリサー
     チ: Directory Search.。この機能は、System Vの`make'に存在します。
     しかし文書化されていません。文書化は4.3 BSDの`make'で行なわれまし
     た（mimics System Vの`VPATH'の機能として）。

   * インクルードされたmakefile。*Note ほかのMakefileをインクルードす
     る: Include.。単一のディレクティブによる複数ファイルのインクルー
     ドの許可はGNUによる拡張です。

   * 変数は環境変数を経由して読み込まれます。*Note 環境（変数）からの
     変数の取得: Environment.。

   * `make'の再帰的な呼び出しのために変数`MAKEFLAGS'を通してオプション
     が渡されます。*Note サブの`make'へのオプションの伝達:
     Options/Recursion.。

   * 自動変数`%'はアーカイブの参照におけるメンバー名にセットされます。
     *Note 自動変数: Automatic.。

   * 自動変数`$@'、`$*'、`$<'、`$%'と`$?'は`$(@F)'と`$(@D)'に似た書式
     を持ちます。これを明らかな展開として`$^'に汎用化しました。*Note 
     自動変数: Automatic.。

   * 変数参照の代用。*Note 変数参照の基礎: Reference.。

   * コマンド行のオプション`-b'と`-m'は受け入れられますが、無視されま
     す。System Vの`make'ではこれらのオプションはある動作を行ないます。

   * `-n'、`-q'あるいは`-t'が指定されていても、変数`MAKE'を経由する
     `make'を実行するコマンドの再帰的な実行。*Note `make'の再帰的用法:
     Recursion.。

   * サフィックスルールにおけるサフィックス`.a'のサポート。*Note アー
     カイブファイルに対するサフィックスルール: Archive Suffix Rules.。
     この機能はGNU `make'では時代遅れです。理由はルールの連鎖（*Note 
     暗黙のルールの連鎖: Chained Rules..）の汎用的な機能がアーカイブ
     （*Note アーカイブメンバーの ターゲットに対する暗黙のルール:
     Archive Update..）にメンバーをインストールごとに関するパターンルー
     ルを認めるからです。

   * 行の配置とコマンドにおけるバックスラッシュと改行の組み合わせは、
     コマンドが出力されるときに保持されます。したがって、最初の空白の
     分離は別として、makefile中にそのまま現われます。

以下の機能は、ほかのさまざまなバージョンの`make'によってもたらされまし
た。いくつかのケースでは、どのバージョンがどのバージョンに影響を与えた
か定かではありません。

   * `%'を使用するパターンルール。これはバージョンによってはインプリメ
     ントされています。誰による発案であるかは不明ですが、これは広く普
     及しています。*Note パターンルールの定義と再定義: Pattern Rules.。

   * ルールの連鎖と暗黙の中間ファイル。これは、Stu Feldmanによる彼のバー
     ジョンのAT&T Eighth Edition Research Unixの`make'でインプリメント
     されました。その後、T&T Bell LabsのAndrew Humeの`make'プログラム
     でインプリメントされました。その2つからこれを得たのか、あるいはわ
     れわれ自身でそれを同時に考えたのかはわかりません。*Note 暗黙のルー
     ルの連鎖: Chained Rules.。

   * カレントのターゲットのすべての必要条件のリストを含む自動変数`$^'。
     われわれはこれを発案しませんでしたが、誰が発案したかはわかりませ
     ん。*Note 自動変数: Automatic.。自動変数`$+'は`$^'の単純な拡張で
     す。

   * what if（GNU `make'では`-W'）は知っている限りでは、Andrew Hume に
     よって発案されました。*Note コマンド実行の代替: Instead of
     Execution.。

   * 同時にいくつかのことを実行する概念は多くの`make'や似たプログラム
     に存在しますが、System VやBSDのインプリメンテーションでは存在しま
     せん。*Note コマンド実行: Execution.。

   * パターンの代用による修正された変数の参照はSunOS 4からきています。
     *Note 変数参照の基礎: Reference.。SunOS 4に対する互換性のための別
     のシンタックスがインプリメントされる以前に、この機能は`patsubst'
     ファンクションでGNU `make'で提供されています。それらを誰が呼び起
     こしたのかはまったくわかりません。なぜなら、SunOS 4がリリースされ
     る以前からGNU `make'は`patsubst'を持つからです。

   * コマンド行に優先する`+'文字の特別な意義は（*Note コマンド実行の代
     替: Instead of Execution..）、`IEEE Standard 1003.2-1992'
     （POSIX.2）により委任されたものです。

   * 変数の値に追加する`+='はSunOS 4の`make'からきたものです。*Note 変
     数へのテキストの追加: Appending.。

   * 1つのアーカイブファイルの複数のメンバーのリストに対する
     `ARCHIVE(MEM1 MEM2...)'という書式はSunOS 4の
     `make'からきたものです。*Note ターゲットとしての アーカイブメンバー: Archive Members.。

   * 存在しないファイルに対するエラーのないmakefileのインクルードを行
     なう`-include'ディレクティブはSunOS 4の`make'からきたものです（し
     かし、SunOS 4の`make'では1つの`-include'ディレクティブで複数の
     makefileを指定することは許可していません）。同じような機能はSGI
     `make'における`sinclude'という名前で現われていて、ほかにもあるこ
     とでしょう。

残りの機能はGNU `make'における新しい機能です。

   * `-v'あるいは`--version'オプションの使用によりバージョンとコピーラ
     イト情報の出力をします。

   * `-h'あるいは`--help'オプションの使用により`make'のオプションの要
     約ができます。

   * 単純展開変数。*Note 変数の2つのフレーバー: Flavors.。

   * 再帰的な`make'の呼び出しのために変数`MAKE'を通してコマンド行の変
     数割り当てを自動的に渡します。*Note `make'の再帰的用法:
     Recursion.。

   * `-C'あるいは`--directory'コマンドオプションの使用により、ディレク
     トリの変更ができます。*Note オプションのサマリー: Options
     Summary.。

   * `define'によって同じ変数定義を作成します。*Note 変数のまったく同
     一の定義: Defining.。

   * 特別なターゲット`.PHONY'によって偽のターゲットの宣言をします。

     AT&T Bell LabsのAndrew Humeは、彼の`make'プログラムのなかで異なる
     シンタックスで似た機能をインプリメントしました。同時に発見した例
     のように思えます。*Note 偽のターゲット: Phony Targets.。

   * ファンクションの呼び出しによるテキストの操作。*Note テキスト変換
     のためのファンクション: Functions.。

   * `-o'あるいは`--old-file'オプションの使用は、ファイルの修正時刻が
     古いように見せかけます。*Note いくつかのファイルの再コンパイルの
     回避: Avoiding Compilation.。

   * 条件文の実行。

     この機能は多くのバージョンの`make'で何度もインプリメントされまし
     た。それは、Cプリプロセッサおよび同様なマクロ言語の機能から引き出
     された自然な拡張で、革命的な概念ではありません。*Note Makefileの
     条件文: Conditionals.。

   * インクルードされるmakefileに対するパスのサーチの指定。*Note ほか
     のMakefileをインクルードする: Include.。

   * 環境変数を用いた読み込むべき特別なmakefileの指定。*Note
     `MAKEFILES'の変数: MAKEFILES Variable.。

   * ファイル名から先行する`./'を切り離します。その結果、`./FILE'と
     `FILE'は同じにみなされます。

   * `-lNAME'で書かれたライブラリの必要条件に対する特別なサーチ法を使
     用します。*Note リンクライブラリに対するディレクトリサーチ:
     Libraries/Search.。

   * サフィックスルール（*Note 古いスタイルのサフィックスルール:
     Suffix Rules..）では、すべての文字の使用が可能です。ただし、
     `make'のバージョンによっては、`.'で始まり`/'は含んではいけない場
     合があります。

   * 変数`MAKELEVEL'を使用する場合、`make'の再帰的な使用のカレントレベ
     ルに絶えず注意をします。*Note `make'の再帰的用法: Recursion.。

   * 変数`MAKECMDGOALS'のなかのコマンド行ではなんらかのゴールを与えま
     す。*Note ゴールを指定する引数: Goals.。

   * 静的なパターンルールを指定します。*Note 静的なパターンルール:
     Static Pattern.。

   * 選択的な`vpath'サーチを提供します。*Note 必要条件のためのディレク
     トリサーチ: Directory Search.。

   * 計算された変数参照を提供します。*Note 変数参照の基礎: Reference.。

   * makefileのアップデートにおいて、System Vの`make'は非常に限られた
     書式になり、SCCSファイルに対するチェックによります。*Note
     Makefileの作られ方: Remaking Makefiles.。

   * さまざまな新しい組み込み済みの暗黙のルール。*Note 暗黙のルールの
     カタログ: Catalogue of Rules.。

   * 組み込み済みの変数`MAKE_VERSION'は`make'のバージョン番号を与えま
     す。



File: make-jp.info, Node: Missing, Next: Makefile Conventions, Prev: Features, Up: Top

非互換性と欠けている機能
************************

さまざまなシステムにおける`make'プログラムは、GNU `make'にインプリメン
トされていないいくつかの機能をサポートしています。ただし、POSIX.2標準
（`IEEE Standard 1003.2-1992'）では、それらの機能を必要とはしていませ
ん。

   * 書式`FILE((ENTRY))'のターゲットはアーカイブファイルFILE のメンバー
     を意味します。そのメンバーは、名前ではなく、リンカのシンボルENTRY
     を定義するオブジェクトファイルの存在によって選択されます。

     この機能はGNU `make'には入れられませんでした。理由は、アーカイブ
     シンボルのテーブルの内部書式のせいで、`make'にその知識を与える際
     の非モジュール性があるからです。*Note アーカイブシンボルディレク
     トリのアップデート: Archive Symbols.。

   * `~'文字で終わるサフィックス（サフィックスルールで使用される）は
     System Vの`make'では特別な意味を持ち、`~'なしのファイルに一致した
     SCCSファイルを参照します。たとえば、サフィックスルール`.c~.o'は
     SCCSファイル`s.N.c'からファイル`N.o'を作成します。全体の網羅のた
     めには一連のサフィックスルールが必要です。*Note 古いスタイルのサ
     フィックスルース: Suffix Rules.。

     GNU `make'においては、この全体の一連のケースは、ルールの連鎖の汎
     用的な機能の組み合わせにより、SCCSファイルからの展開に対する2つの
     パターンルールで処理されます。*Note 暗黙のルールの連鎖: Chained
     Rules.。

   * System Vの`make'においては、文字列`$$@'は奇妙な意味を持ち、複数の
     ターゲットを持つルールの必要条件において、処理される特定のターゲッ
     トを意味します。

     `$$'は通常の`$'としてみなされるため、GNU `make'ではこのような定義
     がされていません。

     静的なパターンルール（*Note 静的なパターンルール: Static
     Pattern..）の使用を通してこの機能の部分的なものを得ることができま
     す。System Vの`make'のルールの、

          $(targets): $$@.o lib.a

     は、GNU `make'の静的なパターンルールでは以下のように置き換えられ
     ます。

          $(targets): %: %.o lib.a

   * System Vと4.3 BSDの`make'では、`VPATH'サーチ（*Note 必要条件のた
     めのディレクトリサーチ: Directory Search..）で発見されるファイル
     はコマンド文字列で変更された名前を持ちます。しかし、つねに自動変
     数を使用したほうがよりわかりやすいと思われ、この機能は時代遅れだ
     と思われます。

   * Unixの`make'によっては、ルールの必要条件に現われる自動変数`$*'が、
     その*ルールのターゲット*のフルネームに展開してしまうという驚異的
     な機能を持つ場合があります。しかし、Unixの`make'開発者の精神から
     はこれがどんな意味を持つのかわかりません。`$*'の通常の定義とまっ
     たく整合性がないと感じます。

   * また、Unixの`make'によっては、暗黙のルール（*Note 暗黙のルールの
     使用: Implicit Rules..）によるサーチがコマンドのないもの以外にも*
     すべて*のターゲットに対して行なわれるようです。これは以下のような
     ことが可能という意味です。

          foo.o:
                  cc -c foo.c

     この例では、Unixの`make'は`foo.o'が`foo.c'に依存していると直感し
     てしまうでしょう。

     このような用法は破綻すると考えられます。`make'の必要条件の属性は
     明確に定義されていて（少なくともGNUの`make'では）、そのような使用
     法はモデルに適合しないのです。

   * GNUの`make'はEFLプログラムのコンパイル、あるいはプリプロセスに対
     する組み込み済みの暗黙のルールを含みませんが、EFLを使用するユーザー
     がいたら、それを喜んで追加します。

   * SVR4の`make'では、サフィックスルールの指定はコマンドなしで行なわ
     れ、空のコマンド（*Note 空のコマンドの使用: Empty Commands..）で
     あるかのように扱われます。たとえば、

          .c.a:

     は、組み込み済みの`.c.a'サフィックスルールをオーバーライドします。

     コマンドなしのルールに対しては、ターゲットに対する必要条件のリス
     トに単純に追加する方法が、よりわかりやすいと考えます。したがって、
     上記の例は、GNUの`make'では以下のように書き換えることができます。

          .c.a: ;

   * `make'のバージョンによっては、`-k' （*Note プログラムのコンパイル
     テスト: Testing..）のない場合には`-e'フラグでシェルを呼び出します。
     `-e'フラグは、シェルに対して実行していたプログラムをゼロ以外のス
     テータスを返してただちに終了するように指示します。特別な取り扱い
     を必要とせず、それ自身で完結するような個々のシェルコマンド行を記
     述するほうがわかりやすいと思います。




File: make-jp.info, Node: Makefile Conventions

Makefileの約束ごと
******************

このノードでは、GNUのプログラムに関するMakefileの記述に関しての約束事
を記します。Automakeを利用することによって、それらの約束事にそった
Makefileの記述の手助けをしてくれます。

* Menu:

* Makefile Basics::		General Conventions for Makefiles
* Utilities in Makefiles::	Utilities in Makefiles
* Command Variables::		Variables for Specifying Commands
* Directory Variables::		Variables for Installation Directories
* Standard Targets::		Standard Targets for Users
* Install Command Categories::  Three categories of commands in the `install'
                                  rule: normal, pre-install and post-install.



File: make-jp.info, Node: Makefile Basics

Makefileに関する一般的な約束事
==============================

すべてのMakefileは、以下の行を含まなければなりません。

     SHELL = /bin/sh

これは、`SHELL'変数が環境変数から継承される場合のシステムでのトラブル
を回避するためです。（しかし、GNUの`make'ではこれは問題にはなりません。）

異なる`make'プログラムは、互換性のないサフィックスのリストと暗黙のルー
ルを持ち、これが混乱や誤ったふるまいを引き起こします。したがって、以下
のように特定のMakefileにおいて、必要なサフィックスだけを明示的に使用す
るほうがよいのです。

     .SUFFIXES:
     .SUFFIXES: .c .o

最初の行でサフィックスのリストをクリアし、次の行で、このMakefileでの暗
黙のルールに必要なサフィックスを導入しています。

コマンド実行のためのパスに、`.'も入ると仮定しないでください。makeの際
のパッケージの一部としてプログラムを実行する際は、そのプログラムがmake
の一部としてビルドされる場合には`./'を、ソースコードの変化のないファイ
ルの場合には`$(srcdir)/'を使用します。これらのサフィックスのどれもない
場合には、カレントのサーチパスが使用されます。

`./'（"ビルドディレクトリ"）と`$(srcdir)/'（"ソースディレクトリ"）の区
別は重要です。なぜならば、`configure'に`--srcdir' オプションを使用して
別個のディレクトリでビルドを行なうことが可能だからです。書式のルールは、

     foo.1 : foo.man sedscript
             sed -e sedscript foo.man > foo.1

と記述し、ビルドディレクトリがソースディレクトリでない場合には失敗しま
す。なぜならば、`foo.man'と`sedscript'がソースディレクトリにあるからで
す。

GNUの`make'を使用する場合には、ソースファイルをみつけるための`VPATH'を
信頼することで、簡単な依存状態ではうまくいきます。なぜならば、`make'の
自動変数`$<'はどこにあろうとそのソースファイルを代替するからです。（た
だし、多くの`make'のバージョンでは`$<'を明示的なルールでのみセットしま
す。）次のようなMakefileのターゲットは、

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c bar.c -o foo.o

以下のように書き換えられ、

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c $< -o $@

`VPATH'が正しく動作するようにされます。ターゲットが複数の依存状態を持
つ場合には、ルールがうまく動作できるようにするためには明示的な
`$(srcdir)'を使用するのがもっとも簡単な方法です。たとえば、`foo.1'に対
する上記のターゲットは以下のように書かれます。

     foo.1 : foo.man sedscript
             sed -e $(srcdir)/sedscript $(srcdir)/foo.man > $@

GNUのディストリビューションは通常、ソースファイルではないものを含んで
います。たとえば、InfoファイルやAutoconf、Automake、BisonやFlexなどの
出力です。これらのファイルは通常はソースディレクトリにある、あるいはつ
ねにそこになければならず、ビルドディレクトリにはないため、それらをアッ
プデートするMakefileのルールはソースディレクトリにアップデートしたファ
イルを出力します。

しかしながら、あるファイルがディストリビューションにない場合、Makefile
はソースディレクトリに出力しません。なぜならば、普通の条件でプログラム
をビルドする場合は、ソースディレクトリを変更することはまずありえないか
らです。

最低でも、パラレル実行を行なう`make'でターゲットのビルドとインストール
を行なうことを試してみてください。



File: make-jp.info, Node: Utilities in Makefiles

Makefileにおけるユーティリティ
==============================

Makefileのコマンド（と、`configure'のようなあらゆるシェルスクリプト）
は、`csh'ではなく`sh'で動作するように記述してください。`ksh'や`bash'の
特別な機能を使用しないでください。

`configure'スクリプトとビルドとインストールのためのMakefileのルールで
は、以下の例外を除いてユーティリテイを直接使用してはなりません。


     cat cmp cp diff echo egrep expr false grep install-info
     ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch true

圧縮プログラムの`zip'は、`dist'ルールのなかで使用できます。

それらのプログラムに対して一般的にサポートされているオプションを使用す
るようにしてください。たとえば、便利であっても多くのシステムではサポー
トされていないため、`mkdir -p'は使用してはなりません。

また、いくつかのシステムではサポートしていないため、Makefileでのシンボ
リックリンクの作成は避けるべきでしょう。

ビルドとインスト−ルに対するMakefileのルールは、またコンパイラ、あるい
は関連したプログラムを使用することができますが、その場合はユーザーがほ
かに代用できるように`make'変数を使用すべきです。以下にそれらの例をあげ
ます。

     ar bison cc flex install ld ldconfig lex
     make makeinfo ranlib texi2dvi yacc

これらのプログラムの実行の際は、以下の`make'変数を使用してください。

     $(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
     $(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)

`ranlib'あるいは`ldconfig'を使用する場合、システムに問題となるプログラ
ムがない場合には、何も確認する必要はありません。コマンドからのエラーを
無視するように設定し、エラーをユーザーに通知するまえにそのエラーが問題
ではないということを出力するようにします（Autoconfの`AC_PROG_RANLIB'マ
クロがこれに役立ちます）。

シンボリックリンクを使用する場合は、これをサポートしないシステムのため
にかわりのものをインプリメントしなければなりません。

Make変数を利用して、使用可能なほかのユーティリティは以下のとおりです。

     chgrp chmod chown mknod

それらのユーティリティが存在することをあらかじめ知っている特定のシステ
ムに対しては、Makefileやスクリプトでそれらを使用することはかまいません。



File: make-jp.info, Node: Command Variables

コマンド指定の変数
==================

Makefileは、あるコマンド、オプションなどをオーバーライドする変数を提供
する必要があります。

また、とくに、多くのユーティリティプログラムは変数を経由して実行すべき
です。したがって、たとえばBisonを使用する場合には、デフォルトの設定が
`BISON = bison'になっている`BISON'と名付けられた変数を使用し、
`$(BISON)'で引用するようにします。

一方、`ln'、`rm'、`mv'などのファイル管理ユーティリティは、ユーザーがほ
かのプログラムで置き換える必要がないため、同じように変数経由で引用する
必要はありません。

個々のプログラム名変数は、プログラムにオプションを与えるためのオプショ
ン変数とともに用いられます。オプション変数を与えるために、たとえば、
`BISONFLAGS'のようにプログラム名変数に`FLAGS'を追加してください。（Cコ
ンパイラに対する`CFLAGS'、yaccに対する`YFLAGS'、lexに対する`LFLAGS'は
このルールの例外ですが、標準であるためこれを残してあります。）プリプロ
セッサを実行するあらゆるコンパイルのコマンドにおいて`CPPFLAGS'を使用し
てください。また、`ld'の直接的な使用と同じようにリンクを実行するあらゆ
るコンパイルのコマンドにおいて`LDFLAGS'を使用してください。

あるファイルを適切にコンパイルするためのCコンパイラのオプションが*ある
*場合、それを`CFLAGS'に含めてはなりません。ユーザーは自分自身で自由に
`CFLAGS'を指定できることを期待しています。したがって、そのかわりに、
`CFLAGS'とは独立してCコンパイラに必要なオプションを渡すように設定しま
す。その場合、以下のようにコンパイルのコマンドに明示的に記述するか暗黙
のルールを定義します。

     CFLAGS = -g
     ALL_CFLAGS = -I. $(CFLAGS)
     .c.o:
             $(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) $<

`CFLAGS'に`-g'を含むようにしてください。なぜならば、適切なコンパイルに
対して*必要*ではないためです。ただし、それは推奨されるデフォルトとみな
すことができます。デフォルトでGCCを用いるようにセットされたパッケージ
の場合、`CFLAGS'の値はデフォルトの値である`-O'を含むのと同じとみなされ
ます。

コンパイラオプションを含むほかの変数のあとに続いて、コンパイルコマンド
に`CFLAGS'を入れてください。それによって、`CFLAGS'がほかをオーバーライ
ドすることになります。

`CFLAGS'はコンパイルとリンクの両方において、Cコンパイラが呼び出される
たびに使用されることになります。

Makefileでは、必ず変数`INSTALL'を定義すべきで、これによってファイルの
システムへのインスト−ルが行なわれます。

また、Makefileでは必ず変数`INSTALL_PROGRAM'と`INSTALL_DATA'も定義すべ
きです（それらに対するデフォルトは`$(INSTALL)'のはずです）。そして、そ
れらの変数を実行プログラムとそうでないものに対して、実際のインストール
時にコマンドとして使用します。これらの変数は以下のように用います。

     $(INSTALL_PROGRAM) foo $(bindir)/foo
     $(INSTALL_DATA) libfoo.a $(libdir)/libfoo.a

場合によっては、`DESTDIR'の値をターゲットファイル名にしてもかまいませ
ん。そうすることで、インストーラがあとで実際のファイルシステムのターゲッ
トにコピーができるようにスナップショットを作成することになります。
Makefileで`DESTDIR'の値をセットしてはなりません。また、インストールさ
れたファイルにその値を含めてはいけません。`DESTDIR'のサポートによって、
前記の例は以下のようになります。

     $(INSTALL_PROGRAM) foo $(DESTDIR)$(bindir)/foo
     $(INSTALL_DATA) libfoo.a $(DESTDIR)$(libdir)/libfoo.a

インストールのコマンドの2番目の引数にはつねにファイル名を用い、ディレ
クトリ名は用いません。インストールされる個々のファイルに対してはコマン
ドを区切って使用します。



File: make-jp.info, Node: Directory Variables

インストールディレクトリの変数
==============================

インストールディレクトリは、つねに変数で名前をつけられなければなりませ
ん。そうすることによって、標準的でない場所へのインストールも簡単になる
のです。それらの変数の標準的な名前は、以下で記述しています。また、それ
らは標準的なファイルシステムのレイアウトに基づいていて、SVR4、4.4BSD、
Linux、Ultrix v4などの最近のオペレーティングシステムでは若干の相違があ
ります。

それら2つの変数は、インストールのためにrootにセットされます。ほかのイ
ンストールディレクトリのすべては、その2つのうちの1つのサブディレクトリ
にセットされ、それら2つのディレクトリに直接インストールされるべきでは
ありません。

`prefix'
     以下にリストした変数のデフォルトの値を構築する際にプレフィックス
     を用いました。`prefix'のデフォルトの値は`/usr/local' でなければな
     りません。完全なGNUのシステムをビルドする場合には、プレフィックス
     は空でなければならず、`/usr'は`/'へのシンボリックリンクとなるでしょ
     う。（Autoconfを使用する場合は、`@prefix@'のように記述します。）

     プログラムのビルドに用いられた`prefix'の値と異なる値を用いて`make
     install'を実行する場合は、そのプログラムは再コンパイルされません。

`exec_prefix'
     以下にリストした変数のいくつかのデフォルトの値を構築する際にプレ
     フィックスを用いました。`exec_prefix'のデフォルトの値は
     `$(prefix)'でなければなりません。（Autoconfを使用する場合は、
     `@exec_prefix@'のように記述します。）

     一般的に、`$(exec_prefix)'は（実行ファイルやサブルーチンライブラ
     リのような）マシン固有のものを含むディレクトリに対して用いられま
     す。その際、`$(prefix)'はほかのディレクトリに直接的に用いられます。

     プログラムのビルドに用いられた`exec_prefix'の値と異なる値を用いて
     `make install'を実行する場合は、そのプログラムは再コンパイルされ
     ません。

実行可能なプログラムは、以下のディレクトリの1つにインストールされます。

`bindir'
     ユーザーが実行可能な実行プログラムをインストールするディレクトリ。
     これは通常は、`/usr/local/bin'ですが、`$(exec_prefix)/bin'のよう
     に記述します。（Autoconfを使用する場合は、`@bindir@'のように記述
     します。）

`sbindir'
     シェルから実行可能なプログラムのインストールのためのディレクトリ。
     ただし、一般的にはシステム管理者にのみ有益なディレクトリです。通
     常は`/usr/local/sbin'ですが、`$(exec_prefix)/sbin'と記述されます。
     （Autoconfを使用する場合は、`@sbindir@'のように記述します。）

`libexecdir'
     ユーザーよりも、むしろほかのプログラムから実行可能なプログラムの
     インストールのためのディレクトリ。通常は`/usr/local/libexec'です
     が、`$(exec_prefix)/libexec'と記述されます。（Autoconfを使用する
     場合は、`@libexecdir@'のように記述します。）

プログラムの実行時に使用されるデータファイルは、2つのカテゴリーに分け
られます。

   * ファイルによっては通常、プログラムにより変更が加えられるものとそ
     うでないもの（ユーザーが変更するかもしれない）があります。

   * ファイルによっては、アーキテクチャから独立していて、あるサイト全
     体のすべてのマシンから共有されているものもあります。反対にアーキ
     テクチャ依存である特定のオペレーティングシステムの数台で、共有さ
     れているものもあります。それ以外は、ほかのマシンから共有はされて
     いないファイルです。

このことは6種類の異なる可能性につながります。しかし、オブジェクトファ
イルとライブラリが別として、アーキテクチャ依存のファイルの使用は避けた
いと考えます。ほかのデータファイルをアーキテクチャ独立にすることは、よ
りクリアにすることで、一般的には難しくはありません。

したがって、Makefilesがディレクトリを指定するのに使用すべき変数をあげ
ます。

`datadir'
     リードオンリーアーキテクチャから独立したデータファイルのインストー
     ルのためのディレクトリ。通常は`/usr/local/share'ですが、
     `$(prefix)/share'と記述されます。（Autoconfを使用する場合は、
     `@datadir@'のように記述します。）特別な例外として、以下の
     `$(infodir)'と`$(includedir)'を確認してください。

`sysconfdir'
     単独のマシンと結び付いたファイル、すなわちホストの設定ファイルの
     ようなリードオンリーファイルをインスト−ルするディレクトリ。メイ
     ラやネットワーク設定ファイルや`/etc/passwd'などがこれに属します。
     これらのすべてのファイルはASCIIテキストファイルです。通常は
     `/usr/local/etc'ですが、`$(prefix)/etc'と記述されます。（Autoconf
     を使用する場合は、`@sysconfdir@'のように記述します。）

     このディレクトリに実行可能なファイルをインスト−ルしてはなりませ
     ん（それらは`$(libexecdir)'、あるいは`$(sbindir)'に属しているはず
     です）。また、それらが使用されているあいだにファイルをインストー
     ルしてはなりません（システムのコンフィギュレーションを変更する目
     的を持つプログラムは実行を停止させます）。それらは
     `$(localstatedir)'に属しています。

`sharedstatedir'
     プログラムが実行中に変更を加えるアーキテクチャ独立のデータファイ
     ルをインストールするディレクトリ。通常は`/usr/local/com'ですが、
     `$(prefix)/com'と記述されます。（Autoconfを使用する場合は、
     `@sharedatadir@'のように記述します。）

`localstatedir'
     特定のマシンと結び付いた、プログラムの実行中に変更の加えられるデー
     タファイルをインストールするディレクトリ。パッケージの操作の際に
     は、ユーザーはこのディレクトリのファイルを変更する必要はありませ
     ん。分割されたそのような設定ファイルは`$(datadir)'、あるいは
     `$(sysconfdir)'におきます。`$(localstatedir)'は通常
     `/usr/local/var'ですが、`$(prefix)/var'と記述されます。

`libdir'
     オブジェクトファイルとオブジェクトコードのライブラリのためのディ
     レクトリ。ここに実行可能ファイルをインストールしてはなりません。
     そのかわりに`$(libexecdir)'にそれらを置いてください。`libdir'の値
     は通常は`/usr/local/lib'ですが、`$(exec_prefix)/lib'と記述されま
     す。（Autoconfを使用する場合は、`@libdir@'のように記述します。）

`infodir'
     パッケージのInfoファイルのインストールのためのディレクトリ。デフォ
     ルトでは、`/usr/local/info'ですが、`$(prefix)/info'と記述されます。
     （Autoconfを使用する場合は、`@infodir@'のように記述します。）

`lispdir'
     パッケージに含まれるEmacs Lispファイルのインストールのためのディ
     レクトリ。デフォルトでは、`/usr/local/share/emacs/site-lisp'です
     が、`$(prefix)/share/emacs/site-lisp'と記述されます。

     Autoconfを使用する場合は、デフォルトで`@lispdir@'のように記述しま
     す。`@lispdir@'が動作できるように、以下のような行を`configure.in'
     ファイルに記述する必要があります。

          lispdir='${datadir}/emacs/site-lisp'
          AC_SUBST(lispdir)

`includedir'
     C言語の`#include'ディレクティブによってユーザープログラムでインク
     ルードされるヘッダファイルのためのディレクトリ。通常は
     `/usr/local/include'ですが、`$(prefix)/include'と記述されます。
     （Autoconfを使用する場合は、`@includedir@'のように記述します。）

     GCCを除く大部分のコンパイラは、`/usr/local/include'のディレクトリ
     のヘッダファイルを探しません。したがって、この方法でヘッダファイ
     ルをインストールするのはGCCの場合にのみ有益です。ライブラリによっ
     ては、GCCでしか動作しないものもあるため、このことは問題にならない
     場合があります。しかし、ライブラリによってはほかのコンパイラでも
     動作するようになっています。その場合には、ヘッダファイルは、
     `includedir'と`oldincludedir'で指定された2つのディレクトリにイン
     ストールされなければなりません。

`oldincludedir'
     GCC以外のコンパイラで使用される`#include'ヘッダファイルのインストー
     ルディレクトリ。通常は`/usr/include'です。（Autoconfを使用する場
     合は、`@oldincludedir@'のように記述します。）

     Makefileコマンドは`oldincludedir'の値が空かどうかをチェックしなけ
     ればなりません。空である場合には、それを使用しようとしません。ま
     た、ヘッダファイルの2番目のインストールをキャンセルすることになり
     ます。

     パッケージは、同じパッケージによるものでない限り、このディレクト
     リに存在するヘッダファイルを置き換えるべきではありません。したがっ
     て、Fooというパッケージがヘッダファイル`foo.h'を提供している場合、
     （1）`foo.h'がない場合、あるいは（2）パッケージFooによる`foo.h'が
     存在する場合のどちらの場合でも`oldincludedir' ディレクトリにイン
     ストールしなければなりません。

     `foo.h'がパッケージFooのものであるかどうかを伝えるために、魔法の
     文字列をファイルにコメントの一部として入れてください。そして、そ
     の文字列を`grep'にかけます。

Unixスタイルのmanページが、以下の1つのデイレクトリにインストールされま
す。

`mandir'
     パッケージのmanページのインスト−ルのためのトップレベルのディレク
     トリ。通常は、`/usr/local/man'ですが、`$(prefix)/man'と記述すべき
     です。（Autoconfを使用する場合は、`@mandir@'のように記述します。）

`man1dir'
     セクション1のmanページのインスト−ルディレクトリで、
     `$(mandir)/man1'と記述します。
`man2dir'
     セクション2のmanページのインスト−ルディレクトリで、
     `$(mandir)/man2'と記述します。
`...'

     GNUソフトウェアに関する主要なドキュメントをmanページで作らないで
     ください。そのかわりにTexinfoで記述してください。Manページは、
     Unix上で二次的なアプリケーションのみを動作させる人たちのためだけ
     にあるのです。

`manext'
     インストールされたmanページに対するファイル名の拡張。これは`.'に
     続いて適切な数字がつけられます。

`man1ext'
     インストールされたセクション1のmanページに対するファイル名の拡張。
`man2ext'
     インストールされたセクション2のmanページに対するファイル名の拡張。
`...'
     マニュアルの1セクションよりも多くmanページをインストールする必要
     がある場合には、`manext'のかわりにこれらを使用してください。

最終的に、以下の変数をセットする必要があります。

`srcdir'
     コンパイルされるソースに対するディレクトリ。この変数の値は通常は
     `configure'シェルスクリプトによって挿入されます。（Autoconfを使用
     する場合は、`srcdir = @srcdir@'を使用してください。）

例として、

     # Common prefix for installation directories.
     # NOTE: This directory must exist when you start the install.
     prefix = /usr/local
     exec_prefix = $(prefix)
     # Where to put the executable for the command `gcc'.
     bindir = $(exec_prefix)/bin
     # Where to put the directories used by the compiler.
     libexecdir = $(exec_prefix)/libexec
     # Where to put the Info files.
     infodir = $(prefix)/info

標準的なユーザー指定のディレクトリの1つに非常に多くのファイルをインス
トールする場合、そのプログラムに固有のサブディレクトリにそれらをグルー
プ化することが便利です。そうすることによって、必要なサブディレクトリを
作成するための`install'ルールを記述するのがよいでしょう。

上記にリストされた変数の値に、サブディレクトリを含むようにすることをユー
ザーに期待はできません。インストールディレクトリに関して均一な変数名の
セットを持つというアイデアは、いくつかの異なるGNUパッケージに対してまっ
たく同じ値をユーザーが指定できるようになります。このことが有益であるよ
うに、すべてのパッケージはユーザーがそうした場合にうまく動作するように
デザインされていなければなりません。



Info file: make-jp.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `make-jp.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.







INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Make: (make).            Remake files automatically.
END-INFO-DIR-ENTRY


This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

This is Edition 0.55, last updated 04 April 2000, of `The GNU Make
Manual', for `make', Version 3.79.

Copyright (C) 1988, '89, '90, '91, '92, '93, '94, '95, '96, '97, '98,
'99, 2000 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.




File: make-jp.info, Node: Standard Targets

ユーザーにとっての標準ターゲット
================================

すべてのGNUプログラムは、Makefileに以下のターゲットを持たなければなり
ません。

`all'
     プログラム全体のコンパイル。これがデフォルトのターゲットです。こ
     のターゲットはいかなるドキュメントファイルも再構成する必要はあり
     ません。ディストリビューションには通常はInfoファイルが含まれてい
     なければならず、要求があった場合にDVIファイルが作られるようになっ
     ていなければなりません。

     デフォルトでは、Makeのルールは`-g'でコンパイルとリンクを行ない、
     その結果、実行プログラムはデバッグシンボルを持ちます。ヘルプ機能
     のないことを気にしないユーザーの場合はあとで実行可能プログラムを
     分離することができます。

`install'
     コンパイルと実行プログラムとライブラリの実際に使用する際のファイ
     ル名へのコピー。プログラムが適切にインストールされるかを確認する
     簡単なテストがある場合は、このターゲットはそれを実行します。

     インスト−ルの最中に実行プログラムを分離してはなりません。向こう
     見ずなユーザーは、`install-strip'ターゲットでこれを実行する場合が
     あります。

     可能な場合には、プログラムがビルドされるディレクトリ、すなわち
     `make all'が実行されるディレクトリにおいて何も変更されないように
     `install'ターゲットルールを記述してください。

     あらかじめ存在しない場合には、コマンドはファイルがインスト−ルさ
     れるのに必要なすべてのディレクトリを作成するでしょう。これには、
     変数`prefix'と`exec_prefix'の値として指定されたディレクトリが含ま
     れ、同じように、必要なサブディレクトリも含まれます。これを行なう
     には以下に書かれたように、`installdirs'ターゲットによります。

     manページのインストールのコマンドのまえに`-'を使用します。そうす
     ることによって、`make'はあらゆるエラーを無視します。これは、Unix
     のmanページドキュメントシステムがインストールされていないシステム
     の場合です。

     Infoファイルをインストールするには、`$(INSTALL_DATA)' （*Note コ
     マンド指定の変数: Command Variables..）による`$(infodir)'にそれら
     をコピーします。その後、プログラムが存在する場合には
     `install-info'を実行します。`install-info'は1つのプログラムで、
     Infoの`dir'ファイルを編集し、与えられたInfoファイルのメニューエン
     トリを追加あるいはアップデートします。また、これはTexinfoパッケー
     ジの一部で、以下にインストールの例を示します。

          $(DESTDIR)$(infodir)/foo.info: foo.info
                  $(POST_INSTALL)
          # There may be a newer info file in . than in srcdir.
                  -if test -f foo.info; then d=.; \
                   else d=$(srcdir); fi; \
                  $(INSTALL_DATA) $$d/foo.info $(DESTDIR)$@; \
          # Run install-info only if it exists.
          # Use `if' instead of just prepending `-' to the
          # line so we notice real errors from install-info.
          # We use `$(SHELL) -c' because some shells do not
          # fail gracefully when there is an unknown command.
                  if $(SHELL) -c 'install-info --version' \
                     >/dev/null 2>&1; then \
                    install-info --dir-file=$(DESTDIR)$(infodir)/dir \
                                 $(DESTDIR)$(infodir)/foo.info; \
                  else true; fi

     `install'ターゲットを記述する際は、コマンドを3つのカテゴリに分け
     る必要があります。それらのコマンドは、通常のもの、"インストール前
     "のもの、インストール後のものです。*Note インストールコマンドのカ
     テゴリー: Install Command Categories.。

`uninstall'
     インストールしたファイル、すなわち`install'ターゲットが作成したす
     べてのファイルを削除する。

     このルールは、コンパイルが行なわれるディレクトリを変更せず、ファ
     イルがインストールされるディレクトリだけを変更します。

     アンインストールのコマンドは、ちょうどインストールコマンドと同様
     に3つのカテゴリーに分けられます。*Note インストールコマンドのカテ
     ゴリー: Install Command Categories.。

`install-strip'
     `install'に似ていますが、インストール中に実行プログラムを分離しま
     す。多くのケースでは、このターゲットの定義は非常に簡単なものにな
     ります。

          install-strip:
                  $(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \
                          install

     通常は、プログラムがバグを持っていないことが確信できる場合を除い
     て、実行ファイルを分離することは推奨されません。しかしながら、バ
     グがある場合を考慮して、分離していない実行プログラムをどこかに保
     存しながら、分離した実行ファイルをインストールするのは妥当なこと
     です。

`clean'

     プログラムのビルドの際に作成されたカレントディレクトリのすべての
     ファイルの削除をします。ただし、コンフィギュレーションを記録して
     いるファイルを削除してはなりません。また、ビルドによって作成され
     るファイルは保存しますが、通常それらはディストリビューションと一
     緒になっているものではありません。

     ディストリビューションの一部でない場合は`.dvi'ファイルを削除しま
     す。

`distclean'
     プログラムのビルドあるいは設定によって、作成されたカレントディレ
     クトリのすべてのファイルの削除をします。ソースを展開してほかのファ
     イルを作成せずにプログラムのビルドを行なった場合は、`make
     distclean'は、ディストリビューションにあるファイルだけを残すでしょ
     う。

`mostlyclean'
     `clean'に似ていますが、再コンパイルするのを避けたいいくつかのファ
     イルを削除することを回避します。たとえば、GCCに対する
     `mostlyclean' ターゲットは`libgcc.a'を削除しません。なぜなら、再
     コンパイルの必要性はめったになく、時間も長くかかるからです。

`maintainer-clean'
     Makefileによって再構築可能なカレントディレクトリのほとんどすべて
     のファイルの削除をします。一般的には、`distclean'で削除されるすべ
     てのファイルを含みますが、これに加えて、Bisonによって作成されたC
     ソースファイル、タグテーブル、Infoファイルなどです。

     ほとんどすべてという意味は、`make maintainer-clean'の実行は、
     Makefileのなかでルールを用いて`configure'が再作成可能な場合でさえ、
     `configure'を削除すべきではないからです。さらに一般的には、`make
     maintainer-clean'は、`configure'の実行とプログラムのビルドの開始
     の順序に従って、存在しなくてはならないすべてのものを削除してはな
     らないのです。ただし、`maintainer-clean'は再構成可能なほかのもの
     をすべて削除しなければならず、これは唯一の例外といえます。

     `maintainer-clean'ターゲットは、パッケージの管理者によって使用さ
     れることを意図しています。`make maintainer-clean'によって、削除さ
     れたファイルのいくつかのファイルの再構築には特別なツールが必要に
     なるかもしれません。通常はそれらのファイルがディストリビューショ
     ンに含まれているので、再構築を容易にする点については注意を払いま
     せん。再度ディストリビューションを展開する必要がある場合には容赦
     してほしいものです。

     ユーザーがこのことに気づくように、特別な`maintainer-clean'ターゲッ
     トに対するコマンドは以下の2つの事柄で始まらなければなりません。

          @echo 'This command is intended for maintainers to use; it'
          @echo 'deletes files that may need special tools to rebuild.'

`TAGS'
     このプログラムに対するタグテーブルのアップデート。

`info'
     必要なInfoファイルの生成。ルールの記述の仕方で、もっともよいのは
     以下のとおりです。

          info: foo.info

          foo.info: foo.texi chap1.texi chap2.texi
                  $(MAKEINFO) $(srcdir)/foo.texi

     Makefileにおいて、変数`MAKEINFO'を定義しなければなりません。それ
     は`makeinfo'プログラムを実行します。このプログラムはTexinfoのディ
     ストリビューションに含まれています。

     通常は、GNUのディストリビューションはInfoファイルを含みますので、
     ソースディレクトリにInfoファイルが存在することになります。したがっ
     て、Infoファイルに対するMakeのルールは、ソースディレクトリにおい
     てアップデートを行なうことになります。パッケージをビルドする際に
     は、すでにあるものが最新であるため、普通のMakeはInfoファイルのアッ
     プデートは行ないません。

`dvi'
     すべてのTexInfoドキュメントに対してDVIファイルを生成します。例と
     しては、

          dvi: foo.dvi

          foo.dvi: foo.texi chap1.texi chap2.texi
                  $(TEXI2DVI) $(srcdir)/foo.texi

     Makefileにおいて変数`TEXI2DVI'を定義する必要があります。それがプ
     ログラム`texi2dvi'を実行させることになります。そのプログラムは
     Texinfoディストリビューションに含まれ、 (1) (*Note Standard
     Targets-Footnotes::)かわりに、依存関係だけを記述して、GNU `make'
     にコマンドを提供させるようにすべきでしょう。

`dist'
     このプログラムに関するディストリビューション用のtarファイルの生成
     をします。ディストリビューション用のパッケージの名前であるサブディ
     レクトリ名を持つtarファイルのなかのファイル名を用いてtarファイル
     はセットされなければなりません。この名前にはバージョン番号も含み
     ます。

     たとえば、GCCバージョン1.40のディストリビューション用のtarファイ
     ルは、`gcc-1.40'という名前のサブディレクトリに展開されます。

     適切なサブディレクトリの名前を生成するためのもっとも簡単な方法は、
     適切なファイルをインストールするために`ln'あるいは`cp'を用いて、
     そのサブディレクトリでtarを実行することです。

     `gzip'を使用してtarファイルを圧縮します。たとえば、GCCバージョン
     1.40の実際のディストリビューションは`gcc-1.40.tar.gz'となっていま
     す。

     `dist'ターゲットは、ディストリビューションに含まれるソースでない
     ファイルに依存しているはずで、最新のものかどうかを確認してくださ
     い。*Note Making Releases: Releases.。*Note Making Releases:
     (standards)Releases.。

`check'
     セルフテストを実行します。テストを行なうまえにプログラムのビルド
     を行う必要がありますが、プログラムのインストロールを行う必要はあ
     りません。セルフテストはプログラムがビルドされて、しかしながらイ
     ンストールはされないように記述すべきです。

以下のターゲットは有益なプログラムとして、従来の名前で存在しています。

`installcheck'
     インストールのテストを実行します。テストを実行するまえにビルドと
     インストールが必要です。この際、サーチパスのなかに`$(bindir)'があ
     ると仮定してはいけません。

`installdirs'
     `installdirs'と名付けられたターゲットを、ファイルがインストールさ
     れるディレクトリと親ディレクトリを作成するために加えることは有益
     です。この場合、`mkinstalldirs'と呼ばれるスクリプトが便利です。こ
     のスクリプトはTexinfoパッケージに含まれていますし、
     `/gd/gnu/lib/mkinstalldirs'にあります。以下のようなルールを使用す
     ることができます。

          # Make sure all installation directories (e.g. $(bindir))
          # actually exist by making them if necessary.
          installdirs: mkinstalldirs
                  $(srcdir)/mkinstalldirs $(bindir) $(datadir) \
                                          $(libdir) $(infodir) \
                                          $(mandir)

     このルールは、コンパイルが行われるディレクトリの修正をしてはなら
     ず、インストールディレクトリの作成だけを行なうべきです。


File: make-jp.info  Node: Standard Targets-Footnotes, Up: Standard Targets

(1) `texi2dvi'はTeXを実際のフォーマット作業に用います。た
だし、TeXはTexinfoと一緒に配布はされません。



File: make-jp.info, Node: Install Command Categories

インストールコマンドのカテゴリー
================================

`install'ターゲットを記述する際は、コマンドを3つに分類する必要がありま
す。通常のコマンド、"pre-installation"コマンド、そして
"post-installation"コマンドです。

通常のコマンドは適切な場所にファイルを移動し、モードを設定します。パッ
ケージに含まれるコマンドを除いて、それらはいかなるファイルも変更するこ
とはできません。

インストール前とインストール後のコマンドは他のファイルを変更することが
できます。とくに、グローバルな設定ファイルやデータベースを編集すること
が可能です。

インストール前のコマンドは一般に、通常のコマンドよりもまえに実行されま
す。また、インストール後のコマンドは反対に通常のコマンドよりもあとに実
行されます。

インストール後のコマンドでもっとも一般的なのは`install-info'の実行です。
このコマンドは通常のコマンドでは実行されません。なぜなら、インストール
されたパッケージによるものでないファイル（Infoディレクトリ）を変更して
しまうからです。パッケージのInfoファイルをインストールする通常のコマン
ドのあとに実行される必要があるため、このコマンドはインストール後のコマ
ンドなのです。

多くのプログラムではインストール前のコマンドは必要としません、しかし、
必要な場合の特徴をあげます。

`install'ルールにおいてコマンドを3つのカテゴリーに分類するには、
"category lines"をそれらのあいだに挿入します。カテゴリー行は、それ以下
のコマンドのカテゴリーを特定します。

カテゴリー行は、タブと特別なMake変数への引用、そして場合によっては最後
のコメントからなっています。変数は3種類使用することができ、それぞれの
カテゴリーに対して1つあり、その名前がカテゴリーを特定します。通常の実
行においてはカテゴリー行はオプションなしです。なぜならこれらの3つの
Make変数は通常は*未定義である*からです（Makefileのなかで定義してはいけ
ません）。

3つのカテゴリー行を示します。それぞれ、何を表わすかのコメントもついて
います。

             $(PRE_INSTALL)     # Pre-install commands follow.
             $(POST_INSTALL)    # Post-install commands follow.
             $(NORMAL_INSTALL)  # Normal commands follow.

`install'ルールの先頭にカテゴリー行を使用しない場合は、最初のカテゴリー
行までは、通常のコマンドと分類されます。カテゴリー行を何も用いない場合
は、すべてのコマンドが通常のコマンドとして分類されます。

`uninstall'に対するカテゴリー行は、以下のようになります。

             $(PRE_UNINSTALL)     # Pre-uninstall commands follow.
             $(POST_UNINSTALL)    # Post-uninstall commands follow.
             $(NORMAL_UNINSTALL)  # Normal commands follow.

一般的に、インストール前のコマンドは、Infoディレクトリからエントリを削
除するのに用いられます。

`install'あるいは`uninstall'ターゲットがインストールのサブルーチンとし
てふるまう場合、カテゴリー行で*それぞれ*依存するコマンドを開始しなけれ
ばなりません。またその際に主たるターゲットのコマンドもカテゴリー行で開
始しなければなりません。そうすることによって、依存関係が実際にどう実行
されるかに関わらず、適切なカテゴリーにそれぞれのコマンドが置かれること
を保証できます。

インスト−ル前のあるいはインストール後のコマンドは、以下の事柄を除いて
どのようなコマンドも実行すべきではありません。

     [ basename bash cat chgrp chmod chown cmp cp dd diff echo
     egrep expand expr false fgrep find getopt grep gunzip gzip
     hostname install install-info kill ldconfig ln ls md5sum
     mkdir mkfifo mknod mv printenv pwd rm rmdir sed sort tee
     test touch true uname xargs yes

コマンドをこのように区別することの理由は、バイナリのパッケージを作るこ
とによります。一般的にバイナリのパッケージはインストールされるべき実行
ファイルとそのほかのファイルを含みます。そしてインストールのための独自
の方法を持ちます。そうすることによって通常のインストールコマンドを実行
する必要がなくなるのです。しかしながら、バイナリパッケージのインストー
ルはインストール前とインスト−ル後のコマンドを実行する必要があります。

バイナリパッケージをビルドするプログラムはインストール前とインストール
後のコマンドの展開によって動作します。ここにインストール前のコマンドの
展開の1つの方法を示します。

     make -n install -o all \
           PRE_INSTALL=pre-install \
           POST_INSTALL=post-install \
           NORMAL_INSTALL=normal-install \
       | gawk -f pre-install.awk

ファイル`pre-install.awk'は以下を含みます。

     $0 ~ /^\t[ \t]*(normal_install|post_install)[ \t]*$/ {on = 0}
     on {print $0}
     $0 ~ /^\t[ \t]*pre_install[ \t]*$/ {on = 1}

インストール前のコマンドの結果生じているファイルはバイナリパッケージの
インストールの一部としてシェルスクリプトのように実行されます。



File: make-jp.info, Node: Quick Reference, Next: Error Messages, Prev: Makefile Conventions, Up: Top

クイックリファレンス
********************

この付録では、ディレクティブ、テキスト操作ファンクション、そしてGNUの
`make'が理解しうる特別な変数などについて要約します。そのほかの要約につ
いては、*Note 特別な組み込み済みターゲット: Special Targets.、*Note 暗
黙のルールのカタログ: Catalogue of Rules.、*Note オプションのサマリー:
Options Summary.を参照してください。

GNUの`make'が認識可能なディレクティブは以下のものです。

`define VARIABLE'
`endef'

     複数行の定義、変数の再帰的展開。*Note コマンドの組み合わせの定義:
     Sequences.。

`ifdef VARIABLE'
`ifndef VARIABLE'
`ifeq (A,B)'
`ifeq "A" "B"'
`ifeq 'A' 'B''
`ifneq (A,B)'
`ifneq "A" "B"'
`ifneq 'A' 'B''
`else'
`endif'

     makefileの一部の条件の評価。*Note Makefileの条件文: Conditionals.。

`include FILE'
`-include FILE'
`sinclude FILE'

     ほかのmakefileのインクルード。*Note ほかのMakefileをインクルード
     する: Include.。

`override VARIABLE = VALUE'
`override VARIABLE := VALUE'
`override VARIABLE += VALUE'
`override VARIABLE ?= VALUE'
`override define VARIABLE'
`endef'

     変数の定義、コマンド行によるものも含めて、以前の定義のオーバーラ
     イド。*Note `override'ディレクティブ: Override Directive.。

`export'

     デフォルトで、子プロセスに対してすべての変数を`make'にエクスポー
     トさせる指示。*Note サブの`make'への変数の伝達:
     Variables/Recursion.。

`export VARIABLE'
`export VARIABLE = VALUE'
`export VARIABLE := VALUE'
`export VARIABLE += VALUE'
`export VARIABLE ?= VALUE'
`unexport VARIABLE'
     子プロセスに対して特定の変数を`make'にエクスポートさせるかどうか
     の指示。*Note サブの`make'への変数の伝達: Variables/Recursion.。

`vpath PATTERN PATH'
     `%'パターンにマッチするファイルに対してのパスのサーチ。*Note
     `vpath'ディレクティブ: Selective Search.。

`vpath PATTERN'
     PATTERNに対する以前に指定したすべてのサーチパスの削除。

`vpath'
     すべての`vpath'ディレクティブに対する以前に指定したすべてのサーチ
     パスの削除。

テキスト操作ファンクションの要約を示します（*Note テキスト変換のための
ファンクション: Functions..）。

`$(subst FROM,TO,TEXT)'
     TESTにおけるFROMのTOによる置換します。*Note 文字列の代用と分析の
     ファンクション: Text Functions.。

`$(patsubst PATTERN,REPLACEMENT,TEXT)'
     TESTにおけるREPLACEMENTとマッチするPATTERNの語の置換をします。
     *Note 文字列の代用と分析のファンクション: Text Functions.。

`$(strip STRING)'
     STRINGからの多すぎる空白の除去をします。*Note 文字列の代用と分析
     のファンクション: Text Functions.。

`$(findstring FIND,TEXT)'
     TEXTでFINDの位置をみつけます。*Note 文字列の代用と分析のファンク
     ション: Text Functions.。

`$(filter PATTERN...,TEXT)'
     TEXTのなかで、PATTERNの1つにマッチする語を選択します。*Note 文字
     列の代用と分析のファンクション: Text Functions.。

`$(filter-out PATTERN...,TEXT)'
     TEXTのなかで、PATTERNのどれにもマッチ*しない*語を選択します*Note 
     文字列の代用と分析のファンクション: Text Functions.。

`$(sort LIST)'
     LISTのなかで語をソートし、重複しているものを削除します。*Note 文
     字列の代用と分析のファンクション: Text Functions.。

`$(dir NAMES...)'
     個々のファイル名からディレクトリ部を展開します。*Note ファイル名
     に対するファンクション: File Name Functions.。

`$(notdir NAMES...)'
     個々のファイル名からディレクトリでない部分を展開します。*Note ファ
     イル名に対するファンクション: File Name Functions.。

`$(suffix NAMES...)'
     個々のファイル名のサフィックス（最後の`.'とそれに続く文字）を展開
     します。*Note ファイル名に対するファンクション: File Name
     Functions.。

`$(basename NAMES...)'
     個々のファイル名のベースネーム（サフィックスを除いた名前）を展開
     します。*Note ファイル名に対するファンクション: File Name
     Functions.。

`$(addsuffix SUFFIX,NAMES...)'
     NAMESにあるそれぞれの語にSUFFIXを追加します。*Note ファイル名に対
     するファンクション: File Name Functions.。

`$(addprefix PREFIX,NAMES...)'
     NAMESにあるそれぞれの語にPREFIXを先頭に追加します。*Note ファイル
     名に対するファンクション: File Name Functions.。

`$(join LIST1,LIST2)'
     2つの語のリストを結合します。*Note ファイル名に対するファンクショ
     ン: File Name Functions.。

`$(word N,TEXT)'
     TEXTのN番目の語を展開します。*Note ファイル名に対するファンクショ
     ン: File Name Functions.。

`$(words TEXT)'
     TEXTの語数をカウントします。*Note ファイル名に対するファンクショ
     ン: File Name Functions.。

`$(wordlist S,E,TEXT)'
     TEXTのなかのSからEまでのリストを返します。*Note ファイル名に対す
     るファンクション: File Name Functions.。

`$(firstword NAMES...)'
     NAMESの最初の語を展開します。*Note ファイル名に対するファンクショ
     ン: File Name Functions.。

`$(wildcard PATTERN...)'
     シェルのファイル名のパターン（`%'パターンでは*なく*）にマッチする
     ファイル名の発見をします。*Note ワイルドカードの機能: Wildcard
     Function.。

`$(error TEXT...)'

     このファンクションが評価される際は、`make'はメッセージTEXTを伴う
     致命的なエラーを起こします。*Note Makeをコントロールするファンク
     ション: Make Control Functions.。

`$(warning TEXT...)'

     このファンクションが評価される際は、`make'はメッセージTEXTを伴う
     ワーニングを発します。*Note Makeをコントロールするファンクション:
     Make Control Functions.。

`$(shell COMMAND)'

     シェルコマンドを実行し、出力を返します。*Note `shell'ファンクショ
     ン: Shell Function.。

`$(origin VARIABLE)'

     `make'の変数VARIABLEがどのように定義されたかを記述する文字列を返
     します。*Note `origin'ファンクション: Origin Function.。

`$(foreach VAR,WORDS,TEXT)'

     WORDSの個々の語で拘束されたVARによってTEXTを評価し、結果を連結し
     ます。*Note `foreach'ファンクション: Foreach Function.。

`$(call VAR,PARAM,...)'

     `$(1)'、すべての参照を置き換える変数VARを評価します。*Note `call'
     ファンクション: Call Function.。

自動変数の要約を示します。すべての情報は*Note 自動変数: Automatic.。

`$@'
     ターゲットのファイル名。

`$%'
     ターゲットがアーカイブメンバーであるときのターゲットメンバー名。

`$<'
     最初の必要条件の名前。

`$?'
     スペースで区切られた、ターゲットよりも新しいすべての必要条件の名
     前。アーカイブメンバーである必要条件に対してはメンバー名だけが使
     用されます（*Note アーカイブファイルのアップデートに`make'を 使用
     する: Archives..）。

`$^'
`$+'
     スペースで区切られたすべての必要条件の名前。アーカイブメンバーで
     ある必要条件に対してはメンバー名だけが使用されます（*Note アーカ
     イブファイルのアップデートに`make'を使用する: Archives..）。`$^'
     の値は`$+'がそれを保存し順序も保存するあいだは、重複した必要条件
     を省略します。

`$*'
     暗黙のルールがマッチするstem（*Note パターンマッチの方法: Pattern
     Match..）。

`$(@D)'
`$(@F)'
     `$@'のディレクトリ部とファイル名だけの部分。

`$(*D)'
`$(*F)'
     `$*'のディレクトリ部とファイル名だけの部分。

`$(%D)'
`$(%F)'
     `$%'のディレクトリ部とファイル名だけの部分。

`$(<D)'
`$(<F)'
     `$<'のディレクトリ部とファイル名だけの部分。

`$(^D)'
`$(^F)'
     `$^'のディレクトリ部とファイル名だけの部分。

`$(+D)'
`$(+F)'
     `$+'のディレクトリ部とファイル名だけの部分。

`$(?D)'
`$(?F)'
     `$?'のディレクトリ部とファイル名だけの部分。

これらの変数はGNUの`make'で特別に使用されます。

`MAKEFILES'

     `make'の呼び出しの際に毎回読み込まれるmakefile。*Note `MAKEFILES'
     の変数: MAKEFILES Variable.。

`VPATH'

     カレントディレクトリで発見されないファイルに対するディレクトリサー
     チパス。*Note `VPATH'：すべての必要条件のサーチパス: General
     Search.。

`SHELL'

     システムでデフォルトのコマンドインタープリタの名前で通常は
     `/bin/sh' です。コマンドを実行するシェルをmakefileのなかで`SHELL'
     にセットして変更することが可能です。*Note コマンド実行:
     Execution.。

`MAKESHELL'

     MS-DOSだけにおける、`make'で使用されるコマンドインタープリタの名
     前。この値は、`SHELL'の値よりも優先します。*Note MAKESHELL変数:
     Execution.。

`MAKE'

     `make'が呼び出される際の名前。コマンドでこの変数を使用する際は特
     別な意味を持ちます。*Note `MAKE'変数の働き: MAKE Variable.。

`MAKELEVEL'

     再帰的呼び出しのレベルの数。*Note サブの`make'への変数の伝達:
     Variables/Recursion.。

`MAKEFLAGS'

     `make'に与えられるフラグ。環境変数またはmakefileでセットできます。
     *Note サブの`make'へのオプションの伝達: Options/Recursion.。

     コマンド行で`MAKEFLAGS'ディレクトリを使用することは*決して* よい
     ことではありません。その理由は、シェルにおける使用に対してその内
     容が適切に引用されないことがあるからです。親プロセスから受け継い
     だ環境変数を通して`make'が再帰的にこれらの値を取得することはつね
     に許可されます。

`MAKECMDGOALS'

     コマンド行において`make'に与えられるターゲット。この変数をセット
     することは`make'の動作に何の影響も与えません。*Note ゴールを指定
     する引数: Goals.。

`CURDIR'

     カレントの作業用ディレクトリのパス名をセットします（もしあったと
     しても、`-C'オプションが処理されたあとで）。この変数をセットする
     ことは`make' の動作に何の影響も与えません。*Note `make'の再帰的用
     法: Recursion.。

`SUFFIXES'

     `make'がどのmakefileをも読み込むまえのデフォルトのサフィックスの
     リスト。

`.LIBPATTERNS'
     `make'がサーチするライブラリの名前付けと順序の定義。*Note リンク
     ライブラリに対するディレクトリサーチ: Libraries/Search.。



File: make-jp.info, Node: Error Messages, Next: Complex Makefile, Prev: Quick Reference, Up: Top

Makeが生成するエラー
********************

`make'が生成する非常に一般的なエラーのリストを示します。またそれらのエ
ラーがどのような意味を持ち、どう対処するかについても示します。

`make'のエラーは致命的でない場合もあります。とくにコマンドスクリプト行
にプレフィックス`-'がある場合、あるいはコマンド行に`-k'オプションがあ
る場合です。エラーが致命的な場合には、先頭に文字列`***'がつきます。

エラーメッセージは先頭にプログラムの名前（通常は`make'）がつくか、ある
いはmakefileでエラーが発見された場合はファイル名と問題のある行番号がつ
きます。

以下の一覧では、それらの共通のプレフィックスが残されます。


`[FOO] Error NN'
`[FOO] SIGNAL DESCRIPTION'
     これらのエラーは本当は`make'のエラーではありません。コマンドスク
     リプトの一部として`make'が呼び出したプログラムが0でないエラーコー
     ド（`Error NN'）を返し、それを`make'が失敗と解釈したもの、あるい
     は何かほかの異常な終了（なんらかのシグナルを伴う）の仕方をしたと
     いう意味です。*Note コマンドのエラー: Errors.。

     メッセージに`***'がつかず、サブプロセスが失敗している場合は、
     makefileのルールは`-'文字がつきます。その場合は`make'はエラーを無
     視します。

`missing separator.  Stop.'
`missing separator (did you mean TAB instead of 8 spaces?).  Stop.'
     これは、コマンドを読み込んだ`make'がそれを理解できないことを意味
     しています。GNUの`make'はさまざまな種類の区切り文字（`:'、`='、タ
     ブ文字など）を探してそのコマンド行の認識を助けようとします。これ
     も、適切なものをみつけられない場合です。

     このメッセージのもっとも一般的な理由（非常に便利な、多くの
     MS-Windowsのエディタの場合のように）は、タブ文字のかわりにスペー
     スを伴うコマンドスクリプトのインデントをしようとする場合です。こ
     の場合、`make'は2番目の書式のエラーを使用するでしょう。コマンドス
     クリプトのすべての行はタブ文字で始める必要があることを覚えておい
     てください。たとえば、8つのスペースはカウントされません。*Note ルー
     ルのシンタックス: Rule Syntax.。

`commands commence before first target.  Stop.'
`missing rule before commands.  Stop.'
     これは、makefileの先頭がコマンドスクリプトの一部のように見えると
     いう意味です。タブ文字で始まっているものの、（変数の割り当てのよ
     うな）正しい`make'のコマンドが現われない場合です。コマンドスクリ
     プトはつねにターゲットと関連している必要があります。

     行において最初の空白でない文字がセミコロンである場合に2番目の書式
     が生成されます。`make'はルールのセクション"target: prerequisite"
     を残していると解釈します。*Note ルールのシンタックス: Rule
     Syntax.。

`No rule to make target `XXX'.'
`No rule to make target `XXX', needed by `YYY'.'
     これは、`make'がターゲットのビルドが必要であると判断したものの、
     どのようにするかの明示的あるいは暗黙の命令（デフォルトのルールデー
     タベースも含めて）をmakefileで発見できないことを意味しています。

     ファイルのビルドを望む場合、ターゲットがどのようにビルドされるか
     を記述したルールをmakefileに追加する必要があります。ほかに考えら
     れる問題の原因はmakefileのなかのタイポ（ファイル名が違うなど）、
     あるいはソースツリーの不完全さ（ビルドの不要なファイルで、必要条
     件だけの場合）などです。

`No targets specified and no makefile found.  Stop.'
`No targets.  Stop.'
     前者は、コマンド行においてビルドされるべきターゲットを何も提供せ
     ず、`make'が読み込むべきmakefileをみつけられなかったことを意味し
     ています。後者は、なんらかのmakefileはみつかったものの、デフォル
     トターゲットが何も含まれていず、コマンドラインでも何も与えられて
     いない場合を意味しています。GNU `make'はこのような状況では何もで
     きません。*Note Makefile指定の引数: Makefile Arguments.。

`Makefile `XXX' was not found.'
`Included makefile `XXX' was not found.'
     コマンド行で指定されたmakefileがみつからなかった（1番目の書式）か、
     インクルードされたmakefileがみつからなかった場合（2番目の書式）。

`warning: overriding commands for target `XXX''
`warning: ignoring old commands for target `XXX''
     GNU `make'はターゲットごとに1つだけ指定されるコマンドを許可します
     （ダブルコロンルールを除いて）。コマンドを持つように定義されてい
     るターゲットにコマンドを与えた場合、このワーニングが示され、コマ
     ンドの2番目のセットが最初のセットを上書きしてしまいます。*Note 1
     つのターゲットに対する複数のルール: Multiple Rules.。

`Circular XXX <- YYY dependency dropped.'
     これは、ターゲットXXXの必要条件YYYのトレース後に、`make'が依存グ
     ラフにおけるループを発見したことを意味します。

`Recursive variable `XXX' references itself (eventually).  Stop.'
     これは、通常の（再帰的な）`make'の変数XXXを定義して、それが展開さ
     れたときに自身を参照しているということを示します。単純展開変数
     （`:='）を使用、あるいは追加演算子（`+='）の使用のどちらかにおい
     て許可されないことです。*Note 変数の使用法: Using Variables.。

`Unterminated variable reference.  Stop.'
     これは、変数あるいはファンクションの参照で、括弧あるいはブラケッ
     トを適切に閉じていないことを示しています。

`insufficient arguments to function `XXX'.  Stop.'
     これは、ファンクションに対して必要な数の引数を与えなかったことを
     意味しています。ファンクションの引数についての詳細なドキュメント
     を参照してください。*Note テキスト変換のためのファンクション:
     Functions.。

`missing target pattern.  Stop.'
`multiple target patterns.  Stop.'
`target pattern contains no `%'.  Stop.'
     これらは、静的なパターンルールが機能しない場合に生成されます。最
     初の意味は、ルールのターゲットセクションにおいてパターンが何もな
     いことを示しています。2番目の意味は、ターゲットセクションに複数の
     パターンがあることを意味しています。3番目の意味は、ターゲットがパ
     ターン文字（`%'）を含んでいないことを示しています。*Note 静的パター
     ンルールのシンタックス: Static Usage.。

`warning: -jN forced in submake: disabling jobserver mode.'
     このワーニングは、サブの`make'が通信可能なシステムにおけるパラレ
     ル実行に関連したエラーを`make'が検出した際に出されます（*Note サ
     ブの`make'へのオプションの伝達: Options/Recursion..）。また、再帰
     的な呼び出しの`make'プロセスが引数のリストに`-jN' （Nは1より大き
     い）を強制的に付加された場合にもこのワーニングが出されます。たと
     えば、`MAKE'環境変数に`make -j2'とセットした場合にこのワーニング
     が出されます。この場合、サブの`make'はほかの`make' プロセスと通信
     せず、自身が2つのジョブを持つように見せかけるでしょう。

`warning: jobserver unavailable: using -j1.  Add `+' to parent make rule.'
     `make'プロセスは通信が可能なように、親プロセスが子プロセスに情報
     を渡します。子プロセスが実際には`make'ではない場合、これが問題に
     なるため、親プロセスは、子プロセスが`make'であると認識した場合に
     だけ情報を渡します。親プロセスは通常のアルゴリズムを使用してこの
     決定を行ないます（*Note `MAKE'変数の働き: MAKE Variable..）。子プ
     ロセスが`make'であることを親プロセスが知らないでmakefileが構築さ
     れる場合、子プロセスは必要な情報の一部しか受け取ることができませ
     ん。このような場合、子プロセスはこのワーニングを生成し、連続した
     方法でそのビルドを継続します。




File: make-jp.info, Node: Complex Makefile, Next: Concept Index, Prev: Error Messages, Up: Top

複雑なMakefileの例
******************

ここにGNU `make'プログラムのmakefileがあり、それは比較的複雑なものです。

ここでは、最初のターゲットなのでデフォルトのゴールは`all'です。この
makefileの興味深い特徴は、`testpad.h'が`testpad'プログラムによって自動
的に作成されるソースファイルである点です。そして、そのプログラム自身は
`testpad.c'のコンパイルによるものです。

`make'あるいは`make all'と入力することで`make'が実行可能な`tar'、テー
プアクセスを提供する`rmt'デーモン、`tar.info'のInfoファイルを作成しま
す。

`make install'と入力すると、`tar'、`rmt'、`tar.info'の作成だけでなく、
それらのインストールも行ないます。

`make clean'と入力すると、`make'は`.o'ファイル、`tar'、`rmt'、
`testpad'、`testpad.h'、そして`core'ファイルをすべて削除します。

`make distclean'と入力すると、`make'は`make clean'と同じ削除以外に
`TAGS'、`Makefile'、そして`config.status'ファイルも削除します。（明ら
かではありませんが、このmakefileと`config.status'は`configure'プログラ
ムによって作成されたもので、これは`tar'の配布プログラムに含まれていま
す。しかし、ここではそれは表示されていません。）

`make realclean'と入力すると、`make'は`make distclean'のときと同じ削除
を行ない、さらに`tar.texinfo'から生成されたInfoファイルの削除も行ない
ます。

さらに、ここでは、配布キットを作成するためのターゲット`shar'と`dist'も
示されています。

     # Generated automatically from Makefile.in by configure.
     # Un*x Makefile for GNU tar program.
     # Copyright (C) 1991 Free Software Foundation, Inc.

     # This program is free software; you can redistribute
     # it and/or modify it under the terms of the GNU
     # General Public License ...
     ...
     ...

     SHELL = /bin/sh

     #### Start of system configuration section. ####

     srcdir = .

     # If you use gcc, you should either run the
     # fixincludes script that comes with it or else use
     # gcc with the -traditional option.  Otherwise ioctl
     # calls will be compiled incorrectly on some systems.
     CC = gcc -O
     YACC = bison -y
     INSTALL = /usr/local/bin/install -c
     INSTALLDATA = /usr/local/bin/install -c -m 644

     # Things you might add to DEFS:
     # -DSTDC_HEADERS        If you have ANSI C headers and
     #                       libraries.
     # -DPOSIX               If you have POSIX.1 headers and
     #                       libraries.
     # -DBSD42               If you have sys/dir.h (unless
     #                       you use -DPOSIX), sys/file.h,
     #                       and st_blocks in `struct stat'.
     # -DUSG                 If you have System V/ANSI C
     #                       string and memory functions
     #                       and headers, sys/sysmacros.h,
     #                       fcntl.h, getcwd, no valloc,
     #                       and ndir.h (unless
     #                       you use -DDIRENT).
     # -DNO_MEMORY_H         If USG or STDC_HEADERS but do not
     #                       include memory.h.
     # -DDIRENT              If USG and you have dirent.h
     #                       instead of ndir.h.
     # -DSIGTYPE=int         If your signal handlers
     #                       return int, not void.
     # -DNO_MTIO             If you lack sys/mtio.h
     #                       (magtape ioctls).
     # -DNO_REMOTE           If you do not have a remote shell
     #                       or rexec.
     # -DUSE_REXEC           To use rexec for remote tape
     #                       operations instead of
     #                       forking rsh or remsh.
     # -DVPRINTF_MISSING     If you lack vprintf function
     #                       (but have _doprnt).
     # -DDOPRNT_MISSING      If you lack _doprnt function.
     #                       Also need to define
     #                       -DVPRINTF_MISSING.
     # -DFTIME_MISSING       If you lack ftime system call.
     # -DSTRSTR_MISSING      If you lack strstr function.
     # -DVALLOC_MISSING      If you lack valloc function.
     # -DMKDIR_MISSING       If you lack mkdir and
     #                       rmdir system calls.
     # -DRENAME_MISSING      If you lack rename system call.
     # -DFTRUNCATE_MISSING   If you lack ftruncate
     #                       system call.
     # -DV7                  On Version 7 Unix (not
     #                       tested in a long time).
     # -DEMUL_OPEN3          If you lack a 3-argument version
     #                       of open, and want to emulate it
     #                       with system calls you do have.
     # -DNO_OPEN3            If you lack the 3-argument open
     #                       and want to disable the tar -k
     #                       option instead of emulating open.
     # -DXENIX               If you have sys/inode.h
     #                       and need it 94 to be included.

     DEFS =  -DSIGTYPE=int -DDIRENT -DSTRSTR_MISSING \
             -DVPRINTF_MISSING -DBSD42
     # Set this to rtapelib.o unless you defined NO_REMOTE,
     # in which case make it empty.
     RTAPELIB = rtapelib.o
     LIBS =
     DEF_AR_FILE = /dev/rmt8
     DEFBLOCKING = 20

     CDEBUG = -g
     CFLAGS = $(CDEBUG) -I. -I$(srcdir) $(DEFS) \
             -DDEF_AR_FILE=\"$(DEF_AR_FILE)\" \
             -DDEFBLOCKING=$(DEFBLOCKING)
     LDFLAGS = -g

     prefix = /usr/local
     # Prefix for each installed program,
     # normally empty or `g'.
     binprefix =

     # The directory to install tar in.
     bindir = $(prefix)/bin

     # The directory to install the info files in.
     infodir = $(prefix)/info

     #### End of system configuration section. ####

     SRC1 =  tar.c create.c extract.c buffer.c \
             getoldopt.c update.c gnu.c mangle.c
     SRC2 =  version.c list.c names.c diffarch.c \
             port.c wildmat.c getopt.c
     SRC3 =  getopt1.c regex.c getdate.y
     SRCS =  $(SRC1) $(SRC2) $(SRC3)
     OBJ1 =  tar.o create.o extract.o buffer.o \
             getoldopt.o update.o gnu.o mangle.o
     OBJ2 =  version.o list.o names.o diffarch.o \
             port.o wildmat.o getopt.o
     OBJ3 =  getopt1.o regex.o getdate.o $(RTAPELIB)
     OBJS =  $(OBJ1) $(OBJ2) $(OBJ3)
     AUX =   README COPYING ChangeLog Makefile.in  \
             makefile.pc configure configure.in \
             tar.texinfo tar.info* texinfo.tex \
             tar.h port.h open3.h getopt.h regex.h \
             rmt.h rmt.c rtapelib.c alloca.c \
             msd_dir.h msd_dir.c tcexparg.c \
             level-0 level-1 backup-specs testpad.c

     all:    tar rmt tar.info

     tar:    $(OBJS)
             $(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)

     rmt:    rmt.c
             $(CC) $(CFLAGS) $(LDFLAGS) -o $@ rmt.c

     tar.info: tar.texinfo
             makeinfo tar.texinfo

     install: all
             $(INSTALL) tar $(bindir)/$(binprefix)tar
             -test ! -f rmt || $(INSTALL) rmt /etc/rmt
             $(INSTALLDATA) $(srcdir)/tar.info* $(infodir)

     $(OBJS): tar.h port.h testpad.h
     regex.o buffer.o tar.o: regex.h
     # getdate.y has 8 shift/reduce conflicts.

     testpad.h: testpad
             ./testpad

     testpad: testpad.o
             $(CC) -o $@ testpad.o

     TAGS:   $(SRCS)
             etags $(SRCS)

     clean:
             rm -f *.o tar rmt testpad testpad.h core

     distclean: clean
             rm -f TAGS Makefile config.status

     realclean: distclean
             rm -f tar.info*

     shar: $(SRCS) $(AUX)
             shar $(SRCS) $(AUX) | compress \
               > tar-`sed -e '/version_string/!d' \
                          -e 's/[^0-9.]*\([0-9.]*\).*/\1/' \
                          -e q
                          version.c`.shar.Z

     dist: $(SRCS) $(AUX)
             echo tar-`sed \
                  -e '/version_string/!d' \
                  -e 's/[^0-9.]*\([0-9.]*\).*/\1/' \
                  -e q
                  version.c` > .fname
             -rm -rf `cat .fname`
             mkdir `cat .fname`
             ln $(SRCS) $(AUX) `cat .fname`
             tar chZf `cat .fname`.tar.Z `cat .fname`
             -rm -rf `cat .fname` .fname

     tar.zoo: $(SRCS) $(AUX)
             -rm -rf tmp.dir
             -mkdir tmp.dir
             -rm tar.zoo
             for X in $(SRCS) $(AUX) ; do \
                 echo $$X ; \
                 sed 's/$$/^M/' $$X \
                 > tmp.dir/$$X ; done
             cd tmp.dir ; zoo aM ../tar.zoo *
             -rm -rf tmp.dir



File: make-jp.info, Node: Concept Index, Next: Name Index, Prev: Complex Makefile, Up: Top

概念索引
********


* Menu:

* =:                            Flavors.                9.
* =:                            Setting.                4.
* +=:                           Appending.              4.
* ?=:                           Flavors.                116.
* :=:                           Flavors.                50.
* :=:                           Setting.                4.
* ?=:                           Setting.                4.
* `@' （コマンド内で）:         Echoing.                4.
* `*' （ワイルドカード）:       Wildcards.              5.
* `?' （ワイルドカード）:       Wildcards.              5.
* `[...]' （ワイルドカード）:   Wildcards.              5.
* 1つのターゲットに対するいくつかのルール: Multiple Rules.  4.
* 1つのターゲットに対する複数のルール: Double-Colon.    4.
* 1つのターゲットに対する複数のルール: Multiple Rules.  4.
* `.a':                         Archive Suffix Rules.   4.
* `all' （標準ターゲット）:     Goals.                  71.
* ar:                           Implicit Variables.     34.
* as:                           Catalogue of Rules.     76.
* as:                           Implicit Variables.     38.
* `--assume-new':               Instead of Execution.   48.
* `--assume-new':               Options Summary.        273.
* `--assume-new'（再帰的用法）: Options/Recursion.      21.
* `--assume-old':               Avoiding Compilation.   4.
* `--assume-old':               Options Summary.        155.
* `--assume-old'（再帰的用法）: Options/Recursion.      21.
* `-b':                         Options Summary.        9.
* 暗黙のルール:                 Implicit Rules.         4.
* 暗黙のルールと`VPATH':        Implicit/Search.        4.
* 暗黙のルールとディレクトリサーチ: Implicit/Search.    4.
* 暗黙のルールとは:             make Deduces.           4.
* 暗黙のルール（事前に定義された）: Catalogue of Rules.  4.
* 暗黙のルールの定義:           Makefile Contents.      16.
* 暗黙のルールの展開:           Reading Makefiles.      54.
* 引用する`%'（`vpath'）:       Selective Search.       35.
* 引用（コマンドの新しい行）:   Execution.              19.
* 引数による変数のオーバーライド: Overriding.           4.
* 引数によるオーバーライド（変数）: Overriding.         4.
* ターゲット固有の変数:         Target-specific.        4.
* ターゲット:                   Rule Syntax.            17.
* ターゲット:                   Rules.                  4.
* ターゲットとは:               Rule Introduction.      7.
* ターゲット（偽）:             Phony Targets.          4.
* ターゲット（強制的）:         Force Targets.          4.
* ターゲット（空の）:           Empty Targets.          4.
* ターゲット（1つに対する複数のルール）: Multiple Rules.  4.
* ターゲット（中断による削除）: Interrupts.             4.
* ターゲット（特別な組み込み済み）: Special Targets.    4.
* ターゲット（エラー時の削除）: Errors.                 60.
* ターゲット（複数）:           Multiple Targets.       4.
* ターゲット（パターンルールにおける複数の）: Pattern Intro.  48.
* ターゲットのtouch:            Instead of Execution.   26.
* ターゲットの展開:             Reading Makefiles.      54.
* ターゲットのクリーン:         Cleanup.                10.
* ターゲットのクリーン:         Simple Makefile.        83.
* ターゲットパターン（暗黙の）: Pattern Intro.          9.
* ターゲットパターン（静的）:   Static Usage.           15.
* ターゲットファイルの削除:     Errors.                 60.
* ターゲットファイルの削除:     Interrupts.             4.
* 何にでもマッチするルール:     Match-Anything Rules.   5.
* 何にでもマッチするルールを使用したオーバーライド: Overriding Makefiles.  12.
* 解釈（makefile）:             Reading Makefiles.      4.
* コメント（コマンド中の）:     Commands.               16.
* エコー（コマンド）:           Echoing.                4.
* コマンド行の変数:             Overriding.             4.
* コマンド:                     Rule Syntax.            25.
* コマンドとは:                 Rule Introduction.      7.
* コマンドライン変数定義（再帰的用法）: Options/Recursion.  16.
* コマンド（コメント）:         Commands.               16.
* コマンド（空の）:             Empty Commands.         4.
* コマンド（新しい行の引用）:   Execution.              19.
* コマンド（バックスラッシュ）: Execution.              19.
* コマンド（パラレル実行）:     Parallel.               4.
* コマンドのエコー:             Echoing.                4.
* コマンドのシーケンス:         Sequences.              4.
* コマンドの展開:               Shell Function.         4.
* コマンドの出力:               Echoing.                4.
* コマンドの書き方:             Commands.               4.
* コンパチビリティ:             Features.               4.
* コンパイラのためのフラグ:     Implicit Variables.     4.
* コンパイルのテスト:           Testing.                4.
* 環境（`SHELL'）:              Execution.              75.
* 環境（再帰的用法）:           Variables/Recursion.    4.
* 環境変数:                     Environment.            5.
* 環境変数からのオプションの設定: Options/Recursion.    73.
* 簡単なmakefile:               Simple Makefile.        4.
* ゴール:                       How Make Works.         9.
* ゴール（デフォルト）:         Rules.                  10.
* ゴール（指定の仕方）:         Goals.                  4.
* 偽のターゲット:               Phony Targets.          4.
* サーチ（文字列）:             Text Functions.         102.
* サーチアルゴリズム（暗黙のルール）: Implicit Rule Search.  4.
* 機能（欠けている）:           Missing.                4.
* 修正変数の参照:               Substitution Refs.      4.
* サイレントな操作:             Echoing.                4.
* 記述（ルール）:               Rules.                  4.
* サフィックス（変数の代用）:   Substitution Refs.      5.
* サフィックス（ファンクションをみつける）: File Name Functions.  42.
* サフィックスルール:           Suffix Rules.           4.
* サフィックスルール（アーカイブ）: Archive Suffix Rules.  4.
* サフィックスの追加:           File Name Functions.    67.
* サブディレクトリ（再帰的）:   Recursion.              4.
* サブの`make':                 Variables/Recursion.    4.
* 強制的なターゲット:           Force Targets.          4.
* 空白（変数の値）:             Flavors.                93.
* 空白の切り取り:               Text Functions.         78.
* 空のターゲット:               Empty Targets.          4.
* 空のターゲットによるレコードイベント: Empty Targets.  4.
* 空のコマンド:                 Empty Commands.         4.
* シグナル:                     Interrupts.             4.
* 新しい行の引用（コマンド）:   Execution.              19.
* 新しい行の引用（makefile）:   Simple Makefile.        40.
* 欠けている機能:               Missing.                4.
* シェルコマンド:               Simple Makefile.        72.
* シェルコマンド（ディレクトリサーチ）: Commands/Search.  4.
* シェルコマンド（ファンクション）: Shell Function.     4.
* シェルコマンドの実行:         Execution.              4.
* シェルのワイルドカード:       Include.                12.
* シェルのファイル名のパターン: Include.                12.
* シンタックス（ルール）:       Rule Syntax.            5.
* シンボルディレクトリ（アーカイブのアップデート）: Archive Symbols.  4.
* 計算された変数名:             Computed Names.         4.
* 計算された名前（変数）:       Computed Names.         4.
* 古いスタイルのサフィックスルール: Suffix Rules.       4.
* ジョブスロット:               Parallel.               4.
* ジョブスロット（再帰的用法）: Options/Recursion.      24.
* ジョブ（ロードによる制限）:   Parallel.               49.
* 語の繰り返し:                 Foreach Function.       4.
* 語の選択:                     File Name Functions.    106.
* 語のソート:                   Text Functions.         151.
* 語のリストの選択:             File Name Functions.    115.
* 語のリストへのジョイン:       File Name Functions.    89.
* 語のフィルタアウト:           Text Functions.         133.
* 語のフィルタリング:           Text Functions.         113.
* 語数を得る:                   File Name Functions.    125.
* スイッチ:                     Options Summary.        4.
* エクスポートの互換性:         Variables/Recursion.    93.
* すべての必要条件のリスト:     Automatic.              55.
* スペース（変数の値）:         Flavors.                93.
* スペースの切り取り:           Text Functions.         78.
* 組み込み済みの特別なターゲット: Special Targets.      4.
* チルダ（`~'）:                Wildcards.              10.
* 実行（コマンド）:             Execution.              4.
* 実行（代替）:                 Instead of Execution.   4.
* 実行（パラレル）:             Parallel.               4.
* 代用変数の参照:               Substitution Refs.      4.
* 単純な展開（変数）:           Flavors.                50.
* 単純な変数の展開:             Using Variables.        4.
* まったく同一の変数定義:       Defining.               4.
* 中間ターゲット（明示的な）:   Special Targets.        50.
* 中間ファイル:                 Chained Rules.          15.
* 中間ファイルの保存:           Chained Rules.          45.
* 中断:                         Interrupts.             4.
* 値:                           Using Variables.        4.
* 値（変数が取得する方法）:     Values.                 4.
* アップデート（アーカイブシンボルディレクトリ）: Archive Symbols.  4.
* 長すぎる引数:                 Options/Recursion.      54.
* 追加（変数）:                 Appending.              4.
* 設定（変数）:                 Setting.                4.
* 展開された先頭の語:           File Name Functions.    130.
* 展開のループ（変数）:         Flavors.                40.
* 静的なパターンルール:         Static Pattern.         4.
* 重複した語の削除:             Text Functions.         160.
* 重要なターゲット:             Special Targets.        34.
* 自動生成（必要条件）:         Automatic Prerequisites.  4.
* 自動生成（必要条件）:         Include.                43.
* 自動変数:                     Automatic.              4.
* 再コンパイル:                 Introduction.           23.
* 再コンパイルの回避:           Avoiding Compilation.   4.
* 再帰:                         Recursion.              4.
* 再帰的な変数の展開:           Flavors.                4.
* 再帰的な変数の展開:           Using Variables.        4.
* 再帰的に展開される変数:       Flavors.                4.
* 再帰的用法（環境）:           Variables/Recursion.    4.
* 再帰的用法（`-C'）:           Options/Recursion.      21.
* 再帰的用法（`-f'）:           Options/Recursion.      21.
* 再帰的用法（`-j'）:           Options/Recursion.      24.
* 再帰的用法（`MAKE'変数）:     MAKE Variable.          4.
* 再帰的用法（`-o'）:           Options/Recursion.      21.
* 再帰的用法（`-t'）:           MAKE Variable.          30.
* 再帰的用法（`-W'）:           Options/Recursion.      21.
* 再帰的用法（`-w'）:           -w Option.              20.
* 再帰的用法（ディレクトリの出力）: -w Option.          4.
* 再帰的用法（変数定義のコマンド行）: Options/Recursion.  16.
* 再帰的用法（変数）:           Variables/Recursion.    4.
* 再帰的用法（レベル）:         Variables/Recursion.    102.
* 再帰的用法（オプション）:     Options/Recursion.      4.
* ユーザー定義ファンクション:   Call Function.          4.
* ユーザーへのワーニング出力:   Make Control Functions.  36.
* テストコンパイル:             Testing.                4.
* 再構成（makefile）:           Remaking Makefiles.     5.
* 特別なターゲット:             Special Targets.        4.
* 再リンク:                     How Make Works.         43.
* 二次的なファイル:             Chained Rules.          45.
* 最後の手段のデフォルトルール: Last Resort.            4.
* エディタ:                     Introduction.           23.
* ディレクティブ:               Makefile Contents.      30.
* ディレクトリサーチと暗黙のルール: Implicit/Search.    4.
* ディレクトリサーチとリンクライブラリ: Libraries/Search.  4.
* ディレクトリサーチ（シェルコマンド）: Commands/Search.  4.
* ディレクトリサーチ（`VPATH'）: Directory Search.      4.
* ディレクトリサーチ（従来の）: Search Algorithm.       40.
* ディレクトリサーチのアルゴリズム: Search Algorithm.   4.
* ホームディレクトリ:           Wildcards.              10.
* ディレクトリ部:               File Name Functions.    15.
* ディレクトリ部ではない部分:   File Name Functions.    25.
* ディレクトリ（アーカイブシンボルのアップデート）: Archive Symbols.  4.
* ディレクトリの出力:           -w Option.              4.
* 失敗時のターゲットの削除:     Special Targets.        68.
* デフォルトゴール:             How Make Works.         9.
* デフォルトゴール:             Rules.                  10.
* デフォルトディレクトリ（インクルードされるmakefileの）: Include.  44.
* デフォルトルール（最後の手段）: Last Resort.          4.
* 順序（パターンルール）:       Pattern Intro.          56.
* 非互換性:                     Missing.                4.
* 標準入力:                     Parallel.               27.
* 標準への準拠:                 Overview.               13.
* エラー（コマンド）:           Errors.                 4.
* エラー（停止）:               Make Control Functions.  11.
* ドル記号（`$'、変数参照）:    Reference.              4.
* ドル記号（`$'、変数名）:      Computed Names.         4.
* ドル記号（`$'、ファンクションコール）: Syntax of Functions.  4.
* 必要条件:                     Rule Syntax.            38.
* 必要条件:                     Rules.                  4.
* 必要条件とは:                 Rule Introduction.      7.
* 必要条件（すべてのリスト）:   Automatic.              55.
* 必要条件（変更のリスト）:     Automatic.              45.
* 必要条件によるルールの組み合わせ: Combine By Prerequisite.  4.
* 必要条件のためのサーチパス(`VPATH'): Directory Search.  4.
* 必要条件の展開:               Reading Makefiles.      54.
* 必要条件の自動生成:           Include.                43.
* 必要条件の変更:               Static Pattern.         4.
* 必要条件のパターン（暗黙の）: Pattern Intro.          20.
* 必要条件のパターン（静的）:   Static Usage.           27.
* 必要条件へのサーチパスと暗黙のルール: Implicit/Search.  4.
* 必要条件へのサーチパスとリンクライブラリ: Libraries/Search.  4.
* ライブラリアーカイブ（サフィックスルール）: Archive Suffix Rules.  4.
* `#'（コメント）、コマンド中の: Commands.              16.
* `-'（コマンド内で）:          Errors.                 17.
* `\'（コマンド）:              Execution.              19.
* 文字列のサーチ:               Text Functions.         102.
* `~'（チルダ）:                Wildcards.              10.
* 保存（中間ファイル）:         Chained Rules.          45.
* `\'（`%'で引用される）:       Selective Search.       35.
* `\'（`%'で引用される）:       Static Usage.           34.
* `\'（`%'で引用される）:       Text Functions.         25.
* `%'（`\'で引用する）:         Selective Search.       35.
* `%'（`\'による引用）:         Static Usage.           34.
* `%'（`\'による引用）:         Text Functions.         25.
* +（`define'）:                Sequences.              45.
* -（`define'）:                Sequences.              45.
* @（`define'）:                Sequences.              45.
* `%'（`patsubst'での引用）:    Text Functions.         25.
* `%'（`vpath'による引用）:     Selective Search.       35.
* `%'（静的なパターン中の引用）: Static Usage.          34.
* `$'（変数参照）:              Reference.              4.
* `$'（変数名）:                Computed Names.         4.
* `$'（ルール中の）:            Rule Syntax.            29.
* ターミナルルール:             Match-Anything Rules.   5.
* 変更された必要条件のリスト:   Automatic.              45.
* `%'（パターンルールにおける）: Pattern Intro.         9.
* 変数:                         Using Variables.        4.
* 変数:                         Variables Simplify.     4.
* 変数（暗黙のルール）:         Automatic.              4.
* 変数（ターゲット固有）:       Target-specific.        4.
* 変数（参照の仕方）:           Reference.              4.
* 変数（コマンド行）:           Overriding.             4.
* 変数（コマンドラインでの再帰的用法）: Options/Recursion.  16.
* 変数（環境変数）:             Environment.            5.
* 変数（環境）:                 Variables/Recursion.    4.
* 変数（修正参照）:             Substitution Refs.      4.
* 変数（代用参照）:             Substitution Refs.      4.
* 変数（代用サフィックス）:     Substitution Refs.      5.
* 変数（値におけるスペース）:   Flavors.                93.
* 変数（再帰的な展開）:         Flavors.                4.
* 変数（名前における`$'）:      Computed Names.         4.
* 変数（未定義によるワーニング）: Options Summary.      282.
* 変数（ネストされた参照）:     Computed Names.         4.
* 変数（オーバーライド）:       Override Directive.     4.
* 変数（パターン固有）:         Pattern-specific.       4.
* 変数による簡素化:             Variables Simplify.     4.
* 変数のエクスポート:           Variables/Recursion.    4.
* 変数の単純な展開:             Flavors.                50.
* 変数のまったく同一の定義:     Defining.               4.
* 変数の定義:                   Makefile Contents.      23.
* 変数の設定:                   Setting.                4.
* 変数の展開のループ:           Flavors.                40.
* 変数の始まり:                 Origin Function.        4.
* 変数のフレーバー:             Flavors.                4.
* 変数はどのようにその値を取得するか: Values.           4.
* 変数への参照:                 Advanced.               4.
* 変数への参照:                 Reference.              4.
* 変数への追加:                 Appending.              4.
* クリーンアップ:               Cleanup.                4.
* リンクライブラリとディレクトリサーチ: Libraries/Search.  4.
* リンクライブラリとパターンマッチング: Libraries/Search.  4.
* リンク（事前に定義された）:   Catalogue of Rules.     85.
* リンクのためのライブラリ:     Libraries/Search.       4.
* 複数のターゲット:             Multiple Targets.       4.
* 複数のターゲット（パターンルール）: Pattern Intro.    48.
* `$'（ファンクションコール）:  Syntax of Functions.    4.
* アルゴリズム（ディレクトリサーチ）: Search Algorithm.  4.
* `::'ルール:                   Double-Colon.           4.
* ルール中の`$':                Rule Syntax.            29.
* ルール中のドル記号:           Rule Syntax.            29.
* ルール中のタブ:               Rule Introduction.      19.
* ルールとは:                   Rule Introduction.      4.
* ルール（暗黙）とは:           make Deduces.           4.
* ルール（暗黙の）:             Implicit Rules.         4.
* ルール（ターゲットに対する複数）: Multiple Rules.     4.
* ルール（静的なパターン対暗黙のルール）: Static versus Implicit.  4.
* ルール（静的なパターン）:     Static Pattern.         4.
* ルール（複数のターゲットを持つ）: Multiple Targets.   4.
* ルール（命令や必要条件のない）: Force Targets.        4.
* ルール（連鎖する暗黙の）:     Chained Rules.          5.
* ルール（パターン）:           Pattern Intro.          4.
* ルール（事前に定義された暗黙の）: Catalogue of Rules.  4.
* ルール（ダブルコロン（`::'））: Double-Colon.         4.
* ルールのターゲット:           Rule Syntax.            17.
* ルールのコマンド:             Commands.               4.
* ルールの記述:                 Rules.                  4.
* ルールのシンタックス:         Rule Syntax.            5.
* ルールの必要条件:             Rule Syntax.            38.
* ルールの連鎖:                 Chained Rules.          5.
* 名前（makefile）:             Makefile Names.         4.
* 問題とバグそして報告の仕方:   Bugs.                   4.
* 未定義の変数（ワーニング）:   Options Summary.        282.
* 明示的なルールの定義:         Makefile Contents.      9.
* 明示的なルールの展開:         Reading Makefiles.      54.
* 命令を導き出させる:           make Deduces.           4.
* ネストされた変数の参照:       Computed Names.         4.
* マクロ:                       Using Variables.        9.
* 従来のディレクトリサーチ:     Search Algorithm.       40.
* ロードによるジョブの制限:     Parallel.               49.
* ロードアベレージ:             Parallel.               49.
* `%'の引用（`patsubst'）:      Text Functions.         25.
* `%'の引用（静的なパターン）:  Static Usage.           34.
* 終了ステータス（エラー）:     Errors.                 4.
* ほかのmakefileのインクルード: Include.                4.
* =の展開:                      Reading Makefiles.      28.
* +=の展開:                     Reading Makefiles.      28.
* +=の展開:                     Reading Makefiles.      28.
* ?=の展開:                     Reading Makefiles.      28.
* 連続したコマンド:             Sequences.              4.
* 連続した行:                   Simple Makefile.        40.
* 連続した行のための`\':        Simple Makefile.        40.
* 削除（ターゲットファイル）:   Errors.                 60.
* 削除（ターゲットファイル）:   Interrupts.             4.
* 削除（重複した語）:           Text Functions.         160.
* 削除（クリーンアップ）:       Cleanup.                4.
* ワイルドカード:               Include.                12.
* ワイルドカード:               Wildcards.              4.
* ワイルドカード展開とパス名のバックスラッシュ: Wildcard Pitfall.  29.
* ワイルドカードとMS-DOS/MS-Windowsのバックスラッシュ: Wildcard Pitfall.  29.
* ワイルドカード（ファンクション）: File Name Functions.  143.
* ワイルドカード（アーカイブメンバー）: Archive Members.  36.
* ワイルドカードによる誤り:     Wildcard Pitfall.       4.
* ワイルドカードによる問題:     Wildcard Pitfall.       4.
* ワイルドカードの落とし穴:     Wildcard Pitfall.       4.
* ワイルドカードを用いたファイル名: Wildcards.          4.
* ワーニング（出力）:           Make Control Functions.  36.
* バグと報告の仕方:             Bugs.                   4.
* バグの報告:                   Bugs.                   4.
* バックスラッシュ（コマンド）: Execution.              19.
* バックスラッシュ（`%'で引用される）: Selective Search.  35.
* バックスラッシュ（`%'で引用される）: Static Usage.    34.
* バックスラッシュ（`%'で引用される）: Text Functions.  25.
* バックスラッシュ（連続した行のための）: Simple Makefile.  40.
* バッククォート:               Shell Function.         4.
* オーバーライド（makefile）:   Overriding Makefiles.   5.
* バイナリパッケージ:           Install Command Categories.  78.
* パーツ（makefileのルール）:   Rule Introduction.      4.
* パラレル実行:                 Parallel.               4.
* パラレル実行（オーバーライド）: Special Targets.      111.
* パラレル実行（アーカイブのアップデート）: Archive Pitfalls.  4.
* パターン固有の変数:           Pattern-specific.       4.
* パターンルール:               Pattern Intro.          4.
* パターンルール（静的）:       Static Pattern.         4.
* パターンルール（静的）:       Static Usage.           4.
* パターンルールの展開:         Reading Makefiles.      54.
* パターンルールの順序:         Pattern Intro.          56.
* 条件文:                       Conditionals.           5.
* 条件文の展開:                 If Function.            4.
* 条件変数の割り当て:           Flavors.                116.
* 条件による割り当て（変数）:   Flavors.                116.
* インストール後のコマンド:     Install Command Categories.  5.
* インストール前のコマンド:     Install Command Categories.  5.
* セカンダリターゲット:         Special Targets.        57.
* ポータビリティ:               Features.               4.
* インクルードされるmakefileのデフォルトディレクトリ: Include.  44.
* アセンブリのコンパイルのルール: Catalogue of Rules.   76.
* フラグ:                       Options Summary.        4.
* フィルタアウト（語）:         Text Functions.         133.
* ファイル（新しいと仮定する）: Instead of Execution.   48.
* ファイル（古いと仮定する）:   Avoiding Compilation.   4.
* ファイル（中間の）:           Chained Rules.          15.
* ファイル（再コンパイルの回避）: Avoiding Compilation.  4.
* フィルタリング（語）:         Text Functions.         113.
* ファイル名（makefile）:       Makefile Names.         4.
* ファイル名（ディレクトリ部ではない部分）: File Name Functions.  25.
* ファイル名（ディレクトリ部）: File Name Functions.    15.
* ファイル名（ベース名）:       File Name Functions.    56.
* ファイル名のサフィックス:     File Name Functions.    42.
* ファイル名のサフィックスの追加: File Name Functions.  67.
* ファイル名のプレフィックスの追加: File Name Functions.  78.
* ファイルの実体のないターゲット: Phony Targets.        4.
* ファイルのtouch:              Instead of Execution.   26.
* フレーバー（変数）:           Flavors.                4.
* ファンクション:               Functions.              4.
* ファンクション（シンタックス）: Syntax of Functions.  4.
* ファンクション（makeのコントロール）: Make Control Functions.  4.
* ファンクション（ユーザー定義の）: Call Function.      4.
* ファンクション（テキストのための）: Text Functions.   4.
* ファンクション（ファイル名に対する）: File Name Functions.  4.
* ファンクションの引数:         Syntax of Functions.    4.
* アーカイブシンボルディレクトリのアップデート: Archive Symbols.  4.
* オブジェクト:                 Variables Simplify.     13.
* 事前に定義されたルールと変数（出力）: Options Summary.  164.
* アーカイブメンバーターゲット: Archive Members.        4.
* アーカイブ:                   Archives.               4.
* アーカイブ（サフィックスルール）: Archive Suffix Rules.  4.
* タブ文字（コマンド内で）:     Rule Syntax.            25.
* アーカイブ（`-j'）:           Archive Pitfalls.       4.
* アーカイブ（パラレル実行）:   Archive Pitfalls.       4.
* ダブルコロンルール:           Double-Colon.           4.
* ブロークンパイプ:             Parallel.               27.
* オプション:                   Options Summary.        4.
* オプション（環境変数からの設定）: Options/Recursion.  73.
* オプション（makefileでの設定）: Options/Recursion.    73.
* オプション（再帰的用法）:     Options/Recursion.      4.
* プレフィックスの追加:         File Name Functions.    78.
* 指定の仕方（makefileの名前）: Makefile Names.         30.
* ベース名:                     File Name Functions.    56.
* .c:                           Catalogue of Rules.     28.
* .C:                           Catalogue of Rules.     33.
* `-C':                         Options Summary.        16.
* `-C':                         Recursion.              19.
* `-C'と`-w':                   -w Option.              20.
* `-C'（再帰的用法）:           Options/Recursion.      21.
* Cのコンパイルのルール:        Catalogue of Rules.     28.
* C++のコンパイルのルール:      Catalogue of Rules.     33.
* cc:                           Catalogue of Rules.     28.
* cc:                           Implicit Variables.     42.
* .cc:                          Catalogue of Rules.     33.
* `cd'（シェルコマンド）:       Execution.              9.
* `cd'（シェルコマンド）:       MAKE Variable.          15.
* .ch:                          Catalogue of Rules.     154.
* `check' （標準ターゲット）:   Goals.                  125.
* `clean' （標準ターゲット）:   Goals.                  75.
* `clobber' （標準ターゲット）: Goals.                  90.
* co:                           Catalogue of Rules.     171.
* co:                           Implicit Variables.     50.
* ctangle:                      Catalogue of Rules.     154.
* ctangle:                      Implicit Variables.     114.
* cweave:                       Catalogue of Rules.     154.
* cweave:                       Implicit Variables.     106.
* `.d':                         Automatic Prerequisites.  82.
* `-d':                         Options Summary.        26.
* `--debug':                    Options Summary.        36.
* .def:                         Catalogue of Rules.     69.
* defineの展開:                 Reading Makefiles.      28.
* `--directory':                Options Summary.        18.
* `--directory':                Recursion.              19.
* `--directory'と`--print-directory': -w Option.        20.
* `--directory'（再帰的用法）:  Options/Recursion.      21.
* `dist' （標準ターゲット）:    Goals.                  115.
* `distclean' （標準ターゲット）: Goals.                86.
* `--dry-run':                  Echoing.                15.
* `--dry-run':                  Instead of Execution.   18.
* `--dry-run':                  Options Summary.        143.
* .dvi:                         Catalogue of Rules.     154.
* `-e':                         Options Summary.        72.
* `-e' （シェルフラグ）:        Automatic Prerequisites.  68.
* E2BIG:                        Options/Recursion.      54.
* Emacs （`M-x compile'）:      Errors.                 59.
* `--environment-overrides':    Options Summary.        74.
* .F:                           Catalogue of Rules.     44.
* .f:                           Catalogue of Rules.     44.
* `-f':                         Makefile Arguments.     4.
* `-f':                         Makefile Names.         21.
* `-f':                         Options Summary.        79.
* f77:                          Catalogue of Rules.     44.
* f77:                          Implicit Variables.     60.
* `-f'（再帰的用法）:           Options/Recursion.      21.
* `--file':                     Makefile Arguments.     4.
* `--file':                     Makefile Names.         21.
* `--file':                     Options Summary.        81.
* `--file'（再帰的用法）:       Options/Recursion.      21.
* Fortranのコンパイルのルール:  Catalogue of Rules.     44.
* g++:                          Catalogue of Rules.     33.
* g++:                          Implicit Variables.     46.
* gcc:                          Catalogue of Rules.     28.
* get:                          Catalogue of Rules.     181.
* get:                          Implicit Variables.     64.
* GNU `make'の機能:             Features.               4.
* `-h':                         Options Summary.        88.
* `--help':                     Options Summary.        90.
* `-i':                         Errors.                 28.
* `-I':                         Include.                44.
* `-I':                         Options Summary.        102.
* `-i':                         Options Summary.        95.
* IEEE標準 1003.2:              Overview.               13.
* ifdefの展開:                  Reading Makefiles.      47.
* ifeqの展開:                   Reading Makefiles.      47.
* ifndefの展開:                 Reading Makefiles.      47.
* ifneqの展開:                  Reading Makefiles.      47.
* `--ignore-errors':            Errors.                 28.
* `--ignore-errors':            Options Summary.        97.
* `#include':                   Automatic Prerequisites.  18.
* `--include-dir':              Include.                44.
* `--include-dir':              Options Summary.        104.
* .info:                        Catalogue of Rules.     163.
* Infoのフォーマットのルール:   Catalogue of Rules.     163.
* `install' （標準ターゲット）: Goals.                  97.
* `-j':                         Options Summary.        111.
* `-j':                         Parallel.               4.
* `-j'（再帰的用法）:           Options/Recursion.      24.
* `-j'（アーカイブのアップデート）: Archive Pitfalls.   4.
* `--jobs':                     Options Summary.        113.
* `--jobs':                     Parallel.               4.
* `--jobs'（再帰的用法）:       Options/Recursion.      24.
* `--just-print':               Echoing.                15.
* `--just-print':               Instead of Execution.   18.
* `--just-print':               Options Summary.        141.
* `-k':                         Errors.                 43.
* `-k':                         Options Summary.        121.
* `-k':                         Testing.                14.
* `--keep-going':               Errors.                 43.
* `--keep-going':               Options Summary.        123.
* `--keep-going':               Testing.                14.
* kill:                         Interrupts.             4.
* .l:                           Catalogue of Rules.     124.
* `-l':                         Options Summary.        129.
* `-l' （ライブラリサーチ）:    Libraries/Search.       4.
* `-l' （ロードアベレージ）:    Parallel.               49.
* ld:                           Catalogue of Rules.     85.
* lex:                          Catalogue of Rules.     124.
* lex:                          Implicit Variables.     69.
* Lexのコンパイルのルール:      Catalogue of Rules.     124.
* `.LIBPATTERNS'（リンクライブラリ）: Libraries/Search.  4.
* lint:                         Catalogue of Rules.     147.
* `lint'の実行のルール:         Catalogue of Rules.     147.
* .ln:                          Catalogue of Rules.     147.
* `--load-average':             Options Summary.        131.
* `--load-average':             Parallel.               49.
* `lpr'（シェルコマンド）:      Empty Targets.          23.
* `lpr'（シェルコマンド）:      Wildcard Examples.      20.
* `-m':                         Options Summary.        11.
* `-M' （コンパイラへ）:        Automatic Prerequisites.  19.
* m2c:                          Catalogue of Rules.     69.
* `make depend':                Automatic Prerequisites.  37.
* `make'がどのようにmakefileを処理するのか: How Make Works.  4.
* Makeのコントロール:           Make Control Functions.  4.
* makeの停止:                   Make Control Functions.  11.
* `make'のルールのデータベース: Options Summary.        164.
* `MAKECMDGOALS':               Goals.                  26.
* makefile:                     Introduction.           7.
* `--makefile':                 Makefile Arguments.     4.
* `--makefile':                 Makefile Names.         21.
* `--makefile':                 Options Summary.        83.
* makefile中の`#'命令:          Makefile Contents.      43.
* makefile中の命令:             Makefile Contents.      43.
* makefileでのオプションの設定: Options/Recursion.      73.
* makefileの解釈:               Reading Makefiles.      4.
* makefileの規約:               Makefile Conventions.   4.
* makefileの新しい行の引用:     Simple Makefile.        40.
* makefileのアップデート:       Remaking Makefiles.     5.
* makefileの再構成:             Remaking Makefiles.     5.
* makefileのデフォルトの名前:   Makefile Names.         4.
* makefileの処理:               How Make Works.         4.
* makefileのルールのパーツ:     Rule Introduction.      4.
* makefileの名前:               Makefile Names.         4.
* makefileの名前の指定の仕方:   Makefile Names.         30.
* makefileの約束ごと:           Makefile Conventions.   4.
* makefileのオーバーライド:     Overriding Makefiles.   5.
* makefileの書き方:             Makefiles.              5.
* makefileのインクルード:       Include.                4.
* makefileの指定:               Makefile Names.         30.
* `MAKEFILES'の変数:            MAKEFILES Variable.     4.
* `MAKEFILES'の変数の再帰的用法: MAKEFILES Variable.    13.
* `MAKEFILES'の変数のインクルード: MAKEFILES Variable.  4.
* makeinfo:                     Catalogue of Rules.     163.
* makeinfo:                     Implicit Variables.     88.
* `--max-load':                 Options Summary.        133.
* `--max-load':                 Parallel.               49.
* `-MM' （GNUコンパイラへ）:    Automatic Prerequisites.  69.
* .mod:                         Catalogue of Rules.     69.
* Modula-2のコンパイルのルール: Catalogue of Rules.     69.
* `mostlyclean' （標準ターゲット）: Goals.              79.
* `-n':                         Echoing.                15.
* `-n':                         Instead of Execution.   18.
* `-n':                         Options Summary.        139.
* `--new-file':                 Instead of Execution.   48.
* `--new-file':                 Options Summary.        271.
* `--new-file'（再帰的用法）:   Options/Recursion.      21.
* `--no-builtin-rules':         Options Summary.        186.
* `--no-builtin-variables':     Options Summary.        202.
* `--no-keep-going':            Options Summary.        222.
* `--no-print-directory':       Options Summary.        260.
* `--no-print-directory':       -w Option.              20.
* .o:                           Catalogue of Rules.     28.
* .o:                           Catalogue of Rules.     85.
* `-o':                         Avoiding Compilation.   4.
* `-o':                         Options Summary.        151.
* `OBJ':                        Variables Simplify.     19.
* `obj':                        Variables Simplify.     19.
* `OBJECTS':                    Variables Simplify.     19.
* `-o'（再帰的用法）:           Options/Recursion.      21.
* `OBJS':                       Variables Simplify.     19.
* `objs':                       Variables Simplify.     19.
* `--old-file':                 Avoiding Compilation.   4.
* `--old-file':                 Options Summary.        153.
* `--old-file'（再帰的用法）:   Options/Recursion.      21.
* `override'を使ったオーバーライド: Override Directive.  4.
* .p:                           Catalogue of Rules.     39.
* `-p':                         Options Summary.        162.
* Pascalのコンパイルのルール:   Catalogue of Rules.     39.
* pc:                           Catalogue of Rules.     39.
* pc:                           Implicit Variables.     73.
* POSIX:                        Overview.               13.
* POSIX.2:                      Options/Recursion.      57.
* `.PRECIOUS'中間ファイル:      Chained Rules.          57.
* `.PRECIOUS'による保持:        Special Targets.        34.
* `.PRECIOUS'を用いた保存:      Chained Rules.          57.
* `print' （標準ターゲット）:   Goals.                  103.
* `print'ターゲット:            Empty Targets.          23.
* `print'ターゲット:            Wildcard Examples.      20.
* `--print-data-base':          Options Summary.        164.
* `--print-directory':          Options Summary.        251.
* `--print-directory'と`--directory': -w Option.        20.
* `--print-directory'（再帰的用法）: -w Option.         20.
* `--print-directory'（使用停止）: -w Option.           20.
* `-q':                         Instead of Execution.   35.
* `-q':                         Options Summary.        175.
* `--question':                 Instead of Execution.   35.
* `--question':                 Options Summary.        177.
* questionモード:               Instead of Execution.   35.
* `--quiet':                    Echoing.                21.
* `--quiet':                    Options Summary.        214.
* .r:                           Catalogue of Rules.     44.
* `-r':                         Options Summary.        184.
* `-R':                         Options Summary.        200.
* Ratforのコンパイルのルール:   Catalogue of Rules.     44.
* RCSの展開される場合のルール:  Catalogue of Rules.     171.
* `README':                     Makefile Names.         8.
* `realclean' （標準ターゲット）: Goals.                88.
* `--recon':                    Echoing.                15.
* `--recon':                    Instead of Execution.   18.
* `--recon':                    Options Summary.        145.
* rm:                           Implicit Variables.     118.
* `rm'（シェルコマンド）:       Errors.                 25.
* `rm'（シェルコマンド）:       Phony Targets.          19.
* `rm'（シェルコマンド）:       Simple Makefile.        83.
* `rm'（シェルコマンド）:       Wildcard Examples.      11.
* .s:                           Catalogue of Rules.     76.
* .S:                           Catalogue of Rules.     79.
* `-s':                         Echoing.                21.
* `-s':                         Options Summary.        210.
* `-S':                         Options Summary.        220.
* s. (SCCS file prefix):        Catalogue of Rules.     181.
* SCCSの展開される場合のルール: Catalogue of Rules.     181.
* `.SECONDARY'による保持:       Special Targets.        57.
* `sed'（シェルコマンド）:      Automatic Prerequisites.  73.
* .sh:                          Catalogue of Rules.     188.
* `shar' （標準ターゲット）:    Goals.                  111.
* `SHELL'（MS-DOS仕様）:        Execution.              35.
* `--silent':                   Echoing.                21.
* `--silent':                   Options Summary.        212.
* stem:                         Pattern Match.          5.
* stem:                         Static Usage.           15.
* stem変数:                     Automatic.              68.
* `--stop':                     Options Summary.        224.
* .sym:                         Catalogue of Rules.     69.
* `__.SYMDEF':                  Archive Symbols.        4.
* `-t':                         Instead of Execution.   26.
* `-t':                         Options Summary.        233.
* `TAGS' （標準ターゲット）:    Goals.                  121.
* tangle:                       Catalogue of Rules.     154.
* tangle:                       Implicit Variables.     110.
* `tar' （標準ターゲット）:     Goals.                  107.
* `-t'（再帰的用法）:           MAKE Variable.          30.
* `test' （標準ターゲット）:    Goals.                  127.
* tex:                          Catalogue of Rules.     154.
* tex:                          Implicit Variables.     93.
* .tex:                         Catalogue of Rules.     154.
* TeXの実行ルール:              Catalogue of Rules.     154.
* .texi:                        Catalogue of Rules.     163.
* texi2dvi:                     Catalogue of Rules.     163.
* texi2dvi:                     Implicit Variables.     98.
* .texinfo:                     Catalogue of Rules.     163.
* Texinfoのフォーマットのルール: Catalogue of Rules.    163.
* `--touch':                    Instead of Execution.   26.
* `--touch':                    Options Summary.        235.
* `touch'（シェルコマンド）:    Empty Targets.          23.
* `touch'（シェルコマンド）:    Wildcard Examples.      20.
* `--touch'（再帰的用法）:      MAKE Variable.          30.
* .txinfo:                      Catalogue of Rules.     163.
* `-v':                         Options Summary.        242.
* ,v (RCS file extension):      Catalogue of Rules.     171.
* `--version':                  Options Summary.        244.
* vpath:                        Directory Search.       4.
* `VPATH'と暗黙のルール:        Implicit/Search.        4.
* `VPATH'とリンクライブラリ:    Libraries/Search.       4.
* .w:                           Catalogue of Rules.     154.
* `-W':                         Instead of Execution.   48.
* `-w':                         Options Summary.        249.
* `-W':                         Options Summary.        267.
* `--warn-undefined-variables': Options Summary.        282.
* `-w'と`-C':                   -w Option.              20.
* `-W'（再帰的用法）:           Options/Recursion.      21.
* `-w'（再帰的用法）:           -w Option.              20.
* `-w'（使用停止）:             -w Option.              20.
* weave:                        Catalogue of Rules.     154.
* weave:                        Implicit Variables.     102.
* .web:                         Catalogue of Rules.     154.
* Webの実行ルール:              Catalogue of Rules.     154.
* what if:                      Instead of Execution.   48.
* `--what-if':                  Instead of Execution.   48.
* `--what-if':                  Options Summary.        269.
* .y:                           Catalogue of Rules.     119.
* yacc:                         Catalogue of Rules.     119.
* yacc:                         Implicit Variables.     78.
* `yacc':                       Sequences.              17.
* Yaccのコンパイルのルール:     Catalogue of Rules.     119.



Info file: make-jp.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `make-jp.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.







INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Make: (make).            Remake files automatically.
END-INFO-DIR-ENTRY


This file documents the GNU Make utility, which determines
automatically which pieces of a large program need to be recompiled,
and issues the commands to recompile them.

This is Edition 0.55, last updated 04 April 2000, of `The GNU Make
Manual', for `make', Version 3.79.

Copyright (C) 1988, '89, '90, '91, '92, '93, '94, '95, '96, '97, '98,
'99, 2000 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.




File: make-jp.info, Node: Name Index, Prev: Concept Index, Up: Top

関数/変数/ディレクティブ索引
****************************


* Menu:

* $@:                           Automatic.              17.
* $%:                           Automatic.              25.
* $<:                           Automatic.              33.
* $?:                           Automatic.              39.
* $^:                           Automatic.              46.
* $+:                           Automatic.              56.
* $*:                           Automatic.              62.
* * （自動変数）サポートされない驚異的な使用方法: Missing.  65.
* @ （自動変数）:               Automatic.              17.
* % （自動変数）:               Automatic.              25.
* < （自動変数）:               Automatic.              33.
* ? （自動変数）:               Automatic.              39.
* ^ （自動変数）:               Automatic.              46.
* + （自動変数）:               Automatic.              56.
* * （自動変数）:               Automatic.              62.
* addprefix:                    File Name Functions.    78.
* addsuffix:                    File Name Functions.    67.
* AR:                           Implicit Variables.     33.
* ARFLAGS:                      Implicit Variables.     104.
* AS:                           Implicit Variables.     37.
* ASFLAGS:                      Implicit Variables.     109.
* basename:                     File Name Functions.    56.
* $*（静的なルール）:           Static Usage.           77.
* call:                         Call Function.          4.
* CC:                           Implicit Variables.     41.
* CFLAGS:                       Implicit Variables.     114.
* CO:                           Implicit Variables.     49.
* COFLAGS:                      Implicit Variables.     122.
* COMSPEC:                      Execution.              32.
* CPP:                          Implicit Variables.     53.
* CPPFLAGS:                     Implicit Variables.     126.
* CTANGLE:                      Implicit Variables.     113.
* CWEAVE:                       Implicit Variables.     105.
* CXX:                          Implicit Variables.     45.
* CXXFLAGS:                     Implicit Variables.     118.
* $(*D):                        Automatic.              108.
* $(%D):                        Automatic.              114.
* $(<D):                        Automatic.              124.
* $(^D):                        Automatic.              130.
* $(?D):                        Automatic.              136.
* $(@D):                        Automatic.              97.
* *D （自動変数）:              Automatic.              108.
* %D （自動変数）:              Automatic.              114.
* <D （自動変数）:              Automatic.              124.
* ^D （自動変数）:              Automatic.              130.
* ?D （自動変数）:              Automatic.              136.
* @D （自動変数）:              Automatic.              97.
* .DEFAULT:                     Last Resort.            22.
* .DEFAULT:                     Special Targets.        22.
* .DEFAULT（空白のコマンド）:   Empty Commands.         14.
* define:                       Defining.               4.
* .DELETE_ON_ERROR:             Errors.                 60.
* .DELETE_ON_ERROR:             Special Targets.        66.
* dir:                          File Name Functions.    15.
* else:                         Conditional Syntax.     4.
* endef:                        Defining.               4.
* endif:                        Conditional Syntax.     4.
* error:                        Make Control Functions.  11.
* export:                       Variables/Recursion.    33.
* .EXPORT_ALL_VARIABLES:        Special Targets.        102.
* .EXPORT_ALL_VARIABLES:        Variables/Recursion.    87.
* $(@F):                        Automatic.              103.
* $(*F):                        Automatic.              110.
* $(%F):                        Automatic.              116.
* $(<F):                        Automatic.              126.
* $(^F):                        Automatic.              132.
* $(?F):                        Automatic.              138.
* @F （自動変数）:              Automatic.              103.
* *F （自動変数）:              Automatic.              110.
* %F （自動変数）:              Automatic.              116.
* <F （自動変数）:              Automatic.              126.
* ^F （自動変数）:              Automatic.              132.
* ?F （自動変数）:              Automatic.              138.
* FC:                           Implicit Variables.     58.
* FFLAGS:                       Implicit Variables.     131.
* filter:                       Text Functions.         113.
* filter-out:                   Text Functions.         133.
* findstring:                   Text Functions.         102.
* firstword:                    File Name Functions.    130.
* foreach:                      Foreach Function.       4.
* GET:                          Implicit Variables.     63.
* GFLAGS:                       Implicit Variables.     135.
* GNUmakefile:                  Makefile Names.         7.
* GPATH:                        Search Algorithm.       45.
* if:                           If Function.            4.
* ifdef:                        Conditional Syntax.     4.
* ifeq:                         Conditional Syntax.     4.
* ifndef:                       Conditional Syntax.     4.
* ifneq:                        Conditional Syntax.     4.
* .IGNORE:                      Errors.                 28.
* .IGNORE:                      Special Targets.        74.
* include:                      Include.                5.
* .INTERMEDIATE:                Special Targets.        48.
* join:                         File Name Functions.    89.
* LDFLAGS:                      Implicit Variables.     139.
* LEX:                          Implicit Variables.     67.
* LFLAGS:                       Implicit Variables.     143.
* .LIBPATTERNS:                 Libraries/Search.       4.
* MAKE:                         Flavors.                74.
* MAKE:                         MAKE Variable.          4.
* MAKECMDGOALS:                 Goals.                  26.
* Makefile:                     Makefile Names.         7.
* makefile:                     Makefile Names.         7.
* MAKEFILES:                    MAKEFILES Variable.     5.
* MAKEFILES:                    Variables/Recursion.    113.
* MAKEFLAGS:                    Options/Recursion.      5.
* MAKEINFO:                     Implicit Variables.     86.
* MAKELEVEL:                    Flavors.                74.
* MAKELEVEL:                    Variables/Recursion.    102.
* MAKEOVERRIDES:                Options/Recursion.      46.
* MFLAGS:                       Options/Recursion.      60.
* notdir:                       File Name Functions.    25.
* .NOTPARALLEL:                 Special Targets.        109.
* origin:                       Origin Function.        4.
* OUTPUT_OPTION:                Catalogue of Rules.     193.
* override:                     Override Directive.     4.
* patsubst:                     Substitution Refs.      24.
* patsubst:                     Text Functions.         19.
* PC:                           Implicit Variables.     72.
* PFLAGS:                       Implicit Variables.     147.
* .PHONY:                       Phony Targets.          20.
* .PHONY:                       Special Targets.        7.
* .POSIX:                       Options/Recursion.      57.
* .PRECIOUS:                    Interrupts.             21.
* .PRECIOUS:                    Special Targets.        32.
* RFLAGS:                       Implicit Variables.     151.
* RM:                           Implicit Variables.     117.
* .SECONDARY:                   Special Targets.        55.
* SHELL:                        Execution.              29.
* shell:                        Shell Function.         4.
* SHELL （コマンド実行）:       Execution.              4.
* .SILENT:                      Echoing.                21.
* .SILENT:                      Special Targets.        88.
* sort:                         Text Functions.         151.
* strip:                        Text Functions.         78.
* subst:                        Multiple Targets.       26.
* subst:                        Text Functions.         9.
* suffix:                       File Name Functions.    42.
* SUFFIXES:                     Suffix Rules.           80.
* .SUFFIXES:                    Special Targets.        15.
* .SUFFIXES:                    Suffix Rules.           59.
* TANGLE:                       Implicit Variables.     109.
* TEX:                          Implicit Variables.     91.
* TEXI2DVI:                     Implicit Variables.     96.
* unexport:                     Variables/Recursion.    39.
* /usr/gnu/include:             Include.                44.
* /usr/include:                 Include.                44.
* /usr/local/include:           Include.                44.
* VPATH:                        Directory Search.       4.
* vpath:                        Directory Search.       4.
* VPATH:                        General Search.         4.
* vpath:                        Selective Search.       4.
* warning:                      Make Control Functions.  36.
* WEAVE:                        Implicit Variables.     101.
* wildcard:                     File Name Functions.    143.
* wildcard:                     Wildcard Function.      4.
* word:                         File Name Functions.    106.
* wordlist:                     File Name Functions.    115.
* words:                        File Name Functions.    125.
* YACC:                         Implicit Variables.     76.
* YACCR:                        Implicit Variables.     81.
* YFLAGS:                       Implicit Variables.     155.


